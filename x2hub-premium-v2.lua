local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("X2hub premium V2", "BloodTheme")

local Tab = Window:NewTab("Converted Scripts")
local Section = Tab:NewSection("Converted from SS to FE *melon is a pedo*")

Section:NewButton("The Boys", "ButtonInfo", function()
    print("Clicked")
script = game:GetObjects("rbxassetid://7473297462")[1].BoysAreBack
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

--require(4781464455)() -- Converter

--// SHORTCUTS \\--
local S =setmetatable({},{__index=function(s,i)local serv = select(2,pcall(game.GetService,game,i))if(serv)then rawset(s,i,serv) return serv end end})
local RNG = (function()
	local R=Random.new()
	return function(min,max,intOrDivider)
		local min=min or 0
		local max=max or 1
		
		if(typeof(intOrDivider)=='number')then
			return R:NextInteger(min,max)/intOrDivider
		else
			if(intOrDivider)then
				return R:NextInteger(min,max)
			else
				return R:NextNumber(min,max)
			end
		end
	end
end)()

local M = {R=math.rad;RNG=RNG;RRNG=function(...)return math.rad(RNG(...))end;P=math.pi;C=math.clamp;S=math.sin;C=math.cos;T=math.tan;AS=math.asin;AC=math.acos;AT=math.atan;D=math.deg;H=math.huge;}
local CF = {N=CFrame.new;A=CFrame.Angles;fEA=CFrame.fromEulerAnglesXYZ;}
local C3 = {N=Color3.new;RGB=Color3.fromRGB;HSV=function(...)local data={...}if(typeof(data[1])=='Color3')then return Color3.toHSV(...)else return Color3.fromHSV(...)end;end;}
local V3 = {N=Vector3.new};
local IN = Instance.new;
local R3 = Region3.new

--// START OF THE SCRIPT \\--
local Title = 'T h e  B o y s';
local Info = "The boys are back in town!\n(To kill you)\nMouse 1 - Behead\n(Hold) Z - Cleave\n\nB - Kick\nK - Switch camera"

local Creator = game:service'Players':GetNameFromUserIdAsync(5719877)

warn(string.format([[
	%s
		%s
		
		Created by %s
]],Title,Info:gsub("\n","\n\t\t"),Creator))

-- Initialization --

local Plr = game:GetService("Players").LocalPlayer;
local PlrGui = Plr:FindFirstChildOfClass'PlayerGui'
local Char = Plr.Character;
local Hum = Char:FindFirstChildOfClass'Humanoid'
assert(Hum and Hum.RigType==Enum.HumanoidRigType.R6,"You need to have a Humanoid and be R6.")
local RArm = Char:WaitForChild'Right Arm'
local LArm = Char:WaitForChild'Left Arm'
local Torso = Char:WaitForChild'Torso'
local RLeg = Char:WaitForChild'Right Leg'
local LLeg = Char:WaitForChild'Left Leg'
local Head = Char:WaitForChild'Head'
local Root = Char:WaitForChild'HumanoidRootPart'
local Puddle = script:WaitForChild'Puddle'
Puddle.Parent=nil
local Liquid = script:WaitForChild'Drop'
Liquid.Parent=nil
local LiqSplash = script:WaitForChild'Splash'
local NeutralAnims = true;
local Attack = false;
local KickAction = false;
local targetnnn = nil;
local Corpses = Instance.new("Folder")
Corpses.Name='Corpses'
Corpses.Parent=workspace.Terrain

local DmgLabel = script:WaitForChild'DMGPart'
local CritStars =script:WaitForChild'Crit'
local Mouse = Plr:GetMouse()
local EffectFolder=Instance.new("Folder")
EffectFolder.Name='Effects'
EffectFolder.Parent=Char
local ProjectileFolder = Instance.new("Folder")
ProjectileFolder.Name='Projectiles'
ProjectileFolder.Parent=EffectFolder
local Cloud = script:WaitForChild'Cloud'
Cloud.Parent=nil
local Blood = script:WaitForChild'Blood'
Blood.Parent=nil

local FXFolder = script:WaitForChild'Effects'
FXFolder.Parent=nil
local Joints = {}
local Sine = 0
local Change = 1
local CamCFrame=CFrame.new()
local Puddles = {}
local CamFollowing=Head;
local Dead={}

--script:WaitForChild'FX'.Disabled=false

local fxRemote = {}
local Plr = game:service'Players'.localPlayer
local Chr = Plr.Character;
local Hum = Chr:FindFirstChildOfClass'Humanoid'
local Root = Chr:WaitForChild'HumanoidRootPart'
local Head = Chr:WaitForChild'Head'
local ProjectileFolder = Chr:WaitForChild'Effects':WaitForChild'Projectiles'
local ProjRemoteN = false
local fxRemoteN = false
--local Parabola = require(script:WaitForChild'Parabola')
local Projectiles={}
local Cam = workspace.CurrentCamera
local FJConn;

function Tween(object,properties,time,style,dir,repeats,reverse,delay)
	local info = TweenInfo.new(time or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,repeats or 0,reverse or false,delay or 0)
	local tween = game:service'TweenService':Create(object,info,properties)
	tween:Play()
	return tween;
end

local fromaxisangle = function(x, y, z) -- credit to phantom forces devs
	if not y then
		x, y, z = x.x, x.y, x.z
	end
	local m = (x * x + y * y + z * z) ^ 0.5
	if m > 1.0E-5 then
		local si = math.sin(m / 2) / m
		return CFrame.new(0, 0, 0, si * x, si * y, si * z, math.cos(m / 2))
	else
		return CFrame.new()
	end
end

function fakePhysics(elapsed,cframe,velocity,acceleration)
	--[[local pos = cframe.p
	local matrix = cframe-pos
	return fromaxisangle(elapsed*rotation)*matrix+pos+elapsed*velocity+elapsed*elapsed*acceleration]]

	return CFrame.new((0.5*acceleration*elapsed*elapsed+velocity*elapsed+cframe.p))

end

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function ValuesToTable(c)
	local Tbl={}
	for i,v in next,c do
		if(v:IsA'ValueBase')then
			local name = typeof(tonumber(v.Name))=='number' and tonumber(v.Name) or v.Name
			Tbl[name]=v.Value
		elseif(v:IsA'Folder')then
			local name = typeof(tonumber(v.Name))=='number' and tonumber(v.Name) or v.Name
			Tbl[name]=ValuesToTable(v:children())
		end
	end	
	return Tbl
end

fxRemoteN = (function(data)
	if(Chr==Plr.Character)then
		local type = data.Type;
		if(type=='Projectile')then
			data.Start=tick();
			data.Part.CFrame=data.Origin
			data.Ignorelist=data.Ignorelist or {}
			data.Distance=0;
			table.insert(Projectiles,data)
		elseif(type=='CamFollowJoint')then
			if(FJConn)then
				FJConn:disconnect()
				FJConn=nil;
			end
			if(not data.Disconnect)then
				local joint = data.Joint
				FJConn=joint.J.Changed:connect(function()
					if(Chr~=Plr.Character and Chr~=Plr.Character.Model  and FJConn)then FJConn:disconnect();FJConn=nil; end
					local difference = (joint.D.C0*joint.J.C0:inverse())*(joint.D.C1*joint.J.C1:inverse())
					Hum.CameraOffset=difference.p
				end)
			end
		elseif(type=='CamFollowPart')then
			Tween(Hum,{CameraOffset=Vector3.new()},.5,Enum.EasingStyle.Quad)
			if(FJConn)then
				FJConn:disconnect()
				FJConn=nil;
			end
			local part = data.Part
			if(part)then
				local difference = Root.CFrame:ToObjectSpace(part.CFrame)
				Tween(Hum,{CameraOffset=difference.p-Vector3.new(0,1.5,0)},0)
				FJConn=game:service'RunService'.Stepped:connect(function ()
					if(Chr~=Plr.Character and Chr~=Plr.Character.Model  and FJConn)then FJConn:disconnect();FJConn=nil; end
					local difference = Root.CFrame:ToObjectSpace(part.CFrame)
					Hum.CameraOffset=difference.p-Vector3.new(0,1.5,0)
				end)
			end
		end
	else
		if(Chr~=Plr.Character and Chr~=Plr.Character.Model  and FJConn)then FJConn:disconnect();FJConn=nil; end
		--fxRemote:destroy()
	end
end)

ProjectileFolder.ChildAdded:connect(function(c)
	local data=ValuesToTable(c:WaitForChild'Values':children());
	print'added'
	if(data.ID)then
		data.Start=tick();
		data.Part.CFrame=data.Origin
		data.Ignorelist=data.Ignorelist or {}
		data.Distance=0;
		table.insert(Projectiles,data)
	end	
end)

function IsDescendantOfPlayer(p)
	for _,v in next, game:service'Players':players()do
		if(v.Character)then 
			if(p:IsDescendantOf(v.Character))then
				return true
			end
		end
	end
	return false
end

local PConn;
PConn=game:service'RunService'.Heartbeat:connect(function(dt)
	if(Chr~=Plr.Character and Chr~=Plr.Character.Model  and PConn)then PConn:disconnect(); PConn=nil; end
	for i,v in next, Projectiles do
		if(not PConn)then break end
		local Hit,Pos,Norm;
		local Distance = v.Distance;
		local Stop=false;
		if(tick()-v.Start>(v.Lifetime or 10))then
			Stop=true;
		else
			local trElapsed = tick()-v.Start
			local newCF = v.Part.CFrame
			local prevCF = v.PrevCF or v.Origin
			local dist = (prevCF.p-newCF.p).magnitude
			local hit,pos,norm = CastRay(prevCF.p,newCF.p,dist,v.Ignorelist)
			if(hit)then
				newCF = CFrame.new(pos,pos+norm)
			end
			v.PrevCF=newCF
			if(prevCF)then
				local Beam=v.Part:FindFirstChildOfClass'Beam'
				if(Beam and v.BeamProjectile)then
					local A0,A1 = Beam.Attachment0,Beam.Attachment1
					if(A0 and A1 and A0.Parent and A1.Parent)then
						A0.Parent.CFrame=prevCF
						--A0.Parent.Orientation=Vector3.new(prevCF:ToOrientation())
						A1.Parent.CFrame=newCF
						--A1.Parent.Orientation=Vector3.new(newCF:ToOrientation())
					end
				end
			end
			if(hit and ((v.IgnoreUnanchored and not hit.Anchored) or (v.IgnoreHumanoids and (IsDescendantOfPlayer(hit) or hit.Parent:FindFirstChildOfClass'Humanoid')) or (v.IgnoreInvisibility and hit.Transparency>=.9) or (v.IgnoreUncollidables and not hit.CanCollide)))then
				if(not v.IgnoreExceptions or not table.find(v.IgnoreExceptions,hit))then
					table.insert(v.Ignorelist,hit)
					hit=nil
				end
			end
			if(hit)then
				Stop=true;
				Hit=hit;
				Pos=pos;
				Norm=norm;
			end

		end

		if(Stop)then
			Projectiles[i]=nil
			fxRemote:FireServer(v.ID,Hit,Pos,Norm,v.Ignorelist)
		end
	end
end)

function fxRemote:FireServer(...)
	if ProjRemoteN then ProjRemoteN(...) end
end

fxRemote:FireServer("CamUpdate",Cam.CFrame)
Cam:GetPropertyChangedSignal("CFrame"):connect(function()
	fxRemote:FireServer("CamUpdate",Cam.CFrame)
end)



local ProjRemote = {}

function ProjRemote:FireClient(...)
	if fxRemoteN then fxRemoteN(...) end
end
local Projectiles = {}


Vector3Sequence={}
Vector3SequenceKeypoint={}

Vector3SequenceKeypoint.new = function(time,value,envelope)
	--bad argument #2 to 'new' (number expected, got Vector3)
	assert(typeof(time)=='number',"bad argument #1 to 'new' (number expected, got "..typeof(time))
	assert(typeof(value)=='Vector3',"bad argument #2 to 'new' (Vector3 expected, got "..typeof(value))
	return {Time=time,Value=value,Envelope=envelope}
end

Vector3Sequence.new = function(...)
	local tuple={...}
	if(#tuple==2)then
		return Vector3Sequence.new{Vector3SequenceKeypoint.new(0,tuple[1]),Vector3SequenceKeypoint.new(1,tuple[2])}
	else
		local thing = tuple[1]
		if(typeof(thing)=='Vector3')then
			return Vector3Sequence.new(thing,thing)
		elseif(typeof(thing)=='table')then
			assert(#thing>=2,"Vector3Sequence: requires at least 2 keypoints")
			local last;
			for i,v in next, thing do
				assert(v.Value and v.Time and typeof(v.Value)=='Vector3',"expected 'Vector3SequenceKeypoint' at index "..i)
				if(not last or v.Time>last)then
					last=v.Time
				else
					error("Vector3Sequence: all keypoints must be ordered by time")
				end
			end
			return setmetatable({
				Keypoints=thing;
			},{__index=Vector3Sequence})
		else
			return error("table of Vector3SequenceKeypoints expected.")
		end
	end
end

--return {Vector3Sequence,Vector3SequenceKeypoint}

CFrameSequence={}
CFrameSequenceKeypoint={}

CFrameSequenceKeypoint.new = function(time,value,envelope)
	--bad argument #2 to 'new' (number expected, got CFrame)
	assert(typeof(time)=='number',"bad argument #1 to 'new' (number expected, got "..typeof(time))
	assert(typeof(value)=='CFrame',"bad argument #2 to 'new' (CFrame expected, got "..typeof(value))
	return {Time=time,Value=value,Envelope=envelope}
end

CFrameSequence.new = function(...)
	local tuple={...}
	if(#tuple==2)then
		return CFrameSequence.new{CFrameSequenceKeypoint.new(0,tuple[1]),CFrameSequenceKeypoint.new(1,tuple[2])}
	else
		local thing = tuple[1]
		if(typeof(thing)=='CFrame')then
			return CFrameSequence.new(thing,thing)
		elseif(typeof(thing)=='table')then
			assert(#thing>=2,"CFrameSequence: requires at least 2 keypoints")
			local last;
			for i,v in next, thing do
				assert(v.Value and v.Time and typeof(v.Value)=='CFrame',"expected 'CFrameSequenceKeypoint' at index "..i)
				if(not last or v.Time>last)then
					last=v.Time
				else
					error("CFrameSequence: all keypoints must be ordered by time")
				end
			end
			return setmetatable({
				Keypoints=thing;
			},{__index=CFrameSequence})
		else
			return error("table of CFrameSequenceKeypoints expected.")
		end
	end
end

--return {CFrameSequence,CFrameSequenceKeypoint}

--local Vector3Sequence,Vector3SequenceKeypoint = unpack(require(script:WaitForChild'Vector3Sequence'))
--local CFrameSequence,CFrameSequenceKeypoint = unpack(require(script:WaitForChild'CFrameSequence'))

-- Info UI --
local InfoUI = script:WaitForChild'InfoUI'
InfoUI.Parent=PlrGui
local InfoFr = InfoUI:WaitForChild'InfoUI'

InfoFr:WaitForChild'Title'.Text = Title
InfoFr:WaitForChild'Info'.Text = Info
InfoFr:WaitForChild'Credit'.Text = "Created by " .. Creator

-- Instance Functions --
--require(7163376902) -- Makes instances work
local baseSound = IN("Sound")
function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or workspace
	if(autoPlay)then
		Sound:Play()
	end
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	part.Parent = parent
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	weld.Parent = part0
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = Part(EffectFolder,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),cf,true,false)
	soundPart.Transparency=1
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound
end

function Joint(name,part0,part1,c0,c1,type)
	local joint = IN(type or "Motor6D")
	joint.Part0 = part0
	joint.Part1 = part1
	joint.C0 = c0 or CF.N()
	joint.C1 = c1 or CF.N()
	joint.Parent=part0
	joint.Name=name or part0.." to "..part1.." "..joint.ClassName
	return joint
end

function NewInstance(instance,parent,properties)if(properties.Parent)then properties.Parent=parent end;local new = IN(instance)if(properties)then for prop,val in next, properties do pcall(function() new[prop]=val end)end;end;new.Parent=parent;return new;end

-- Customization --
local DamageColor = Color3.new(1,0,0)
local WalkSpeed = 16
local MusicData = {ID=4973799797;Pitch=.75;Volume=1;}
local Soundgroup = script:WaitForChild'SoundGroup'
local MaxPuddles = 500;

-- Joints and Manipulation --

function IsAllowedAccessory(handle)
	local Attachments={"BodyBackAttachment","BodyFrontAttachment","LeftCollarAttachment","RightCollarAttachment","WaistFrontAttachment","WaistCenterAttachment","WaistBackAttachment"}
	for i = 1,#Attachments do
		if(handle:FindFirstChild(Attachments[i]))then
			return true
		end
	end
	return false
end

local Accessories = {}
for _,v in next, Char:GetDescendants()do
	if(v:IsA'BasePart' and v.Parent:IsA'Accessory' and not IsAllowedAccessory(v))then
		table.insert(Accessories,{v,v.Transparency})
		--v.Transparency=1
	end
end

local Axe = script:WaitForChild'Axe'
Axe.Parent=Char
Axe.PrimaryPart.Anchored=false

local AxeHat = gp(gp(gp(cnnnnn, "FireaxeAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
AxeHat.Parent = Axe.PrimaryPart
AxeHat.Rotation = Vector3.new(-0, 0, 90)

local Hitbox = Axe:WaitForChild'Blade'


spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		
		if Attack == true and NeutralAnims == false and KickAction == false then
			GlobalFunctions.fling(Hitbox,0)
		end
		if Attack == true and NeutralAnims == false and KickAction == true then
			if targetnnn ~= nil then
				GlobalFunctions.fling(targetnnn)
				wait(0.2)
				targetnnn = nil
			end
		end
	end
end)


local Morph = script:WaitForChild'Morph'
for _,v in pairs(Morph:GetDescendants()) do
	if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1


	end
end
--Head.Transparency=1  
--Hat Pumpkin 5857617173  
--Hood 4932728913
--Cape 7284314095
--Axe 5555611932
-- -gh 5857617173,4932728913,7284314095,5555611932
--Head:ClearAllChildren()

local HueShift = {
	[344016870]={H=.73,S=1,V=1};--.73;
--	[19342912]={H=.57,S=1,V=.5};
	[407695969]={H=.9,S=.7,V=1};
--	[45322272]={H=0,S=1,V=.4};
--	[407695969]={H=.07,S=.7,V=.8};
}

if(HueShift[Plr.CharacterAppearanceId])then
	local m = HueShift[Plr.CharacterAppearanceId]
	for _,v in next, Morph.Head:GetDescendants()do
		if(v:IsA'BasePart')then
			if(v.Name~='Hood' and v.Name~='Cone')then
				local H,S,V=C3.HSV(v.Color)
				v.Color=C3.HSV(math.clamp(m.H,0,1),math.clamp(S*m.S,0,1),math.clamp(V*m.V,0,1))
			end
		elseif(v:IsA'ParticleEmitter')then
			if(v.Name~='Smoke')then
				local newSequence={}
				for i = 1,#v.Color.Keypoints do
					local H,S,V=C3.HSV(v.Color.Keypoints[i].Value)
					table.insert(newSequence,ColorSequenceKeypoint.new(v.Color.Keypoints[i].Time,C3.HSV(math.clamp(m.H,0,1),math.clamp(S*m.S,0,1),math.clamp(V*m.V,0,1))))
				end
				v.Color=ColorSequence.new(newSequence)
				
			end
		end
	end
end

for _,v in next, Char:children() do
	if(Morph:FindFirstChild(v.Name))then
		local part = Morph[v.Name]
		part.Parent=Char
		part:SetPrimaryPartCFrame(v.CFrame)
		for _,c in next, part:GetDescendants() do
			if(c:IsA'BasePart' and c~=part.PrimaryPart)then
				c.Massless=true
				c.Anchored=false
				local j = Weld(v,c,CFrame.new(),c.CFrame:inverse()*v.CFrame)
				c.CanCollide=false
			end
		end
		part.PrimaryPart:destroy()
	end
end

function GetJoint(joint)
	for i,v in next, Joints do
		if(i==joint or v.J==joint)then
			return v,i;
		end
	end	
	return nil;
end

function getLength(table)local len=0;for i,v in next,table do len=len+1 end;return len;end
function getFirstEntry(table)for i,v in next,table do return i,v end;return nil;end

function Animate(joint,props,alpha,style,dir)
	local joint = typeof(joint)=='string' and Joints[joint].J or typeof(joint)=='table' and joint.J or typeof(joint)=='Instance' and joint or error("lol animate needs a string, table or instance")
	local propName='C0'
	if(typeof(props)=='table' and getLength(props)==1 and select(2,getFirstEntry(props)).lerp)then
		propName,props=getFirstEntry(props)
	end
	
	if(style=='Lerp' and props.lerp)then
		joint[propName] = joint[propName]:lerp(props,alpha)
	else
		if(typeof(props)=='CFrame')then
			props={C0=props}
		end
		local info = TweenInfo.new(alpha or 1,(style~='Lerp' and style) or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,0,false,0)
		local tween = S.TweenService:Create(joint,info,props)
		tween:Play();
		return tween;
	end
end

Joints['RJ'] = Joint("RootJoint",Root,Torso,CF.N(),CF.N())
Joints['NK'] = Joint("Neck",Torso,Head,CF.N(0,1.5,0),CF.N())
Joints['LS'] = Joint("Left Shoulder",Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0))
Joints['RS'] = Joint("Right Shoulder",Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0))
Joints['LH'] = Joint("Left Hip",Torso,LLeg,CF.N(-.5,-2,0),CF.N(0,0,0))
Joints['RH'] = Joint("Right Hip",Torso,RLeg,CF.N(.5,-2,0),CF.N(0,0,0))
Joints['HW'] = Joint("Handle",RArm,Axe.PrimaryPart,CF.N(0,-1,0)*CF.A(M.R(-90),M.R(180),M.R(-90)))

for i,v in next, Joints do Joints[i]={J=v,D={C0=v.C0,C1=v.C1}} end

for _,v in next, Char:GetDescendants() do
	if(v:IsA'JointInstance' and not GetJoint(v) and (v.Name:find("Hip") or v.Name:find("Shoulder") or v.Name=='Neck' or v.Name:find("Root")))then
		--v:destroy()
	end
end


-- Artificial Heartbeat --
local AHB = Instance.new("BindableEvent")
do
	local Timeframe = 0;
	local LastFrame= 0;
	
	local FPS = 60
	AHB:Fire()
	
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		Timeframe = Timeframe + s
		if(Timeframe >= 1/FPS)then
			for i = 1, math.floor(Timeframe/(1/FPS)) do
				AHB:Fire()
			end
			LastFrame = tick()
			Timeframe = Timeframe - (1/FPS) * math.floor(Timeframe / (1/FPS))
		end
	end)
end

function fwait(Frames)
	for i = 1,((typeof(Frames)~='number' or Frames<=0) and 1 or Frames)do
		AHB.Event:wait()
	end
end

-- Stop Animations --
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')
-- Effect Functions --

function CamshakePlayer(p,settings)
	local sh = script:WaitForChild'CamShake':Clone()	
	local optionFolder = sh:WaitForChild'Options'
	for _,v in next, optionFolder:children() do
		if(settings[v.Name])then
			v.Value=settings[v.Name]
		end
	end
	local originVal;
	if(typeof(settings.Origin)=='Vector3')then
		originVal=IN("Vector3Value")
	elseif(typeof(settings.Origin)=='CFrame')then
		originVal=IN("CFrameValue")
	elseif(typeof(settings.Origin)=='Instance')then
		originVal=IN("ObjectValue")
	end
	if(originVal)then
		originVal.Name = 'Origin'
		originVal.Value = settings.Origin
		originVal.Parent=optionFolder
	end
	local parent = p.Character or p:FindFirstChildOfClass'Backpack' or p:FindFirstChildOfClass'PlayerGui'
	if(parent)then
		local nig = sh:Clone();
		nig.Parent=parent
		nig.Disabled=false
		S.Debris:AddItem(nig,(settings.Duration or 2)+1)
	end
end

function Camshake(settings)
	for _,p in next, game:service'Players':players() do
		CamshakePlayer(p,settings)
	end
end

function Tween(object,properties,time,style,dir,repeats,reverse,delay)
	local info = TweenInfo.new(time or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,repeats or 0,reverse or false,delay or 0)
	local tween = S.TweenService:Create(object,info,properties)
	tween:Play()
	return tween;
end

local function numLerp(Start,Finish,Alpha)
    return Start + (Finish- Start) * Alpha
end

function IsValidEnum(val,enum,def)
	local enum = Enum[tostring(enum)]
	local succ,err=pcall(function() return enum[val.Name] end)
	if(not err)then
		return val
	else
		return def
	end
end

function IsValid(val,type,def)
	if(typeof(type)=='string')then
		return (typeof(val)==type and val or def)
	elseif(typeof(type)=='table')then
		for i,v in next, type do
			if(typeof(val)==v)then
				return val
			end
		end
	end
	return def
end

function LiquidPuddle(hit,pos,normal,color,mat,size,lerpSize)
	local size = size or M.RNG(.5,1.5)
	if(not Puddles[hit])then
		local C3C=typeof(color)=='BrickColor' and color.Color or color
		local splat = Puddle:Clone();
		local weldConstraint=IN("WeldConstraint")
		if(not hit.Anchored)then
			weldConstraint.Parent=splat
			weldConstraint.Part0=hit
			weldConstraint.Part1=splat
			splat.Anchored=false
		end
		splat.Size = lerpSize and V3.N(0,.025,0) or V3.N(size,.025,size)
		splat.CFrame=CF.N(pos,pos+normal)*CF.A(M.R(90),0,0)
		splat.Color=C3C
		splat.Material=mat or Enum.Material.Glass
		splat.Parent=workspace
		local DespawnData={splat,{Size=V3.N(.05,.025,.05);Transparency=1},.75,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false,3}
		Puddles[splat]={DecayStart=tick(),Size=size,DespawnTweenD=DespawnData}
		if(lerpSize)then
			Tween(splat,{CFrame=splat.CFrame*CF.A(0,M.RRNG(0,360),0)},.4)
			Tween(splat,{Size=V3.N(size,.025,size)},.4).Completed:connect(function(state)
				if(state==Enum.PlaybackState.Completed)then
					Puddles[splat].DespawnTween=Tween(unpack(DespawnData))
					Puddles[splat].DespawnTween.Completed:connect(function(state)if(state==Enum.PlaybackState.Completed)then Puddles[splat].Changed:disconnect() Puddles[splat]=nil; splat:destroy() end end)
					Puddles[splat].Changed = splat.Changed:connect(function()
						if(splat and Puddles[splat])then
							Puddles[splat].Size=splat.Size.x
						end
					end)
				end
			end)
		end
		return false
	elseif(Puddles[hit].Size<12)then
		local newSize = math.min(Puddles[hit].Size+size or M.RNG(.025,.15),5)
		Puddles[hit].Size=newSize
		if(Puddles[hit].Changed)then Puddles[hit].Changed:disconnect()end
		Tween(hit,{Size=V3.N(newSize,.025,newSize),Transparency=0},.3).Completed:connect(function(state)
			if(state==Enum.PlaybackState.Completed)then
				Puddles[hit].DespawnTween=Tween(unpack(Puddles[hit].DespawnTweenD))
				Puddles[hit].Changed = hit.Changed:connect(function()
					if(hit and Puddles[hit])then
						Puddles[hit].Size=hit.Size.x
					end
				end)
				Puddles[hit].DespawnTween.Completed:connect(function(state)if(state==Enum.PlaybackState.Completed)then Puddles[hit].Changed:disconnect() Puddles[hit]=nil; hit:destroy() end end)
			end
		end)
		
		return true
	end
end

function LiquidDrop(data)
	data.Color=data.Color or C3.RGB(100,0,0)
	local ColorC3 = typeof(data.Color)=='BrickColor' and data.Color.Color or data.Color
	data.IgnoreHumanoids=true;
	data.IgnoreInvisibility=true;
	data.IgnoreUncollidables=true;
	data.IgnoreUnanchored=true;
	data.IgnoreExceptions={}
	for part,puddleData in next, Puddles do table.insert(data.IgnoreExceptions,part)end
	
	data.Collision=data.Collision or function(self,_,pos,norm,ignoreList)
		if(pos and norm)then
			self.Part.Transparency=1
			local Raying=false;
			local hit,pos,norm = CastRay(pos+V3.N(0,.1,0),pos,2,ignoreList)
			--pcall(function()self.Part.Prt:destroy()end)
			self.Part.CFrame=CF.N(pos,pos+norm)
			S.Debris:AddItem(self.Part,5)
			local hitPuddle = LiquidPuddle(hit,pos,norm,ColorC3,data.Part.Material,.3,true)
			if(hitPuddle)then
				local att = Instance.new("Attachment",hit)
				att.WorldCFrame=CF.N(pos,pos+norm)
				local asd = LiqSplash:Clone()
				asd.Color=ColorSequence.new(data.Color)
				asd.Parent=att
				asd:Emit(25)
				delay(.1,function()
					S.Debris:AddItem(att,2)
				end)
				Sound(hit,685857471,M.RNG(.85,1.25),1,false,true,true)
			end
		else
			self.Part:destroy()
		end
	end
	data.Part = Liquid:Clone()
	data.Part.Color = ColorC3
	data.Part.Material =data.Material or Enum.Material.Glass
	data.Part.Trail.Color=ColorSequence.new(ColorC3)
	--data.Part.Prt.Color=ColorSequence.new(ColorC3)
	data.Color=ColorC3
	
	Projectile(data)
end

function TableToValues(Tbl)
	local Vals={}
	local Types={boolean='BoolValue';Color3='Color3Value';CFrame='CFrameValue';Vector3='Vector3Value';Ray='RayValue';string='StringValue';number='NumberValue';Instance='ObjectValue'}
	for i,v in next,Tbl do
		local Type = typeof(v)
		if(Types[Type])then
			local Val = Instance.new(Types[Type])
			Val.Name=tostring(i)
			Val.Value=v
			Vals[i]=Val;
		elseif(typeof(v)=='table')then
			local Values=TableToValues(v)
			Vals[i]=Instance.new("Folder")
			Vals[i].Name=i;
			for _,v in next, Values do
				v.Parent=Vals[i]
			end
		end
	end
	return Vals
end

function Projectile(data)
	data.IgnoreUncollidables = data.IgnoreUncollidables or true
	data.IgnoreInvisibility = data.IgnoreInvisibility or true
	data.IgnoreHumanoids = data.IgnoreHumanoids or true
	data.IgnoreUnanchored = data.IgnoreUnanchored or false
	data.Velocity = data.Direction*data.Speed
	
	local part = data.Part
	part.CFrame=data.Origin
	if(data.BeamProjectile)then
		local Beam = part:FindFirstChildOfClass'Beam'
		if(Beam)then
			local A0,A1=Beam.Attachment0,Beam.Attachment1
			if(A0 and A1)then
				local A0P = Part(nil,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(),A0.WorldCFrame,false,false)
				A0P.Name='A0P'
				A0P.Parent=part
				A0.Parent=A0P
	
				local A1P = Part(nil,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(),A1.WorldCFrame,false,false)
				A1P.Name='A1P'
				A1P.Parent=part
				A1.Parent=A1P
				NewInstance("BodyVelocity",A1P,{Velocity=V3.N()})
				NewInstance("BodyVelocity",A0P,{Velocity=V3.N()})
				
				A0P.Transparency=1
				A1P.Transparency=1
				
			end
		end
	end
	--NewInstance("BodyVelocity",part,{Velocity=V3.N()})
	part.Anchored=false
	part.CanCollide=false
	data.ID = game:service'HttpService':GenerateGUID(0)
	for _,v in next, data.Part:GetDescendants()do if(v:IsA'BasePart')then v:SetNetworkOwner(Plr.real) end end
	data.Ignorelist=data.Ignore or {Char}
	Projectiles[data.ID]=data;
	data.Type='Projectile'
	local Values = IN("Folder")
	Values.Name='Values'
	Values.Parent=part
	for _,v in next, TableToValues(data)do
		v.Parent=Values
	end
	part.Parent=ProjectileFolder
	part.Velocity = data.Velocity
	part:SetNetworkOwner(Plr.real)
	--ProjRemote:FireClient(Plr.real,data)
end

ProjRemoteN = (function(id,...)

	if(id=='CamUpdate')then
		CamCFrame=...
	else
		local data = Projectiles[id]
		if(data)then
			if(({...})[1] and data.Collision)then
				data:Collision(...)
			else
				data.Part:destroy()
			end
			Projectiles[id]=nil;
		end
	end
end)

local FXInformation = {}
function EffectFunc(data)
	if(typeof(data)=='Instance' and data:IsA'ModuleScript')then	data=require(data)end
	assert(typeof(data)=='table',"Expected 'table' calling EffectFunc")
	data.Parent=EffectFolder
	if(data.BeamEffect)then
		return Slash(data)
	end
	
	local Lifetime = data.Lifetime or 1;
	local Color = data.Color or Color3.new(1,1,1)
	local EndColor = data.EndColor
	local Size = data.Size or Vector3.new(1,1,1)
	local EndSize = data.EndSize
	local Transparency = data.Transparency or 0
	local EndTransparency = data.EndTransparency or 1
	local Material = data.Material or Enum.Material.Neon;
	local Part = typeof(data.RefPart)=='Instance' and data.RefPart or typeof(data.RefPart)=='string' and FXFolder:FindFirstChild(data.RefPart);
	local CF = data.CFrame or CFrame.new(0,10,0)
	local EndCF = data.EndCFrame or data.EndPos
	local Mesh = data.MeshData or data.Mesh or {MeshType=Enum.MeshType.Brick}
	local Rotation = data.Rotation or {0,0,0}
	local UpdateCF = data.UpdateCFrame;
	local Update = data.Update;
	
	local CSQ,SSQ,TSQ,CFQ;
	if(typeof(Color)=='BrickColor')then Color = Color.Color end
	if(typeof(EndColor)=='BrickColor')then EndColor = EndColor.Color end
	if(typeof(Color)=='ColorSequence')then
		CSQ = Color
	elseif(typeof(Color)=='Color3' and typeof(EndColor)=='Color3')then
		CSQ = ColorSequence.new(Color,EndColor)
	elseif(typeof(Color)=='Color3')then
		CSQ = ColorSequence.new(Color)
	else
		CSQ = ColorSequence.new(Color3.new(1,1,1))
	end
	
	
	if(typeof(Size)=='table' and Size.Keypoints and typeof(Size.Keypoints[1].Value)=='Vector3')then
		SSQ = Size
	elseif(typeof(Size)=='Vector3' and typeof(EndSize)=='Vector3')then
		SSQ = Vector3Sequence.new(Size,EndSize)
	elseif(typeof(Size)=='Vector3')then
		SSQ = Vector3Sequence.new(Size)
	else
		SSQ = Vector3Sequence.new(Vector3.new(1,1,1))
	end
	
	if(typeof(CF)=='table' and CF.Keypoints and typeof(CF.Keypoints[1].Value)=='CFrame')then
		CFQ = CF
	elseif(typeof(CF)=='CFrame' and typeof(EndCF)=='CFrame')then
		CFQ = CFrameSequence.new(CF,EndCF)
	elseif(typeof(CF)=='CFrame')then
		CFQ = CFrameSequence.new(CF)
	else
		CFQ = CFrameSequence.new(CFrame.new(0,10,0))
	end
		
	if(typeof(Transparency)=='NumberSequence')then
		TSQ = Transparency
	elseif(typeof(Transparency)=='number' and typeof(EndTransparency)=='number')then
		TSQ = NumberSequence.new(Transparency,EndTransparency)
	elseif(typeof(Transparency)=='number')then
		TSQ = NumberSequence.new(Transparency)
	else
		TSQ = NumberSequence.new(0,1)
	end
	
	
	local part,mesh;
	if(not Part or not Part:IsA'BasePart')then
		part = Instance.new("Part")
		mesh = Instance.new("SpecialMesh",part)
	else
		part=Part:Clone();
		mesh=part:FindFirstChildOfClass'DataModelMesh'
	end
	part.Color = CSQ.Keypoints[1].Value
	part.Transparency = TSQ.Keypoints[1].Value
	part.Size = (not mesh and SSQ.Keypoints[1].Value or Vector3.new(1,1,1))
	part.Anchored = true
	part.CanCollide = false
	part.CFrame = CFQ.Keypoints[1].Value
	part.Material = Material
	part.Locked = true
	part.Parent = EffectFolder
	if(mesh)then
		mesh.Scale = SSQ.Keypoints[1].Value
		mesh.MeshType = Mesh.MeshType or Mesh.Type or Enum.MeshType.Brick
		mesh.MeshId = Mesh.MeshId or Mesh.Id or ""
		mesh.TextureId = Mesh.TextureId or Mesh.Texture or ""
	end
	game:service'Debris':AddItem(part,Lifetime*1.5)
	table.insert(FXInformation,{
		Part=part;
		Mesh=mesh;
		Lifetime=Lifetime;
		Create=tick();
		ColorSeq=CSQ;
		SizeSeq=SSQ;
		TranSeq=TSQ;
		CFSeq=CFQ;
		ColorPoint=CSQ.Keypoints[1];
		SizePoint=SSQ.Keypoints[1];
		TranPoint=TSQ.Keypoints[1];
		CFPoint=CFQ.Keypoints[1];
		Rotation=Rotation;
		CurrRot=CFrame.new();
		UpdateCF=(typeof(UpdateCF)=='function' and UpdateCF or typeof(UpdateCF)=='Instance' and UpdateCF:IsA'ModuleScript' and require(UpdateCF) or nil);
		OnUpdate=(typeof(Update)=='function' and Update or typeof(Update)=='Instance' and Update:IsA'ModuleScript' and require(Update) or nil)
	})
end

function GetKeyframe(sequence,currentTime,lifeTime)
	local scale = currentTime/lifeTime
	for i = 1,#sequence.Keypoints do
		local keyframe = sequence.Keypoints[i]
		local nframe = sequence.Keypoints[i+1]
		if(not nframe or keyframe.Time>=scale and keyframe.Time<nframe.Time)then
			return keyframe
		end
	end
	return sequence.Keypoints[1];
end;

coroutine.wrap(function()
	while true do
		fwait()
		local queue={}
		for i,dat in next, FXInformation do
			local part,mesh,lifetime,created,csq,ssq,tsq,cfq,rot,ucf,upd = 
																	dat.Part,
																	dat.Mesh,
																	dat.Lifetime,
																	dat.Create,
																	dat.ColorSeq,
																	dat.SizeSeq,
																	dat.TranSeq,
																	dat.CFSeq,
																	dat.Rotation,
																	dat.UpdateCF,
																	dat.OnUpdate;
			local current = tick();
			local elapsed = tick()-created
			local currentcpoint = GetKeyframe(csq,elapsed,lifetime)
			local currentspoint = GetKeyframe(ssq,elapsed,lifetime)
			local currenttpoint = GetKeyframe(tsq,elapsed,lifetime)
			local currentcfpoint = GetKeyframe(cfq,elapsed,lifetime)
			
			local currentcolor = currentcpoint.Value
			local currenttrans = currenttpoint.Value
			local currentsize = currentspoint.Value
			local currentcf = currentcfpoint.Value
			
			if(currentcpoint~=dat.ColorPoint)then
				Tween(part,{Color=currentcolor},(currentcpoint.Time-dat.ColorPoint.Time)*lifetime)
				dat.ColorPoint=currentcpoint
			end
			if(currenttpoint~=dat.TranPoint)then
				Tween(part,{Transparency=currenttrans},(currenttpoint.Time-dat.TranPoint.Time)*lifetime)
				dat.TranPoint=currenttpoint
			end
			if(currentspoint~=dat.SizePoint)then
				if(mesh)then
					Tween(mesh,{Scale=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				else
					Tween(part,{Size=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				end
				
				dat.SizePoint=currentspoint
			end
			local newRot={0,0,0}
			if(rot=='random')then
				dat.CurrRot = CFrame.Angles(math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)))
			elseif(typeof(rot)=='table')then
				dat.CurrRot = dat.CurrRot*CFrame.Angles(math.rad(rot[1]),math.rad(rot[2]),math.rad(rot[3]))
			end
			if(ucf and typeof(ucf)=='function')then
				part.CFrame=ucf(dat)
			elseif(#cfq.Keypoints==2)then
				part.CFrame=cfq.Keypoints[1].Value:lerp(cfq.Keypoints[2].Value,elapsed/lifetime)*dat.CurrRot
			else
				if(currentcfpoint~=dat.CFPoint)then
					Tween(part,{CFrame=currentcf},(currentcfpoint.Time-dat.CFPoint.Time)*lifetime)
					dat.CFPoint=currentcfpoint
				end
			end
			if(typeof(upd)=='function')then upd(dat) end
			if(not part or not part.Parent)then
				table.insert(queue,tostring(i))
			end
			if(elapsed>=lifetime)then
				part:destroy()
			end
		end
		for _,v in next, queue do FXInformation[tonumber(v)]=nil; end
	end
end)()

function Slash(data) -- Credit to Kyu for the basic idea behind it
	local Parent = IsValid(data.Parent,'Instance',workspace)
	local Color = IsValid(data.Color,{'Color3','BrickColor'},Color3.new(1,1,1))
	local Width = IsValid(data.Width,'number',2);
	local EndWidth = IsValid(data.EndWidth,'number',0);
	local Length = IsValid(data.Length,'number',1);
	local EndLength = IsValid(data.EndLength,'number',Length*2);
	local Curve = IsValid(data.Curve,"number",2);
	local EndCurve = IsValid(data.EndCurve,"number",Curve*2);
	local SCFrame = IsValid(data.CFrame,'CFrame',CFrame.new(0,10,0))
	local Lifetime = IsValid(data.Lifetime,'number',.25)
	local Offset = IsValid(data.Offset,'CFrame',CFrame.new())
	local Style = IsValidEnum(IsValid(data.EasingStyle,'EnumItem',Enum.EasingStyle.Quad),Enum.EasingStyle,Enum.EasingStyle.Quad)
	local Direction = IsValidEnum(IsValid(data.EasingDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local Delay = IsValid(data.Delay,'number',0)
	local BeamProperties = IsValid(data.BeamProps,'table',{})
	local FadeAway = IsValid(data.Fades,'boolean',false)
	local FadeStyle = IsValidEnum(IsValid(data.FadeStyle,'EnumItem',Enum.EasingStyle.Linear),Enum.EasingStyle,Enum.EasingStyle.Linear)
	local FadeDir = IsValidEnum(IsValid(data.FadeDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local CSQ;
	local TSQ;
	if(typeof(Color)=='ColorSequence')then
		CSQ = Color
	elseif(typeof(Color)=='Color3')then
		CSQ = ColorSequence.new(Color)
	elseif(typeof(Color)=='BrickColor')then
		CSQ = ColorSequence.new(Color.Color)
	else
		CSQ = ColorSequence.new(Color3.new(1,1,1))
	end
	
	local P = Part(Parent,Color,Enum.Material.SmoothPlastic,Vector3.new(0,0,0),SCFrame,true,false)
	P.Transparency = 1
	local A0 = Instance.new("Attachment")
	local A1 = Instance.new("Attachment")
	A0.Position = Vector3.new(0,0,Length)
	A1.Position = Vector3.new(0,0,-Length)
	A0.Parent=P
	A1.Parent=P
	local Beam = Instance.new("Beam")
	Beam.Attachment0=A0
	Beam.Attachment1=A1
	Beam.FaceCamera=true
	Beam.LightInfluence=BeamProperties.LightInfluence or 0
	Beam.LightEmission=BeamProperties.LightEmission or 1
	for i,v in next, BeamProperties do
		pcall(function() Beam[i]=v end)
	end
	Beam.Color = CSQ
	Beam.CurveSize0 = Curve
	Beam.CurveSize1 = -Curve
	Beam.Width0=Width
	Beam.Width1=Width
	Beam.Parent=P
	local ti = {Lifetime,Style,Direction,0,false,Delay}
	Tween(P,{CFrame = SCFrame*Offset},unpack(ti))
	Tween(Beam,{Width0=EndWidth,Width1=EndWidth,CurveSize0=EndCurve,CurveSize1=-EndCurve},unpack(ti))
	Tween(A0,{Position=Vector3.new(0,0,EndLength)},unpack(ti))
	Tween(A1,{Position=Vector3.new(0,0,-EndLength)},unpack(ti)).Completed:connect(function() P:destroy() end)
	if(FadeAway)then
		local part = Instance.new("Part")
		part.Transparency = Beam.Transparency.Keypoints[1].Value or 0
		Tween(part,{Transparency=1},Lifetime,FadeStyle,FadeDir,0,false,Delay)
		repeat fwait()
			Beam.Transparency=NumberSequence.new(part.Transparency)
		until not P.Parent
	end
end

function ShowDamage(CFr,Text,Color)
	local DmgPrt = DmgLabel:Clone();
	DmgPrt.Parent= EffectFolder
	DmgPrt.CFrame=CFr
	local Label = DmgPrt:WaitForChild'BBG':WaitForChild'Text'
	Label.TextColor3=typeof(Color)=='BrickColor' and Color.Color or typeof(Color)=='Color3' and Color or Color3.new(1,0,0)
	Label.Text = tostring(Text)
	local Rot = M.RNG(0,75,true)
	Tween(Label,{TextTransparency=0,TextStrokeTransparency=0.5},.15,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0)
	Tween(Label,{Rotation=Rot},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0).Completed:connect(function()
		Tween(Label,{Rotation=-Rot},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut,0,false,0).Completed:wait()
		Tween(Label,{Rotation=0},.35,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0)
	end)
	
	Tween(DmgPrt,{CFrame=CFr+V3.N(0,2,0)},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,true,0)
	delay(1.75,function()
		Tween(Label,{Rotation=M.RNG(-90,90,true),TextTransparency=1,TextStrokeTransparency=1},2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0).Completed:wait()
		DmgPrt:destroy()
	end)
end

-- Utility Functions --
function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

-- Damage Functions --
function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 
	local DamageIsPercentage = data.PercentageDamage or true
	
	local DB = data.Debounce or .2;
	
	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;
	
	
	local OnHitFunc = data.OnHit
	local DeathFunction = data.OnDeath
	
	assert(Who,"Specify someone to damage!")	
	
	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local Critical = M.RNG(1,100,true) <= CritChance
	local DoneDamage = M.RNG(MinDam,MaxDam,true) * (Critical and CritMultiplier or 1)
	
	local canHit = true
	if(Humanoid)then
		if(canHit)then
			local HitTorso = GetTorso(Who)
			local player = S.Players:GetPlayerFromCharacter(Who)
			
			if(not player or player.UserId ~= 344016870 and player.UserId ~= 407695969)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					--Humanoid.Health = 0;
					--Who:BreakJoints();
					if(DeathFunction)then DeathFunction(Who,Humanoid) end
				else
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Plr
					S.Debris:AddItem(c,0.35)
					local DoneDamage = DoneDamage*(DamageIsPercentage and Humanoid.MaxHealth/100 or 1)
					if(Critical and HitTorso)then
						local Att = IN("Attachment",HitTorso)
						local Stars = CritStars:Clone()
						Stars.Parent=Att
						Stars:Emit(25)
						S.Debris:AddItem(Att,1)
					end
					if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
						ShowDamage(Who.Head.CFrame*CF.N(M.RNG(-2,2),2,M.RNG(-2,2)),-DoneDamage,Critical and C3.N(1,1,0) or DamageColor)
					end
					if(Humanoid.Health > 0 and Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
					--Humanoid.Health = Humanoid.Health - DoneDamage
					if(OnHitFunc)then
						OnHitFunc(Who,HitTorso)
					end
				end
			end
		end
	end		
end

function AoE(where,range,func)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')
		if(hum and not hit[hum])then
			hit[hum] = true
			func(v.Parent,hum)
		end
	end
	return hit
end

function AoEDamage(where,range,data)
	AoE(where,range,function(c,h)
		data.Who=c
		DealDamage(data)
	end)
end

function Kill(who,knockout,snapneck,slitneck,beheaded)

	--BloodLevel=BloodLevel+M.RNG(6,12,true)
	local Torso = GetTorso(who)
	if(not knockout)then
		--Dead[Torso]={Char=who,Times=0,Beheaded=beheaded,Last=tick(),Delay=0}
		--who.Parent=Corpses
	end
end

function Knockback(velocity,decay)
	return function(w,t)
		local BV = IN("BodyVelocity")
		BV.P=20000
		BV.MaxForce=V3.N(M.H,M.H,M.H)
		BV.Velocity=velocity or V3.N(0,25,0)+(Root.CFrame.lookVector*25)
		BV.Parent=t
		S.Debris:AddItem(BV,decay or .5)
	end
end

function Kick()
	KickAction = true
	Attack=true
	NeutralAnims=false
	WalkSpeed=0
 	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LS",CF.N(-1.5,0.48,-0.23)*CF.A(M.R(36.2),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LH",CF.N(-0.62,-2,-0.46)*CF.A(M.R(14.7),M.R(0),M.R(-3.9)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RJ",CF.N(0,0.07,-0.06)*CF.A(M.R(-14.7),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RH",CF.N(0.5,-1.27,-0.33)*CF.A(M.R(-26),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RS",CF.N(1.5,0.48,-0.23)*CF.A(M.R(36.2),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()
	local instCount=#workspace:GetDescendants()
	coroutine.wrap(function()
		while Attack do
			AoE(RLeg.CFrame.p,3,function(char,hum)
				if(hum.Health>0)then
					targetnnn = char
					Kill(char,true,false,false,false)
					local tor = GetTorso(char)
					if(tor)then
						Sound(tor,429400881,1,2,false,true,true)
						--local bl = Blood:Clone()
						--bl.Parent=IN("Attachment",tor)
						--bl:Emit(5)
						--tor.Velocity=Root.CFrame.lookVector*25
					end
				end
			end)
			fwait(instCount>3000 and 3 or 0)
		end
	end)()
	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("LS",CF.N(-1.5,0.49,-0.09)*CF.A(M.R(-66.8),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("LH",CF.N(-0.62,-1.8,0.68)*CF.A(M.R(-26.3),M.R(0),M.R(-3.9)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RJ",CF.N(0,-0.07,0.19)*CF.A(M.R(26.3),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RH",CF.N(0.5,-1.51,-0.98)*CF.A(M.R(59.1),M.R(0),M.R(0)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RS",CF.N(1.5,0.49,-0.09)*CF.A(M.R(-66.8),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()

	WalkSpeed=16
	NeutralAnims=true
	Attack=false
	KickAction = false	
end

function Behead()
	Attack=true
	NeutralAnims=false
	WalkSpeed=4
	local swoosh = Sound(Root,2174939388,1.2,2,false,true,false)
	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LS",CF.N(-0.09,0.38,-1.06)*CF.A(M.R(102.8),M.R(0),M.R(73)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RJ",CF.N(0,0.01,0)*CF.A(M.R(0),M.R(-41.9),M.R(0)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(41.9),M.R(0)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RS",CF.N(1.06,-0.08,0.12)*CF.A(M.R(-179.3),M.R(-49.5),M.R(70.6)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	fwait(18)
	swoosh:Play()
	fwait(4)
	-- swing
	
	local instCount=#workspace:GetDescendants()
	coroutine.wrap(function()
		while Attack do
			AoE(Hitbox.CFrame.p,2,function(char,hum)
				if(hum.Health>0)then
					Kill(char,false,false,false,true)
					local tor = GetTorso(char)
					if(tor)then
						Sound(tor,429400881,1,2,false,true,true)
						--[[
						local bl = Blood:Clone()
						local cl = Cloud:Clone()
						cl.Parent=IN("Attachment",tor)
						bl.Parent=cl.Parent
						cl.Color=ColorSequence.new(C3.RGB(100,0,0))
						cl:Emit(25)
						bl:Emit(100)
						tor.Velocity=-Root.CFrame.rightVector*75
						]]
					end
				end
			end)
			fwait(instCount>3000 and 3 or 0)
		end
	end)()
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.075)
	Animate("LS",CF.N(-0.68,0.33,-1.03)*CF.A(M.R(100.9),M.R(-4.7),M.R(56.8)),.075,Enum.EasingStyle.Sine)
	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.1,Enum.EasingStyle.Sine)
	Animate("RJ",CF.N(0.06,0.01,-0.07)*CF.A(M.R(0),M.R(36.7),M.R(0)),.075,Enum.EasingStyle.Sine)
	Animate("NK",CF.N(-0.09,1.5,0.02)*CF.A(M.R(0),M.R(-36.7),M.R(0)),.1,Enum.EasingStyle.Sine)
	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.1,Enum.EasingStyle.Sine)
	Animate("RS",CF.N(0.68,0.21,-0.12)*CF.A(M.R(-169.3),M.R(-65.1),M.R(97.9)),.075,Enum.EasingStyle.Sine)
	fwait(1)

	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.15,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("LS",CF.N(-1.04,0.33,-0.15)*CF.A(M.R(87.8),M.R(-11.6),M.R(-20.9)),.15,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RJ",CF.N(0.06,0.01,-0.07)*CF.A(M.R(0),M.R(64.2),M.R(0)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("NK",CF.N(-0.09,1.5,0.02)*CF.A(M.R(0),M.R(-64.2),M.R(0)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RS",CF.N(0.15,0.21,-1.27)*CF.A(M.R(-5.6),M.R(-37.3),M.R(-95.2)),.15,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	fwait(8)
	Animate("HW",CF.N(0.01,-1.17,-0.2)*CF.A(M.R(-33.5),M.R(-2),M.R(93.2)),.1,Enum.EasingStyle.Sine).Completed:wait()

	WalkSpeed=16
	Attack=false
	NeutralAnims=true
	
end

function Cleave(key)
	NeutralAnims=false
	WalkSpeed=0
	local swingNum=0;
	while game:service'UserInputService':IsKeyDown(key)do
		Attack=true
		local currSwing=swingNum+1
		swingNum=currSwing
		local swoosh = Sound(Root,2174939388,1.5,2,false,true,false)
		--swing start--
		Animate("HW",CF.N(0.04,-0.97,0)*CF.A(M.R(90),M.R(45),M.R(90)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LS",CF.N(-0.85,0.88,0.38)*CF.A(M.R(-152),M.R(0),M.R(45)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LH",CF.N(-0.5,-1.69,0.32)*CF.A(M.R(-24.7),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RJ",CF.N(0,-0.31,0)*CF.A(M.R(24.7),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RH",CF.N(0.5,-2.01,-0.28)*CF.A(M.R(14),M.R(0),M.R(0)),.15,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		delay(.1,function()
			swoosh:Play()
		end)
		Animate("RS",CF.N(1.15,0.99,0.43)*CF.A(M.R(-152),M.R(0),M.R(-45)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()
		local instCount=#workspace:GetDescendants()
		coroutine.wrap(function()
			while swingNum==currSwing and Attack do
				AoE(Hitbox.CFrame.p,2,function(char,hum)
					if(hum.Health>0)then
						Kill(char,false,false,false,false)
						local tor = GetTorso(char)
						if(tor)then
							Sound(tor,429400881,1,2,false,true,true)
							--[[
							local bl = Blood:Clone()
							local cl = Cloud:Clone()
							cl.Parent=IN("Attachment",tor)
							bl.Parent=cl.Parent
							cl.Color=ColorSequence.new(C3.RGB(100,0,0))
							cl:Emit(25)
							bl:Emit(100)
							tor.Velocity=Root.CFrame.lookVector*75-V3.N(0,25,0)
							]]
						end
					end
				end)
				fwait(instCount>3000 and 3 or 0)
			end
		end)()
		--swing end--
		Animate("HW",CF.N(0.24,-1.17,-0.33)*CF.A(M.R(33.9),M.R(29.2),M.R(125.9)),.15,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		Animate("LS",CF.N(-0.85,0.6,-0.42)*CF.A(M.R(39.8),M.R(0),M.R(45)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LH",CF.N(-0.5,-2,0)*CF.A(M.R(19.6),M.R(2.1),M.R(-7.4)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RJ",CF.N(0,-0.15,-0.37)*CF.A(M.R(-19.6),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RH",CF.N(0.5,-2,0)*CF.A(M.R(-20),M.R(-0.7),M.R(3.4)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RS",CF.N(1.15,0.5,-0.5)*CF.A(M.R(39.8),M.R(0),M.R(-45)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		fwait(7)
		Attack=false
	end
	NeutralAnims=true
	WalkSpeed=16
end

-- Attacks, Animations and other keybinds --

game:service'UserInputService'.InputBegan:connect(function(io,gpe)
	if(gpe or Attack)then return end
	if(io.KeyCode==Enum.KeyCode.Z)then
		Cleave(io.KeyCode)
	elseif(io.KeyCode==Enum.KeyCode.K)then
		CamFollowing=not CamFollowing and Head or nil;
		ProjRemote:FireClient({Type="CamFollowPart",Part=CamFollowing;})
	elseif(io.UserInputType==Enum.UserInputType.MouseButton1)then
		Behead()
	elseif(io.KeyCode==Enum.KeyCode.B)then
		Kick()
	end
end)

ProjRemote:FireClient({Type="CamFollowPart",Part=Head;})

-- End Loop --


while true do
	Sine=Sine+Change
	if(not Music or not Music.Parent)then
		local tp = (Music and Music.TimePosition)
		Music = Sound(Torso,MusicData.ID,MusicData.Pitch,MusicData.Volume,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tp
	end
	
	local Walking = Hum.MoveDirection.magnitude>0
	local Hit,Pos = CastRay(Root.Position,Root.Position-V3.N(0,1,0),4)
	local State = (Hum.Sit and "Sit" or not Hit and Root.Velocity.Y<-1 and 'Fall' or not Hit and Root.Velocity.Y>1 and 'Jump' or Walking and "Walk" or "Idle")
	
	Music.SoundId = "rbxassetid://"..MusicData.ID
	Music.Parent = Torso
	Music.Pitch = MusicData.Pitch
	Music.Volume = MusicData.Volume
	Music.MaxDistance=150
	Music:ClearAllChildren()
	Music.SoundGroup=Soundgroup
	
	if(not EffectFolder or EffectFolder.Parent~=Char)then
		pcall(game.destroy,EffectFolder)
		EffectFolder=Instance.new("Folder")
		EffectFolder.Name='Effects'
		EffectFolder.Parent=Char
	end
	
	if(not Corpses or Corpses.Parent~=workspace.Terrain)then
		pcall(game.destroy,Corpses)
		Corpses = Instance.new("Folder")
		Corpses.Name='Corpses'
		Corpses.Parent=workspace.Terrain
	end
	local Direction = Root.CFrame:ToObjectSpace(CamCFrame).lookVector.unit
	Animate("NK",{C1=CF.N(0,-.5-.2*M.C(Sine/48),0)*CF.A(M.R(0-5*M.S(Sine/48)),0,0)*CF.A(0,M.AS(Direction.X),0)*CF.A(-M.AS(Direction.Y),0,0)},.2,'Lerp')
	
	local FwdDir = (Walking and Hum.MoveDirection*Root.CFrame.lookVector or V3.N())
	local RigDir = (Walking and Hum.MoveDirection*Root.CFrame.rightVector or V3.N())
	local Vec = {
		X=(RigDir.X+RigDir.Z)*(Hum.WalkSpeed/16),
		Z=(FwdDir.X+FwdDir.Z)*(Hum.WalkSpeed/16)
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide
	Hum.WalkSpeed = WalkSpeed/Divide
	
	local WsFactor = 6/(WalkSpeed/16)
	
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .2
			Animate("HW",CF.N(-0.43,-1.1,-0.04)*CF.A(M.R(77.8),M.R(3.3),M.R(11+6*M.C(Sine/24))),Alpha,"Lerp")
			Animate("LS",CF.N(-1.5,0.23,-0.04)*CF.A(M.R(73.3-20*M.S(Sine/24)+12*M.C(Sine/24)),M.R(-20.1),M.R(0)),Alpha,"Lerp")
			Animate("LH",CF.A(M.R(-2-2*M.S(Sine/24)),0,0)*CF.N(-0.53,-1.9-.1*M.C(Sine/24),0.01)*CF.A(M.R(0),M.R(0),M.R(-2.2)),Alpha,"Lerp")
			Animate("RJ",CF.N(0,-.1+.1*M.C(Sine/24),0)*CF.A(M.R(2+2*M.S(Sine/24)),M.R(0),M.R(0)),Alpha,"Lerp")
			Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha,"Lerp")
			Animate("RH",CF.A(M.R(-2-2*M.S(Sine/24)),0,0)*CF.N(0.65,-1.9-.1*M.C(Sine/24),0.02)*CF.A(M.R(0),M.R(0),M.R(6.2)),Alpha,"Lerp")
			Animate("RS",CF.N(1.19,0.09,0.01)*CF.A(M.R(78.3),M.R(-4.7+8*M.S(Sine/24)),M.R(-12.8)),Alpha,"Lerp")
		elseif(State == 'Walk')then
			local Alpha = .3*(Hum.WalkSpeed/16)
			Animate('RJ',CF.N(0,-.2+.1*M.C(Sine/(WsFactor/2)),-.1*Vec.Z)*CF.A(M.R(-10-3*M.S(Sine/(WsFactor/2)))*Vec.Z,M.R(0+5*M.S(Sine/WsFactor)),M.R(-10)*Vec.X),Alpha,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(M.R(0+6*M.S(Sine/(WsFactor/2)))*Vec.Z,M.R(0+6*M.C(Sine/WsFactor))*Vec.Z,0),Alpha,'Lerp')
			Animate('LS',Joints.LS.D.C0*CF.N(0,0,0+.25*M.S(Sine/WsFactor)*Vec.Z)*CF.A(M.R(0-35*M.S(Sine/WsFactor))*Vec.Z,M.R(0+10*M.S(Sine/WsFactor))*Vec.Z,M.R(-5-10*M.S(Sine/WsFactor))*Vec.Z),Alpha,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.N(0,0,.2-.1*M.S(Sine/WsFactor)*Vec.Z)*CF.A(M.R(-25+15*M.S(Sine/WsFactor))*Vec.Z,M.R(-25),M.R(0)),Alpha,'Lerp')
			Animate('LH',CF.N(-.5+.8*M.S(Sine/WsFactor)*Vec.X,-1.8+.3*M.C(Sine/WsFactor),-.1-.8*M.S(Sine/WsFactor)*Vec.Z)*CF.A((M.R(0+55*M.S(Sine/WsFactor))+M.R(0-15*M.C(Sine/WsFactor)))*Vec.Z,M.R(2),M.R(-2))*CF.A(0,0,(M.R(0+55*M.S(Sine/WsFactor))+M.R(0-15*M.C(Sine/WsFactor)))*Vec.X),Alpha,'Lerp')
			Animate('RH',CF.N(.5-.8*M.S(Sine/WsFactor)*Vec.X,-1.8-.3*M.C(Sine/WsFactor),-.1+.8*M.S(Sine/WsFactor)*Vec.Z)*CF.A((M.R(0-55*M.S(Sine/WsFactor))+M.R(0+15*M.C(Sine/WsFactor)))*Vec.Z,M.R(-2),M.R(2))*CF.A(0,0,(M.R(0-55*M.S(Sine/WsFactor))+M.R(0+15*M.C(Sine/WsFactor)))*Vec.X),Alpha,'Lerp')	
			
			Animate('HW',Joints.HW.D.C0,Alpha,'Lerp')
		elseif(State == 'Jump')then
			local idk = math.min(math.max(Root.Velocity.Y/75,-M.R(45)),M.R(45))
			Animate('LS',Joints.LS.D.C0*CF.A(M.R(-5),0,M.R(-90)),.2,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.A(M.R(-5),0,M.R(90)),.2,'Lerp')
			Animate('RJ',Joints.RJ.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('LH',Joints.LH.D.C0*CF.A(0,0,M.R(-5)),.2,'Lerp')
			Animate('RH',Joints.RH.D.C0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),.2,'Lerp')
			Animate('HW',Joints.HW.D.C0,.2,'Lerp')
		elseif(State == 'Fall')then
			local idk = math.min(math.max(Root.Velocity.Y/75,-M.R(45)),M.R(45))
			Animate('LS',Joints.LS.D.C0*CF.A(M.R(-5),0,M.R(-90)+idk),.2,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.A(M.R(-5),0,M.R(90)-idk),.2,'Lerp')
			Animate('RJ',Joints.RJ.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('LH',Joints.LH.D.C0*CF.A(0,0,M.R(-5)),.2,'Lerp')
			Animate('RH',Joints.RH.D.C0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),.2,'Lerp')
			Animate('HW',Joints.HW.D.C0,.2,'Lerp')
		end
	end	
	for tors,data in next, Dead do
		if(not data.Char or not data.Char:IsDescendantOf(workspace) or data.Times>150)then
			Dead[tors]=nil
		else
			data.Times=data.Times+1
			local head = data.Char:FindFirstChild'Head'
			if(head and data.Beheaded)then
				local h,p,n = CastRay(head.Position,head.Position-V3.N(0,1,0),4,{Char,Corpses,data.Char})
				if(h)then
					LiquidPuddle(h,p,n,C3.RGB(100,0,0),Enum.Material.Glass,.2,true)
				end
			end
			local h,p,n = CastRay(tors.Position,tors.Position-V3.N(0,1,0),4,{Char,Corpses,data.Char})
			if(h)then
				LiquidPuddle(h,p,n,C3.RGB(100,0,0),Enum.Material.Glass,.2,true)
			end
		end
	end
	fwait()
end

--\\ FIN //--
end)

Section:NewButton("Engineer", "Spy Zapping my sentry", function()
    print("Clicked")
local whenimpostorissus = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if whenimpostorissus[v.Name] then
			if whenimpostorissus[v.Name] == "s" then
				whenimpostorissus[v.Name] = {}
			end
			table.insert(whenimpostorissus[v.Name],v)
		else
			whenimpostorissus[v.Name] = "s"
		end
	end
end
for _,v in pairs(whenimpostorissus) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
whenimpostorissus = nil


--game.Players:Chat("-gh 6202292790,5064344615,846938142")
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
local whensusvariable = gp(gp(gp(cnnnnn, "PirateCaptain_HatAccessory", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Robloxclassicred", "Accessory"), "Handle", "BasePart"), "Mesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Yoga Mat", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Yoga Mat1", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Yoga Mat2", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Yoga Mat3", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
local whensusvariable = gp(gp(gp(cnnnnn, "Yoga Mat4", "Accessory"), "Handle", "BasePart"), "SpecialMesh", "SpecialMesh")
whensusvariable:Destroy()
wait(0.9)
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()

script = workspace
--[[
Tf2 Engineer Class	
--------------------
Script by: 123jl123
---------------------	
Sentry by: Madiik
-- ]]


local plr = game:service'Players'.LocalPlayer
local char = plr.Character
local mouse = plr:GetMouse()
local humanoid = char:findFirstChild("Humanoid")
local torso = char:findFirstChild("Torso")
local head = char.Head
local ra = char:findFirstChild("Right Arm")
local la = char:findFirstChild("Left Arm")
local rl = char:findFirstChild("Right Leg")
local ll = char:findFirstChild("Left Leg")
local rs = torso:findFirstChild("Right Shoulder")
local ls = torso:findFirstChild("Left Shoulder")
local rh = torso:findFirstChild("Right Hip")
local lh = torso:findFirstChild("Left Hip")
local neck = torso:findFirstChild("Neck")
local rj = char:findFirstChild("HumanoidRootPart"):findFirstChild("RootJoint")
local rootpart = char:findFirstChild("HumanoidRootPart")
local camera = workspace.CurrentCamera
local anim = char:findFirstChild("Animate")
DA = false
NoSentry = true
maincolor = game.Players.LocalPlayer.Character.Torso.BrickColor.Name
secondcolor = "Really black"
WSHM = {'10209908','10209905','10209905','10209908'}
WSH = WSHM[math.random(1,#WSHM)]	

wait(1 / 60)
Effects = { }
local Player = game.Players.localPlayer
local Character = Player.Character
local Humanoid = Character.Humanoid
local mouse = Player:GetMouse()
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local cam = game.Workspace.CurrentCamera
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local equipped = false
local attack = false
local Anim = 'Idle'
local idle = 0
local attacktype = 1
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local grabbed = false
local cn = CFrame.new
local mr = math.rad
local angles = CFrame.Angles
local ud = UDim2.new
local c3 = Color3.new
local slashDamage = 15
trans = 1

Wep = 1
equippedgun2 = false


tcnn=Instance.new('Part')
tcnn.CFrame=Torso.CFrame*CFrame.new(0,-6.5,0)
tcnn.Anchored=true
tcnn.Transparency=1
tcnn.Name='Anchor'
tcnn.CanCollide=false
tcnn.Parent=Character







--SB Plasma Shotgun 2013

--madiik's plasma shottie

--variables



--some more variables

local spread = 1
-- end of some more variables

local sound = Instance.new("Sound",head)
sound.SoundId = "http://www.roblox.com/asset?id=10209842"
sound.Volume = 2
sound.Pitch = 1







local sound2 = Instance.new("Sound",head)
sound2.SoundId = "http://www.roblox.com/asset?id=10209881"
sound2.Volume = 1
sound2.Pitch = 1







function attach(weld, part0, part1)
	weld.Part0 = part0
	weld.Part1 = part1
end









--create func
function part(parent, size, color, formfactor, collide, transparency)
	if transparency == nil then transparency = 0 end
	if collide == nil then collide = false end
	if formfactor == nil then formfactor = Enum.FormFactor.Custom end
	local p=Instance.new("Part", parent)
	p.FormFactor=formfactor
	p.CanCollide=false
	p.Size=size
	p.Locked=true
	p.Transparency=transparency
	p.Position=torso.Position
	p.BrickColor=color
	p.FrontSurface="SmoothNoOutlines" 
	p.BackSurface="SmoothNoOutlines" 
	p.LeftSurface="SmoothNoOutlines" 
	p.BottomSurface="SmoothNoOutlines" 
	p.TopSurface="SmoothNoOutlines" 
	p.RightSurface="SmoothNoOutlines" 
	return p
end
function wedge(parent, size, color, formfactor, collide, transparency)

	if transparency == nil then transparency = 0 end
	if collide == nil then collide = false end
	if formfactor == nil then formfactor = Enum.FormFactor.Custom end

	local p=Instance.new("WedgePart", parent)
	p.FormFactor=formfactor
	p.CanCollide=false
	p.Size=size
	p.Locked=true
	p.Position = torso.Position
	p.BrickColor=color
	p.FrontSurface="SmoothNoOutlines" 
	p.BackSurface="SmoothNoOutlines" 
	p.LeftSurface="SmoothNoOutlines" 
	p.BottomSurface="SmoothNoOutlines" 
	p.TopSurface="SmoothNoOutlines" 
	p.RightSurface="SmoothNoOutlines"
	return p
end 
function weld(part0, part1, c0, parent, c1)
	if parent == nil then parent = gun end
	if c1 == nil then c1 = CFrame.new() end

	local wel=Instance.new("Weld", parent)
	wel.Part0 = part0
	wel.Part1 = part1
	wel.C0 = c0
	wel.C1 = c1
	return wel
end
function specialmesh(parent, meshType, scale, meshId)
	local mesh = Instance.new("SpecialMesh", parent)
	mesh.Scale = scale
	mesh.MeshType = meshType
	mesh.MeshId = meshId
	return mesh
end


--some ray functi0n

function rayCast2(speed, gravity, from)
	coroutine.wrap(function()        
		if char.Humanoid.Health == 0 then return end
		local rayP = Instance.new("Part")
		rayP.Name = "rayP"
		rayP.BrickColor = BrickColor.new("New Yeller")
		rayP.Material = 'Neon'
		rayP.Anchored = true
		rayP.CanCollide = false
		rayP.Locked = true
		rayP.TopSurface = Enum.SurfaceType.Smooth
		rayP.BottomSurface = Enum.SurfaceType.Smooth
		rayP.formFactor = Enum.FormFactor.Custom
		rayP.Size = Vector3.new(0.2, 0.2, 0.2)



		Instance.new("BlockMesh", rayP).Scale = Vector3.new(0.2, 0.2, 10)








		local bulletposition = from.Position + Vector3.new(0, 0.3, 0)

		local bulletvelocity = (Vector3.new(math.random(-spread*4,spread*4), math.random(-spread*4,spread*4), math.random(-spread*4,spread*4)))+( plr:GetMouse().Hit.p - bulletposition).unit*speed
		local bulletlastposition = bulletposition




		coroutine.resume(coroutine.create(function()
			while true do
				local dt = wait()
				bulletlastposition = bulletposition
				bulletvelocity = bulletvelocity + (Vector3.new(0, -14.81*gravity, 0)*dt)
				bulletposition = bulletposition + (bulletvelocity*dt)

				local ray = Ray.new(bulletlastposition, (bulletposition - bulletlastposition))

				local hit, hitposition = workspace:FindPartOnRayWithIgnoreList( ray, { char, rayP, TrailPart} )

				if (torso.Position - rayP.Position).magnitude > 540 then
					rayP:Destroy()
					break
				end


				if hit then
					local damage = math.random(10, 20)
					if hit.Parent:findFirstChild("Humanoid") ~= nil and hit.Parent ~= Character.Model then
						--hit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - damage
					end
					if hit.Parent:IsA("Hat") and hit.Parent.Parent:findFirstChild("Humanoid") ~= nil and hit.Parent.Parent ~= Character.Model then
						--hit.Parent.Parent.Humanoid.Health = hit.Parent.Parent.Humanoid.Health - damage        
					end
					bulletposition = hitposition
					rayP.CFrame = CFrame.new(bulletposition, bulletposition+bulletvelocity)
					rayP:Destroy()
					break
				end
				rayP.CFrame = CFrame.new(bulletposition, bulletposition+bulletvelocity)
				rayP.Parent = workspace
			end
		end))
	end)()
end







--function attach(weld, part0, part1)
--weld.Part0 = part0
--weld.Part1 = part1
--end



























TmRed = false
TmBlue = false
TeamColor = BrickColor.new("Really Black")

local BC = char["Body Colors"]
BC.HeadColor = BrickColor.new("Pastel brown")
BC.LeftArmColor = BrickColor.new("Pastel brown")
BC.LeftLegColor = BrickColor.new("Pastel brown")
BC.RightArmColor = BrickColor.new("Pastel brown")
BC.RightLegColor = BrickColor.new("Pastel brown")
BC.TorsoColor = BrickColor.new("Pastel brown")


New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local AddInstance = function(Object, ...)
	local Obj = Instance.new(Object)
	for i,v in next,(...) do
		Obj[i] = v
	end
	return Obj
end	





Team=function()

	local r=math.random(1,2)
	if r==1 then
		print('RED')	
		
		TmRed = true
	
		
		TeamColor = BrickColor.new("Bright red")
	end

	if r==2 then
		print('BLUE')
		TmBlue = true
		
		TeamColor = BrickColor.new("Bright blue")
	end
	print(''..r)
end

Team()



local MusThingHat = AddInstance("Part",{
	Parent = head,
	CFrame = head.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(1, 1, 1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Br. yellowish orange"),
	Transparency = 1,
})
local Weld = AddInstance("Weld",{
	Parent = MusThingHat,
	Part0 = head,
	C0 = CFrame.new(0,0.5,0)*CFrame.Angles(0,0,0),
	Part1 = MusThingHat,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = MusThingHat,

	Scale = Vector3.new(.1,0,.1),

})

local Reaper = AddInstance("Part",{
	Parent = head,
	CFrame = head.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(1, 1, 1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Br. yellowish orange"),
})
local Weld = AddInstance("Weld",{
	Parent = Reaper,
	Part0 = head,
	C0 = CFrame.new(-.04,.7,-.1)*CFrame.Angles(0,0,.08),
	Part1 = Reaper,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper,
	MeshId = "rbxassetid://1073659",
	Scale = Vector3.new(1.06,1.05,1.06),
	VertexColor = Vector3.new(1,1,1),
})

local Helmpart2 = AddInstance("Part",{
	Parent = head,
	CFrame = head.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(1, 1, 1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("White"),
})
local Weld = AddInstance("Weld",{
	Parent = Helmpart2,
	Part0 = head,
	C0 = CFrame.new(.01,.4,.05)*CFrame.Angles(.1,0,-.02),
	Part1 = Helmpart2,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Helmpart2,
	Scale = Vector3.new(1.28,.48,1.28),
	VertexColor = Vector3.new(1,1,1),
})


local Glassespart2 = AddInstance("Part",{
	Parent = head,
	CFrame = head.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(1, 1, 1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Really black"),
})
local Weld = AddInstance("Weld",{
	Parent = Glassespart2,
	Part0 = head,
	C0 = CFrame.new(0,.35,0)*CFrame.Angles(0,0,0),
	Part1 = Glassespart2,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Glassespart2,
	Scale = Vector3.new(1.27,.5,1.27),
	VertexColor = Vector3.new(1,1,1),
})








local Reaper3 = AddInstance("Part",{
	Parent = head,
	CFrame = head.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(1, 1, 1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Gold"),
})
local Weld = AddInstance("Weld",{
	Parent = Reaper3,
	Part0 = head,
	C0 = CFrame.new(0,.3,-0.02)*CFrame.Angles(-.1,0,0),
	Part1 = Reaper3,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper3,
	MeshId = "rbxassetid://19380122",
	TextureId = "rbxassetid://19380117",
	Scale = Vector3.new(.9,1,1),
	VertexColor = Vector3.new(1,1,1),
})



spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if equippedgun2 == true and debounce == true and Shotuse == true then
			GlobalFunctions.fling(mouse.Hit.p)
	    end
	end
end)



local Reaper4 = AddInstance("Part",{
	Parent = RightArm,		
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(0.1, 0.5, 3),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	Transparency = 0
})

local shotgunnn = gp(gp(gp(cnnnnn, "Red Sci-Fi Scattergun", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local handlennn = gp(gp(cnnnnn, "Red Sci-Fi Scattergun", "Accessory"), "Handle", "BasePart")
--shotgunnn.Parent = Reaper4


local Weld = AddInstance("Weld",{
	Parent = Reaper4,
	Part0 = RightArm,
	C0 = CFrame.new(-0.35,-1.8,-0.4)*CFrame.Angles(4.7,3.4,0),
	Part1 = Reaper4,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper4,
	MeshId = "rbxassetid://470533002",
	TextureId = "rbxassetid://470533004",
	Scale = Vector3.new(.03,.03,.03),
	VertexColor = Vector3.new(1,1,1),
})				

local GunFire = AddInstance("Part",{
	Parent = RightArm,		
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(0.1, 0.1, 0.1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	Transparency = 1
})
local Weld = AddInstance("Weld",{
	Parent = GunFire,
	Part0 = RightArm,
	C0 = CFrame.new(-0.8,-3.5,-0.7)*CFrame.Angles(4.7,3.4,0),
	Part1 = GunFire,
})


local GunParticle = Instance.new("ParticleEmitter", GunFire);
GunParticle.VelocitySpread = 60;
GunParticle.LightEmission = 200;

local Colors2 = {Color3.new(1,.5,0), Color3.new(1,.7,0), Color3.new(1,.9,0);}		
GunParticle.Size = NumberSequence.new(.05,.07);

GunParticle.Color = ColorSequence.new(Colors2[math.random(#Colors2)]);
GunParticle.Texture = "rbxassetid://252350680";
GunParticle.RotSpeed = NumberRange.new(10,70);
GunParticle.Rate = 600;
GunParticle.Speed = NumberRange.new(15);
GunParticle.Transparency = NumberSequence.new(0,1);
GunParticle.Lifetime = NumberRange.new(.01,.2);
GunParticle.EmissionDirection = 'Back'
GunParticle.Enabled = false	








local Reaper5 = AddInstance("Part",{
	Parent = RightArm,		
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(0.1, 0.5, 3),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	Transparency = 1
})


local wrenchnn = gp(gp(gp(cnnnnn, "Wrench", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local handlenn = gp(gp(cnnnnn, "Wrench", "Accessory"), "Handle", "BasePart")
wrenchnn.Parent = Reaper5

local Weld = AddInstance("Weld",{
	Parent = Reaper5,
	Part0 = RightArm,
	C0 = CFrame.new(-.1,-0.75,-.7)*CFrame.Angles(1.5,0,3),
	Part1 = Reaper5,
})

local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper5,
	MeshId = "rbxassetid://431003868",
	TextureId = "rbxassetid://430627740",
	Scale = Vector3.new(1.93,1.99,1.99),
	VertexColor = Vector3.new(1,1,1),
})	



local Arms = AddInstance("Model",{
	Parent = cam,	
	Name = "Arms",	


})

local Arm1 = AddInstance("Part",{
	Parent = Arms,	
	Name = "RightArm",	
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(.85,1.85,.85),
	CanCollide = false,
	Material = "SmoothPlastic",
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Pastel brown"),
	Transparency = 0
})
local Weld = AddInstance("Weld",{
	Parent = Arm1,
	Part0 = RightArm,
	C0 = CFrame.new(0,0,0)*CFrame.Angles(0,0,0),
	Part1 = Arm1,
})

local Arm2 = AddInstance("Part",{
	Parent = Arms,	
	Name = "LeftArm",	
	CFrame = LeftArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(.85,1.85,.85),
	CanCollide = false,
	Material = "SmoothPlastic",
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Pastel brown"),
	Transparency = 0
})
local Weld = AddInstance("Weld",{
	Parent = Arm2,
	Part0 = LeftArm,
	C0 = CFrame.new(0,0,0)*CFrame.Angles(0,0,0),
	Part1 = Arm2,
})




local Arm3 = AddInstance("Part",{
	Parent = Arms,	
	Name = "RightArm",	
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(.9,.9,.9),
	CanCollide = false,
	Material = "SmoothPlastic",
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=TeamColor,
	Transparency = 0
})
local Weld = AddInstance("Weld",{
	Parent = Arm3,
	Part0 = RightArm,
	C0 = CFrame.new(0,.5,0)*CFrame.Angles(0,0,0),
	Part1 = Arm3,
})

local Arm4 = AddInstance("Part",{
	Parent = Arms,	
	Name = "LeftArm",	
	CFrame = LeftArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(.9,.9,.9),
	CanCollide = false,
	Material = "SmoothPlastic",
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=TeamColor,
	Transparency = 0
})
local Weld = AddInstance("Weld",{
	Parent = Arm4,
	Part0 = LeftArm,
	C0 = CFrame.new(0,.5,0)*CFrame.Angles(0,0,0),
	Part1 = Arm4,
})
local Arm5 = AddInstance("Part",{
	Parent = Arms,	
	Name = "RightArm",	
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(.86,.8,.86),
	CanCollide = false,
	Material = "SmoothPlastic",
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	BrickColor=BrickColor.new("Br. yellowish orange"),
	Transparency = 0
})
local Weld = AddInstance("Weld",{
	Parent = Arm5,
	Part0 = RightArm,
	C0 = CFrame.new(0,-.55,0)*CFrame.Angles(0,0,0),
	Part1 = Arm5,
})

local Reaper6 = AddInstance("Part",{
	Parent = Arms,		
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(0.1, 0.1, .1),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	Transparency = 1
})
local Weld = AddInstance("Weld",{
	Parent = Reaper6,
	Part0 = RightArm,
	C0 = CFrame.new(-0.35,-1.8,-0.4)*CFrame.Angles(4.7,3.4,0),
	Part1 = Reaper6,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper6,
	MeshId = "rbxassetid://470533002",
	TextureId = "rbxassetid://470533004",
	Scale = Vector3.new(.029,.029,.029),
	VertexColor = Vector3.new(1,1,1),
})				













local Reaper7 = AddInstance("Part",{
	Parent = Arms,		
	CFrame = RightArm.CFrame,
	formFactor = "Symmetric",
	Size = Vector3.new(0.1, 0.5, 3),
	CanCollide = false,
	TopSurface = "Smooth",
	BottomSurface = "Smooth",
	Locked = true,
	Transparency = 1
})
local Weld = AddInstance("Weld",{
	Parent = Reaper7,
	Part0 = RightArm,
	C0 = CFrame.new(-.1,-0.75,-.7)*CFrame.Angles(1.5,0,3),
	Part1 = Reaper7,
})
local Mesh = AddInstance("SpecialMesh",{
	Parent = Reaper7,
	MeshId = "rbxassetid://431003868",
	TextureId = "rbxassetid://430627740",
	Scale = Vector3.new(1.9,1.98,1.98),
	VertexColor = Vector3.new(1,1,1),
})	


head.face.Texture = "http://www.roblox.com/asset/?id=156600391"
local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
Humanoid.Animator:Destroy()
Character.Animate:Destroy()

local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)


RSH, LSH = nil, nil 

RW = Instance.new("Weld") 
LW = Instance.new("Weld")

RH = Torso["Right Hip"]
LH = Torso["Left Hip"]

RSH = Torso["Right Shoulder"] 
LSH = Torso["Left Shoulder"] 

RSH.Parent = nil 
LSH.Parent = nil 

RW.Name = "RW"
RW.Part0 = Torso 
RW.C0 = cn(1.5, 0.5, 0)
RW.C1 = cn(0, 0.5, 0) 
RW.Part1 = RightArm
RW.Parent = Torso 

LW.Name = "LW"
LW.Part0 = Torso 
LW.C0 = cn(-1.5, 0.5, 0)
LW.C1 = cn(0, 0.5, 0) 
LW.Part1 = LeftArm
LW.Parent = Torso 

function clerp(a, b, t) 
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5 / s 
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00 - m11 - m22 + 1) 
			local recip = 0.5 / s 
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip 
		elseif i == 1 then 
			local s = math.sqrt(m11 - m22 - m00 + 1) 
			local recip = 0.5 / s 
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip 
		elseif i == 2 then 
			local s = math.sqrt(m22 - m00 - m11 + 1) 
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip 
		end 
	end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w * xs, w * ys, w * zs 
	local xx = x * xs 
	local xy = x * ys 
	local xz = x * zs 
	local yy = y * ys 
	local yz = y * zs 
	local zz = z * zs 
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)) 
end

function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1 / math.sin(theta) 
			startInterp = math.sin((1 - t) * theta) * invSinTheta 
			finishInterp = math.sin(t * theta) * invSinTheta  
		else 
			startInterp = 1 - t 
			finishInterp = t 
		end 
	else 
		if (1 + cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1 / math.sin(theta) 
			startInterp = math.sin((t - 1) * theta) * invSinTheta 
			finishInterp = math.sin(t * theta) * invSinTheta 
		else 
			startInterp = t - 1 
			finishInterp = t 
		end 
	end 
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp 
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


Swait = function(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end

swait = Swait

local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end

function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end

function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld"){
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1,
	}
	return Weld
end

function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function Raycastn(Origin,Direction,Blacklist,MaxDistance,IgnoreWater)
	return workspace:FindPartOnRayWithIgnoreList(Ray.new(Origin,Direction.Unit*MaxDistance),Blacklist or {},false,IgnoreWater)
end

function CreateSound(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound", par or workspace)
		sou.Volume = vol
		sou.Pitch = pit or 1
		sou.SoundId = id
		wait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou, 6)
	end))
end

local function getclosest(obj, distance)
	local last, lastx = distance + 1
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA'Model' and v ~= Character and v ~= Character.Model and v:findFirstChild('Humanoid') and v:findFirstChild('Torso') and v:findFirstChild('Humanoid').Health > 0 then
			local t = v.Torso
			local dist = (t.Position - obj.Position).magnitude
			if dist <= distance then
				if dist < last then
					last = dist
					lastx = v
				end
			end
		end
	end
	return lastx
end

function Damage(hit, damage, cooldown, Color1, Color2, HSound, HPitch)
	for i, v in pairs(hit:GetChildren()) do 
		if v:IsA("Humanoid") and hit.Name ~= Character.Name and hit ~= Character.Model and hit ~= Character then
			local find = v:FindFirstChild("Hitz")
			if not find then
				if v.Parent:findFirstChild("Head") then
					local BillG = Create("BillboardGui"){
						Parent = v.Parent.Head,
						Size = UDim2.new(1, 0, 1, 0),
						Adornee = v.Parent.Head,
						StudsOffset = Vector3.new(math.random(-3, 3), math.random(3, 5), math.random(-3, 3)),
					}
					local TL = Create("TextLabel"){
						Parent = BillG,
						Size = UDim2.new(3, 3, 3, 3),
						BackgroundTransparency = 1,
						Text = tostring(damage).."-",
						TextColor3 = Color1.Color,
						TextStrokeColor3 = Color2.Color,
						TextStrokeTransparency = 0,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						FontSize = Enum.FontSize.Size18,
						Font = "ArialBold",
					}
					coroutine.resume(coroutine.create(function()
						wait(1)
						for i = 0, 1, .1 do
							wait(.1)
							BillG.StudsOffset = BillG.StudsOffset + Vector3.new(0, .1, 0)
						end
						BillG:Destroy()
					end))
				end
				v.Health = v.Health - damage
				local bool = Create("BoolValue"){
					Parent = v,
					Name = 'Hitz',
				}
				if HSound ~= nil and HPitch ~= nil then
					CreateSound(HSound, hit, 1, HPitch) 
				end
				game:GetService("Debris"):AddItem(bool, cooldown)
			end
		end
	end
end


function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.new(x1, y1, z1)
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end




for i = 0, 1, 0.05 do
	swait()
	RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
	Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(0)), .1)
	RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(5), math.rad(0), math.rad(5)), 0.1)
	LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-10)), 0.3)
	if Torsovelocity > 2 then
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-50 * math.cos(sine / 4)), math.rad(0), math.rad(4 * math.cos(sine / 4))), .2)
		RH.C0 = clerp(RH.C0, cn(1, -1 + .1 * math.cos(sine / 5), 0) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1 + .1 * math.cos(sine / 5), 0) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
	elseif Torsovelocity < 1 then
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(5), math.rad(0), math.rad(5)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
	end
end
attack = false















local No = Instance.new("Sound", head);
No.SoundId = "rbxassetid://245064504"
No.Volume = 3
local yes = Instance.new("Sound", head);
yes.SoundId = "rbxassetid://131384028"
yes.Volume = 3
local HitM = Instance.new("Sound", Reaper5);
HitM.SoundId = "rbxassetid://"..WSH
HitM.Volume = 1.1
local Swing = Instance.new("Sound", Reaper5);
Swing.SoundId = "rbxassetid://10209850"
Swing.Volume = 1.5
Swing.Pitch = 1.1
local SwingH = Instance.new("Sound", Reaper5);
SwingH.SoundId = "rbxassetid://10209590"
SwingH.Volume = 2.9
SwingH.Pitch = .8
local Taunt = Instance.new("Sound", head);
Taunt.SoundId = "rbxassetid://150611842"
Taunt.Volume = 2
local RUS = Instance.new("Sound", char);
RUS.SoundId = "rbxassetid://322621962"
RUS.Volume = 2.5
RUS.Pitch = 1
RUS.Looped = true

local Hat1n = gp(gp(gp(cnnnnn, "Yoga Mat", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")

local Hat2n = gp(gp(gp(cnnnnn, "Yoga Mat1", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")

local Hat3n = gp(gp(gp(cnnnnn, "Yoga Mat2", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")

local Hat4n = gp(gp(gp(cnnnnn, "Yoga Mat3", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")

local Hat5n = gp(gp(gp(cnnnnn, "Yoga Mat4", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
Hat1n.Parent = tcnn
Hat2n.Parent = tcnn
Hat3n.Parent = tcnn
Hat4n.Parent = tcnn
Hat5n.Parent = tcnn



local circleturret = gp(gp(gp(cnnnnn, "PirateCaptain_HatAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local circleturretnn = gp(gp(cnnnnn, "PirateCaptain_HatAccessory", "Accessory"), "Handle", "BasePart")
circleturret.Parent = tcnn;

local largeturret = gp(gp(gp(cnnnnn, "Robloxclassicred", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local largeturretnn = gp(gp(cnnnnn, "Robloxclassicred", "Accessory"), "Handle", "BasePart")
largeturret.Position = Vector3.new(0, 0, 0.5)
largeturret.Parent = tcnn;


function BuildSentry()
do --CFrame lerp (stravant, clerp by AntiBoomz0r)
        local function QuaternionFromCFrame(cf)  -- y u no axis angle interpolation?
                local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
                local trace = m00 + m11 + m22 
                if trace > 0 then 
                        local s = math.sqrt(1 + trace) 
                        local recip = 0.5/s 
                        return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
                else 
                        local i = 0 
                        if m11 > m00 then
                                i = 1 
                        end 
                        if m22 > (i == 0 and m00 or m11) then 
                                i = 2 
                        end 
                        if i == 0 then 
                                local s = math.sqrt(m00-m11-m22+1) 
                                local recip = 0.5/s 
                                return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
                        elseif i == 1 then 
                                local s = math.sqrt(m11-m22-m00+1) 
                                local recip = 0.5/s 
                                return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
                        elseif i == 2 then 
                                local s = math.sqrt(m22-m00-m11+1) 
                                local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
                        end 
                end 
        end
        local function QuaternionToCFrame(px, py, pz, x, y, z, w) 
                local xs, ys, zs = x + x, y + y, z + z 
                local wx, wy, wz = w*xs, w*ys, w*zs 
                local xx = x*xs 
                local xy = x*ys 
                local xz = x*zs 
                local yy = y*ys 
                local yz = y*zs 
                local zz = z*zs 
                return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
        end   
        function QuaternionSlerp(a, b, t) 
                local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
                local startInterp, finishInterp; 
                if cosTheta >= 0.0001 then 
                        if (1 - cosTheta) > 0.0001 then 
                                local theta = math.acos(cosTheta) 
                                local invSinTheta = 1/math.sin(theta) 
                                startInterp = math.sin((1-t)*theta)*invSinTheta 
                                finishInterp = math.sin(t*theta)*invSinTheta  
                        else 
                                startInterp = 1-t 
                                finishInterp = t 
                        end 
                else
                        if (1+cosTheta) > 0.0001 then 
                                local theta = math.acos(-cosTheta) 
                                local invSinTheta = 1/math.sin(theta) 
                                startInterp = math.sin((t-1)*theta)*invSinTheta 
                                finishInterp = math.sin(t*theta)*invSinTheta 
                        else 
                                startInterp = t-1 
                                finishInterp = t 
                        end 
                end 
                return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
        end  
        function clerp(a,b,t) 
                local qa = {QuaternionFromCFrame(a)}
                local qb = {QuaternionFromCFrame(b)} 
                local ax, ay, az = a.x, a.y, a.z 
                local bx, by, bz = b.x, b.y, b.z  
                local _t = 1-t 
                return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
        end 
end




local ABS = math.abs;
local SIN = math.sin;
local ASIN = math.asin;
local COS = math.cos;

local new = Instance.new;

function math_pos(float)
    if float < 0 then float = 0 end
    return float
end
function math_neg(float)
    if float > 0 then float = 0 end
    return float
end
function math_max(float, max)
    if float > max then float = max end
    return float
end
function math_min(float, min)
    if float > min then float = min end
    return float
end

function SharpSin(double_p1)
    return ASIN(SIN(double_p1));
end

local Storage = Instance.new("Model", script);

function WeldP(part0, part1, C0, C1)
    local W = new("Weld", Storage);
    W.Part0 = part0;
    W.Part1 = part1;
    W.C0 = C0 or CFrame.new();
    W.C1 = C1 or CFrame.new();
    return W;
end

function Bevel(part, sizeV3)
    local BvlMesh = new("SpecialMesh", part)
    BvlMesh.MeshId = "rbxasset://fonts/torso.mesh";
    if (sizeV3 ~= nil) then
        BvlMesh.Scale = Vector3.new(sizeV3.x/2, sizeV3.y/2, sizeV3.z);
    else
        BvlMesh.Scale = Vector3.new(part.Size.x/2, part.Size.y/2, part.Size.z);
    end
end



local Scale = 0.5 -- 1 is size of a robloxian (mostly);

Storage.Name = "";

local BasePart = new("Part");
BasePart.FormFactor = "Custom";
BasePart.TopSurface = 10;
BasePart.BottomSurface = 10;
BasePart.LeftSurface = 10;
BasePart.RightSurface = 10;
BasePart.FrontSurface = 10;
BasePart.BackSurface = 10;
BasePart.Anchored = true;
BasePart.CFrame = Character.Torso.CFrame * CFrame.new(0, -1.5/Scale, -2.9) * CFrame.Angles(0, math.pi, 0);


local CylPart = new("Part");
CylPart.FormFactor = "Custom";
CylPart.TopSurface = 10;
CylPart.BottomSurface = 10;
CylPart.LeftSurface = 10;
CylPart.RightSurface = 10;
CylPart.FrontSurface = 10;
CylPart.BackSurface = 10;
CylPart.Anchored = true;
CylPart.CFrame = Character.Torso.CFrame * CFrame.new(0, -1.5*Scale, -2.9) * CFrame.Angles(0, math.pi, 0);

new("CylinderMesh", CylPart);



wait(0.2)

CylPart.Anchored = false;
BasePart.Anchored = false;
local TopFrame = BasePart:clone()
TopFrame.Parent = Storage;
TopFrame.Size = Vector3.new(3.5*Scale, 1.5*Scale, 3.5*Scale);
TopFrame.BrickColor = TeamColor;

circleturret.Parent = TopFrame;

new("CylinderMesh", TopFrame);

local Screw = CylPart:clone();
Screw.Parent = Storage;
Screw.Size = Vector3.new(.3*Scale, 1.6*Scale, .3*Scale);
Screw.BrickColor = BrickColor.new(199);

local CGreyStyle = CylPart:clone()
CGreyStyle.Parent = Storage;
CGreyStyle.Size = Vector3.new(2.2*Scale, 1.52*Scale, 2.6*Scale);
CGreyStyle.BrickColor = BrickColor.new(199);

local TurretCasing = BasePart:clone();
TurretCasing.Name = "TurretCasing";
TurretCasing.Size = Vector3.new(2.2*Scale, 1.4*Scale, 5.6*Scale);
TurretCasing.BrickColor = BrickColor.new(199);
TurretCasing.Parent = Storage;

largeturret.Parent = TurretCasing;

Bevel(TurretCasing);

local TurretFront = BasePart:clone();
TurretFront.Name = "TurretFront";
TurretFront.Size = Vector3.new(1.7*Scale, 1*Scale, .2*Scale);
TurretFront.BrickColor = TeamColor;
TurretFront.Parent = Storage;

local Barrel = CylPart:clone();
Barrel.Name = "Barrel";
Barrel.Parent = Storage;
Barrel.Size = Vector3.new(.7*Scale, .4*Scale, .7*Scale);
Barrel.BrickColor = BrickColor.Black();


        local Particle = Instance.new("ParticleEmitter", Barrel);
        Particle.VelocitySpread = 30;
        Particle.LightEmission = 200;

        local Colors = {Color3.new(1,.5,0), Color3.new(1,.7,0), Color3.new(1,.9,0);}

        Particle.Size = NumberSequence.new(.05,.07);

        Particle.Color = ColorSequence.new(Colors[math.random(#Colors)]);
        Particle.Texture = "rbxassetid://252350680";
        Particle.RotSpeed = NumberRange.new(10,70);
        Particle.Rate = 300;
        Particle.Speed = NumberRange.new(15);
        Particle.Transparency = NumberSequence.new(0,1);
        Particle.Lifetime = NumberRange.new(.01,.2);
Particle.Enabled = false



local RedDot = BasePart:clone();
RedDot.Name = "RedDot";
RedDot.Parent = Storage;
RedDot.Size = Vector3.new(.2*Scale, .2*Scale, .2*Scale);
RedDot.BrickColor = BrickColor.new("Really red");

local Sphere = Instance.new("SpecialMesh", RedDot);
Sphere.Name = "Sphere";
Sphere.MeshType = "Sphere";
Sphere.Scale = Vector3.new(1*Scale,1*Scale,1*Scale);


Bevel(TurretFront, Vector3.new(1.7*Scale, 1*Scale, .05*Scale));

local Joint = CylPart:clone();
Joint.Name = "Joint";
Joint.Parent = Storage;
Joint.Size = Vector3.new(.7*Scale, 2*Scale, .7*Scale);
Joint.BrickColor = BrickColor.Black();

--Hat 1

Hat1n.Parent = Joint;


local Hold = BasePart:clone();
Hold.Name = "Hold";
Hold.Parent = Storage;
Hold.BrickColor = BrickColor.Black();
Hold.Size = Vector3.new(2.2*Scale, .2*Scale, .75*Scale);

--Hat 2

Hat2n.Parent = Hold

local Bolt = BasePart:clone();
Bolt.Name = "Bolt";
Bolt.Size = Vector3.new(.2*Scale, 1.5*Scale, .5*Scale);
Bolt.Parent = Storage;
Bolt.BrickColor = BrickColor.Black();

local Bolt2 = BasePart:clone();
Bolt2.Name = "Bolt2";
Bolt2.Size = Vector3.new(.2*Scale, 1.5*Scale, .5*Scale);
Bolt2.Parent = Storage;
Bolt2.BrickColor = BrickColor.Black();


local TurretToFrame = WeldP(TopFrame, TurretCasing, CFrame.new(0, 0, 1.4*Scale));
WeldP(TopFrame, CGreyStyle);
WeldP(TurretCasing, TurretFront, CFrame.new(0, 0, 2.8*Scale));
WeldP(TopFrame, Screw);
local BarrelWeld = WeldP(Barrel, TurretFront, CFrame.new(.3*Scale, -.2*Scale, 0), CFrame.Angles(math.pi/2, 0, 0));

WeldP(RedDot, TurretFront, CFrame.new(-.55*Scale, 0, -.15*Scale), CFrame.Angles(math.pi/2, 0, 0));

local RotateAxisY = WeldP(Bolt, TurretCasing, CFrame.Angles(0,0,0), CFrame.new(1.1*Scale, -.75*Scale, 1*Scale));

WeldP(Bolt, Hold, CFrame.new(-1.1*Scale, -.5*Scale, 0));

WeldP(Bolt2, Hold, CFrame.new(1.1*Scale, -.5*Scale, 0));

local RotateAxisX = WeldP(Hold, Joint, CFrame.new(0, -1*Scale, 0));



local Leg1 = BasePart:clone();
Leg1.Name = "Leg1";
Leg1.Size = Vector3.new(.2*Scale, 3.5*Scale, .5*Scale);
Leg1.Parent = Storage;
Leg1.BrickColor = BrickColor.Black();

--Hat 3

Hat3n.Parent = Leg1

WeldP(Leg1, Joint, CFrame.new(0, -1.75*Scale, 0), CFrame.new(0, -.75*Scale, 0) * CFrame.Angles(math.pi/3, 0, math.pi));


local Leg2 = BasePart:clone();
Leg2.Name = "Leg2";
Leg2.Size = Vector3.new(.2*Scale, 3.5*Scale, .5*Scale);
Leg2.Parent = Storage;
Leg2.BrickColor = BrickColor.Black();

--Hat 4

Hat4n.Parent = Leg2;

WeldP(Leg2, Joint, CFrame.new(0, -1.75*Scale, 0), CFrame.new(0, -.45*Scale, 0) * CFrame.Angles(-math.pi/4, 0, math.pi + -math.pi/6));


local Leg3 = BasePart:clone();
Leg3.Name = "Leg3";
Leg3.Size = Vector3.new(.2*Scale, 3.5*Scale, .5*Scale);
Leg3.Parent = Storage;
Leg3.BrickColor = BrickColor.Black();

--Hat 5

Hat5n.Parent = Leg3;

WeldP(Leg3, Joint, CFrame.new(0, -1.75*Scale, 0), CFrame.new(0, -.45*Scale, 0) * CFrame.Angles(-math.pi/4, 0, math.pi + math.pi/6));

	for i,v in pairs(Storage:children()) do
		if v.Name== "Part" then
			trans = 1
			v.Transparency = 1
		end
		end

local InvisiBox = BasePart:clone();
InvisiBox.Name = "InvisiBox";
InvisiBox.Size = Storage:GetModelSize() + Vector3.new(2*Scale, 0, 0);
InvisiBox.Parent = Storage;
InvisiBox.Transparency = 1
InvisiBox.Name = 'box'
WeldP(InvisiBox, Joint, CFrame.new(0, -.2*Scale, .97*Scale));

local InvisiBox2 = BasePart:clone();
InvisiBox2.Name = "InvisiBox2"
InvisiBox2.Size = Storage:GetModelSize() + Vector3.new(2*Scale, 0, 0);
InvisiBox2.Parent = Arms;
InvisiBox2.Transparency = .9
InvisiBox2.Name = 'box'
InvisiBox2.CanCollide = false
InvisiBox2.BrickColor = TeamColor
InvisiBox2.Material = 'Neon'
WeldP(InvisiBox2, Joint, CFrame.new(0, -1.2*Scale, .97*Scale));

InvisiBox.CFrame = Character.Torso.CFrame * CFrame.new(0, 5.5*Scale, -2.9) * CFrame.Angles(0, math.pi, 0);



local Action = "Idle";

local Target = nil;

wait(1)

InvisiBox.Anchored = true



for i,v in pairs(Storage:children()) do
    if v:IsA'Part' then
        v.Locked = true
    end
end
--//
--// SOUNDS
--//
	for i,v in pairs(Storage:children()) do
		if v.Name== "Part" then
			trans = 1
			v.Transparency = 1
		end
		end
	for i,v in pairs(Storage:children()) do
		if v.Name== "Part" then
			trans = 1
			v.Transparency = 1
		for i = 1,11 do
				
			trans = trans - .1
			v.Transparency = trans
			wait()
			end
			end
	end
	trans = 1

local OnFind = new("Sound", TopFrame);
OnFind.SoundId = "rbxassetid://10209260"
OnFind.Volume = 1


local OnFire = new("Sound", TopFrame);
OnFire.SoundId = "rbxassetid://10209257"
OnFire.Volume = 1

local OnEmpty = new("Sound", TopFrame);
OnEmpty.SoundId = "rbxassetid://10209225"
OnEmpty.Volume = 1

local Scanning = new("Sound", TopFrame);
Scanning.SoundId = "rbxassetid://258704234"
Scanning.Volume = 1

local Explode = new("Sound", TopFrame);
Explode.SoundId = "rbxassetid://10209236"
Explode.Volume = .5

local Move = new("Sound", TopFrame);
Move.SoundId = "rbxassetid://258704467";
Move.Volume = 1;





function FindShortest(Table)
local Current = Table[1]
local Final
for _,v in pairs(Table) do
if v[2] ~= Current[2] then
if v[1] < Current[1] then
Current = v
end
end
end
Final = Current
return Final
end

function GetNearbyPlayer()

    local List = {}
    for i,v in pairs(workspace:children()) do
        if (v ~= nil) then
            if (v:IsA'Model') then
                if (v:findFirstChild'Torso' ~= nil) then
                    local rx, ry, rz = Hold.CFrame:toEulerAnglesXYZ();
                    if (v:findFirstChild'Torso'.Position - Hold.CFrame * CFrame.new(0, 0, 20) * CFrame.Angles(0, ry, 0).p).magnitude < 20 then
                        if (v ~= char and v ~= char.Model) then
                            for x,z in next, v:children() do
                                if z:IsA'Humanoid' and z.Health > 0.01 then
                                    table.insert(List, {(v:findFirstChild'Torso'.Position - Hold.CFrame * CFrame.new(0, 0, 20) * CFrame.Angles(0, ry, 0).p).magnitude, v})
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if (FindShortest(List) ~= nil) then
        return FindShortest(List)[2];
    else
        return nil;
    end
end

local Health = Instance.new("Humanoid", Storage);
Health.MaxHealth = 150;
Health.Health = 150;



function RayC(Part, speed)
	coroutine.wrap(function()
		local Visual = BasePart:clone();
		Visual.FormFactor = "Custom";
		Visual.BrickColor = BrickColor.Yellow();
		Visual.Size = Vector3.new(.2, 3, .2);
		Visual.CFrame = Part.CFrame * CFrame.new(0, -1, 0);
		Visual.Anchored = true;
		Visual.CanCollide = false;
		Visual.Locked = true


		coroutine.wrap(function()

			wait(.2)

			wait(.1);
			wait(.3)

		end)()

		Instance.new("SpecialMesh", Visual).MeshType = "Sphere";
		Visual.Mesh.Scale = Vector3.new(.5, 1, .5);

		local bulletpos = Visual.Position
		local bulletvelocity = (Part.CFrame.p - bulletpos).unit*speed
		local lastbulletpos = Visual.Position 
		Visual.Parent = Storage;
		while game:service'RunService'.Stepped:wait() do

			lastbulletpos = bulletpos 
			bulletpos = bulletpos + bulletvelocity
			--local RayCast = Ray.new(lastbulletpos, (bulletpos - lastbulletpos))
			local hit, hitpos = Raycastn(lastbulletpos, (bulletpos - lastbulletpos), { char, Storage, char.Model }, 999.999, true)
			if (Joint.Position - Visual.Position).magnitude > 1000 or Visual.Parent == nil then
				Visual:Destroy();
				break
			end
			Visual.Anchored = true
			Visual.CFrame = CFrame.new(bulletpos, bulletpos+bulletvelocity) * CFrame.Angles(math.pi/2, 0, 0);
			if hit then
		
				if hit.Parent then
				
					if hit.Parent.Parent.ClassName == "Model" then
						
						for _, c in pairs(hit.Parent.Parent:GetChildren()) do
							if c:IsA'Humanoid' then
								print("Hit Parent Parent")
								GlobalFunctions.fling(c.Parent,0.2)
								--z:TakeDamage(math.random(8,12));
							end
						end

					elseif hit.Parent.ClassName == "Model" then
						for _, c in pairs(hit.Parent:GetChildren()) do
								if c:IsA'Humanoid' then
									print("Hit Parent")
									GlobalFunctions.fling(c.Parent,0.2)
									--z:TakeDamage(math.random(8,12));
								end
							end
					end
				end
				

				Visual:Destroy();
				break
			end
		end
	end)()
end


lastTick = tick();
local db = false;
game:service'RunService'.RenderStepped:connect(function()
    if Action == "DEAD" then return end;


    if not Wrangler then
        --//
        --// AUTOMATED MODE, MOTION SENSOR WILL DETECT MOVEMENT
        --//


        --//
        --// IF PLAYER USED WRANGLER, THERE IS A SHIELD WICH MUST BE REMOVED
        --// 

        if (Storage:findFirstChild'Shield') then
            Storage:findFirstChild'Shield':Destroy();
        end

        local LastTarget = Target;

        --//
        --// CHECK FOR NEARBY ENEMIES
        --//
        local Player = GetNearbyPlayer();
        Target = Player;

        --//
        --// BEEP ON TARGET FOUND
        --//
        if (Target ~= LastTarget and Target ~= nil) then
            Move.Pitch = 0.9 + math.random()/9;
            Move:play();
            OnFind:play();
            Action = "Standby";
        end

        --//
        --// IDLE
        --//
        if Action == "Idle" then
            RotateAxisX.C1 = clerp(RotateAxisX.C1, CFrame.Angles(0, SharpSin(tick()*2)*.2, 0), .1);
            RotateAxisY.C0 = clerp(RotateAxisY.C0, CFrame.new(), .1);
        end


        --//
        --// SENTRY DEAD
        --//

        --//
        --// IF PLAYER EXISTS, FIRE!
        --//



        if Action == "Standby" then
            pcall(function()
                local tor = Target.Torso.CFrame.p -- Target CFrame
                local direction = InvisiBox.CFrame.lookVector -- Direction handling, welds mess up, just a workaround.
                local heading = math.atan2(direction.x, direction.z)--
                local RotY = math.deg(heading)
                    if RotY < 0 then
                        RotY = (360 - math.abs(RotY));
                    end
                RotateAxisX.C1 = --Begin here
                clerp(RotateAxisX.C1, 
                CFrame.new(

                  Vector3.new(), --The Pivot0 of pointing the weld.
                  Vector3.new(tor.x, 0, tor.z) - Vector3.new(RotateAxisX.Part1.CFrame.x, 0, RotateAxisX.Part1.CFrame.z)) --We point the sentry here

                * CFrame.Angles(0, math.rad(360) - math.rad(RotY), 0), 
                .1
                );
                
                local Point = Hold.CFrame:toObjectSpace(CFrame.new(Hold.CFrame.p,tor))*CFrame.Angles(0,math.rad(180),0)
                local RX, RY, RZ = Point:toEulerAnglesXYZ()
                if math.deg(RX) > 45 then
                    RX = math.rad(45)
                elseif math.deg(RX) < -55 then
                    RX = math.rad(-55)
                end
                RotateAxisY.C0 = clerp(RotateAxisY.C0,CFrame.Angles(RX,0,0),.1)
                
            end)
        end
        if Action == "Fire" then
            pcall(function()
                local tor = Target.Torso.CFrame.p;
                local direction = InvisiBox.CFrame.lookVector
                local heading = math.atan2(direction.x, direction.z)
                local RotY = math.deg(heading)
                    if RotY < 0 then
                        RotY = (360 - math.abs(RotY));
                    end
                RotateAxisX.C1 = --Begin here
                clerp(RotateAxisX.C1, 
                CFrame.new(

                  Vector3.new(), --The Pivot0 of pointing the weld.
                  Vector3.new(tor.x, 0, tor.z) - Vector3.new(RotateAxisX.Part1.CFrame.x, 0, RotateAxisX.Part1.CFrame.z)) --We point the sentry here

                * CFrame.Angles(0, math.rad(360) - math.rad(RotY), 0), 
                .1
                );

                BarrelWeld.C0 = clerp(BarrelWeld.C0, CFrame.new())
                local Point = Hold.CFrame:toObjectSpace(CFrame.new(Hold.CFrame.p,tor))*CFrame.Angles(0,math.rad(180),0)
                local RX, RY, RZ = Point:toEulerAnglesXYZ()
                if math.deg(RX) > 45 then
                    RX = math.rad(45)
                elseif math.deg(RX) < -55 then
                    RX = math.rad(-55)
                end
                RotateAxisY.C0 = clerp(RotateAxisY.C0,CFrame.Angles(RX,0,0),.1)
            end)
        end

        if (Target ~= nil) then
            if Action == "Fire" or db then return end
            if Action == "Standby" then
                db = true
                wait(.2);
            end
            Action = "Fire";
            db = false
            OnFire:play();

        Particle.Color = ColorSequence.new(Colors[math.random(#Colors)]);

            local PointLight = Instance.new("PointLight", Barrel);
            PointLight.Color = Color3.new(1,.8,0)
            PointLight.Brightness = 6;
Particle.Enabled = true
            game:service'Debris':AddItem(PointLight, .05);



            RayC(Barrel, 20)




            wait(.1)
Particle.Enabled = false
            if (Target ~= nil) then
                Action = "Standby";
            else
                Action = "Idle";
            end
        end

        if tick() - lastTick > 2.5 and Target == nil then
            lastTick = tick();
            Scanning:play();
        end
    end

    if (Health.Health < 0.0001 or RotateAxisX.Parent == nil) then
            Action = "DEAD";
            if db then return end
            circleturret.Parent = handlenn;
            RotateAxisY:Destroy();
            TurretToFrame:Destroy();
            Joint:Destroy();
InvisiBox2:Destroy();
            db = true

Explode:Play()
NoSentry = true
circleturret.Parent = tcnn;
largeturret.Parent = tcnn;
Hat1n.Parent = tcnn;
Hat2n.Parent = tcnn;
Hat3n.Parent = tcnn;
Hat4n.Parent = tcnn;
Hat5n.Parent = tcnn;
            game:service'Debris':AddItem(Storage, 3);
            
        end 

end)
end




combo = 0
function strike(hit)
	if hit and hit.Parent and hit.Parent.Name ~= char.Name and hit.Parent ~= char.Model then
		local targetHumanoid = hit.Parent:FindFirstChild("Humanoid")
		if targetHumanoid and targetHumanoid ~= char:FindFirstChild("Humanoid") then
			if combo == 1 then
				GlobalFunctions.fling(targetHumanoid.Parent)
			
				--targetHumanoid:TakeDamage(slashDamage)
				SwingH:Play()

			end



		end
	end
end



Reaper5.Touched:connect(strike)
--------------------------------------------------------------------------------------------------------------------------
function AnimSit()
	for i = 0, 1, 0.05 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, -1, -.6) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.3, .1) * angles(math.rad(20), math.rad(0), math.rad(20)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(0), math.rad(0), math.rad(5)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -.4, -.4) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, -.6) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(60)), .1)
	end

end

function AnimSitHit1()
	for i = 0, 1, 0.05 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, -1, -.6) * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(0)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.3, .1) * angles(math.rad(20), math.rad(0), math.rad(20)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(170), math.rad(0), math.rad(-5)), 0.08)
		RH.C0 = clerp(RH.C0, cn(1, -.4, -.4) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(10)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, -.6) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(50)), .1)
	end

end


function AnimSitHit2()
	for i = 0, 1, 0.05 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, -1, -.6) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(15), math.rad(0), math.rad(0)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.3, .1) * angles(math.rad(20), math.rad(0), math.rad(20)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.55, 0.4, -.1) * angles(math.rad(40), math.rad(3 ), math.rad(-15)), 0.3)
		RH.C0 = clerp(RH.C0, cn(1, -.4, -.4) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, -.6) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(60)), .1)
	end

end		
--------------------------------------------------------------------------------------------------------------------------

function No1()
	for i = 0, 1, 0.05 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(30), math.rad(0), math.rad(40)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.1) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(30), math.rad(0), math.rad(0)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
	end

end	



function No2()
	for i = 0, 1, 0.05 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-40)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.1) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(30), math.rad(0), math.rad(0)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
	end

end	



--------------------------------------------------------------------------------------------------------------------------

function Yes1()
	for i = 0, 1, 0.1 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(25), math.rad(0), math.rad(0)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.1) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(30), math.rad(0), math.rad(0)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
	end

end	



function Yes2()
	for i = 0, 1, 0.1 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.1) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(30), math.rad(0), math.rad(0)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
	end

end	



--------------------------------------------------------------------------------------------------------------------------
function AttackAnim1()
	for i = 0, 1, 0.05 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(0)), .1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(170), math.rad(0), math.rad(10)), 0.08)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(40), math.rad(0), math.rad(10)), 0.3)
		if Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1 + .1 * math.cos(sine / 5), 0) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1 + .1 * math.cos(sine / 5), 0) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
		elseif Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(-5)), .1)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(5)), .1)
		end
	end
end


function AttackAnim2()
	for i = 0, 1, 0.05 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(0)), .1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(5), math.rad(10), math.rad(-10)), 0.25)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(10)), 0.3)
		if Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.9 + -.1 * math.cos(sine / 4),0 + -.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.9 + .1 * math.cos(sine / 4), 0 + .1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)

		elseif Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(5)), .1)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(-5)), .1)
		end
	end
end
--------------------------------------------------------------------------------------------------------------------------



function ShotAttackAnim1()
	for i = 0, 1, 0.07 do
		swait()

		if Torsovelocity > 2 then
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(-50 - 5 * math.cos(sine / 5))), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(50 + 5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(90), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(85 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 + -.1 * math.cos(sine / 4),-.6) * RHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 + .1 * math.cos(sine / 4),  .5) * LHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)				



		elseif Torsovelocity < 1 then


			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-50)), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(50)), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(90), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(85 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 - 0.1 * math.cos(sine / 25), -.6) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 - 0.1 * math.cos(sine / 25), .5) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)			


		end
	end
end





function ShotAttackAnim2()
	for i = 0, 1, 0.05 do
		swait()

		if Torsovelocity > 2 then
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(-50 - 5 * math.cos(sine / 5))), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(50 + 5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(100), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(75 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.1)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 + -.1 * math.cos(sine / 4),-.6) * RHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 + .1 * math.cos(sine / 4),  .5) * LHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)				



		elseif Torsovelocity < 1 then


			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-50)), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(50)), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(100), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(75 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.1)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 - 0.1 * math.cos(sine / 25), -.6) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 - 0.1 * math.cos(sine / 25), .5) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)			


		end
	end
end



function ShotAttackAnim3()
	for i = 0, 1, 0.05 do
		swait()

		if Torsovelocity > 2 then
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(-50 - 5 * math.cos(sine / 5))), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(50 + 5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.56, -.2) * angles(math.rad(45), math.rad(-20 - .01 * math.cos(sine / 25)), math.rad(-70 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -.6) * angles(math.rad(115 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-30 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 + -.1 * math.cos(sine / 4),-.6) * RHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 + .1 * math.cos(sine / 4),  .5) * LHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)				



		elseif Torsovelocity < 1 then


			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-50)), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(50)), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.56, -.2) * angles(math.rad(45), math.rad(-20 - .01 * math.cos(sine / 25)), math.rad(-70 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -.6) * angles(math.rad(115 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-30 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 - 0.1 * math.cos(sine / 25), -.6) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 - 0.1 * math.cos(sine / 25), .5) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)			


		end
	end
end

function ShotAttackAnim4()
	for i = 0, 1, 0.05 do
		swait()

		if Torsovelocity > 2 then
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(-50 - 5 * math.cos(sine / 5))), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(50 + 5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.56, 0) * angles(math.rad(45), math.rad(-20 - .01 * math.cos(sine / 25)), math.rad(-70 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -.8) * angles(math.rad(115 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-50 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 + -.1 * math.cos(sine / 4),-.6) * RHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 + .1 * math.cos(sine / 4),  .5) * LHCF * angles(math.rad(-2), math.rad(50), math.rad(50 * math.cos(sine / 4))), .3)				



		elseif Torsovelocity < 1 then


			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-50)), .2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(50)), .2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.56, 0) * angles(math.rad(45), math.rad(-20 - .01 * math.cos(sine / 25)), math.rad(-70 + 0.1 * math.cos(sine / 25))), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -.8) * angles(math.rad(115 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-50 - 1 * math.cos(sine / 25))), 0.2)
			RH.C0 = clerp(RH.C0, cn(.9, -.9 - 0.1 * math.cos(sine / 25), -.6) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)
			LH.C0 = clerp(LH.C0, cn(-.9, -.9 - 0.1 * math.cos(sine / 25), .5) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(50), math.rad(10 + 2 * math.cos(sine / 25))), .2)			


		end
	end
end
--------------------------------------------------------------------------------------------------------------------------

function DanAni1()
	for i = 0, .8, 0.05 + MusThingHat.Mesh.Scale.Y*0.025 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,-.4) * angles(math.rad(5), math.rad(-8), math.rad(0)), MusThingHat.Mesh.Scale.Y*0.2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(MusThingHat.Mesh.Scale.Y*30)    +math.rad(-10),0,math.rad(0)),MusThingHat.Mesh.Scale.Y*0.2)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.25) * angles(math.rad(170), math.rad(0), math.rad(20)), MusThingHat.Mesh.Scale.Y*0.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.0) * angles(math.rad(90), math.rad(0), math.rad(-45)), MusThingHat.Mesh.Scale.Y*0.2)
		RH.C0 = clerp(RH.C0, cn(1, -.2, -.4) * RHCF * angles(math.rad(-4), math.rad(-15), math.rad(-5)), MusThingHat.Mesh.Scale.Y*0.3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, -.0) * LHCF * angles(math.rad(4), math.rad(5), math.rad(5)), MusThingHat.Mesh.Scale.Y*0.2)
	end

end	



function DanAni2()
	for i = 0, .8, 0.05 + MusThingHat.Mesh.Scale.Y*0.025 do

		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0,0,-.5) * angles(math.rad(8), math.rad(8), math.rad(0)), MusThingHat.Mesh.Scale.Y*0.2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(MusThingHat.Mesh.Scale.Y*30)    +math.rad(-10),0,math.rad(0)),MusThingHat.Mesh.Scale.Y*0.2)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, -.25) * angles(math.rad(180), math.rad(0), math.rad(25)), MusThingHat.Mesh.Scale.Y*0.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.0) * angles(math.rad(0), math.rad(0), math.rad(45)), MusThingHat.Mesh.Scale.Y*0.2)
		RH.C0 = clerp(RH.C0, cn(1, -1, -.0) * RHCF * angles(math.rad(4), math.rad(-5), math.rad(-8)), MusThingHat.Mesh.Scale.Y*0.2)
		LH.C0 = clerp(LH.C0, cn(-1, -.2, -.4) * LHCF * angles(math.rad(-4), math.rad(15), math.rad(8)), MusThingHat.Mesh.Scale.Y*0.3)
	end


end	



--------------------------------------------------------------------------------------------------------------------------

BuildNow = false

Shotuse	= false	

wait2 = false

mouse.KeyDown:connect(function(key)

	if key == "g" and attack == false then
		yes:Play()
		head.face.Texture = "http://www.roblox.com/asset/?id=393521316"
		humanoid.WalkSpeed = 0
		attack = true 
		Yes1()
		Yes2()
		Yes1()
		Yes2()
		attack = false 
		humanoid.WalkSpeed = 16
		head.face.Texture = "http://www.roblox.com/asset/?id=156600391"
	end
end)


mouse.KeyDown:connect(function(key)
	if key == "e" and attack == false then
		if Wep == 1 then
			Wep = 2
		else 	
			Wep = 1		
		end		


	end
end)

mouse.KeyDown:connect(function(key)
	if key == "p" and attack == false then

		Wep = 3		



	end
end)












equippedgun = true




coroutine.wrap(function()
	while equippedgun do

		if spread < 0 then spread = 0 end
		if humanoid.Health == 0 then break end


		Swait()
	end
end)()

mouse.Button1Down:connect(function()
	if debounce then return end
	if equippedgun2 == true and attack == false then
		Shotuse = true
		debounce = true

		wait(.2)

		sound:play()



		coroutine.wrap(function()
			wait(0.3)
			for angle = 0, 4 do

				wait()
			end

			wait(0.2)
			sound2:play()


			wait(0.1)
			for move = 0, 3 do
				if move > 2 then return end


				wait(0.06)
			end
		end)()
		spread = spread + 1
		coroutine.wrap(function()
			for bullitz = 0, 7 do
				if bullitz > 6 then return end
				rayCast2(300, 1, Reaper4)
				GunParticle.Enabled = true
				local PointLight = Instance.new("PointLight", Reaper4);
				PointLight.Color = Color3.new(.2,.2,0)
				PointLight.Brightness = 2;
				game:service'Debris':AddItem(PointLight, .05);
			end
		end)()
		coroutine.wrap(function()
			for _ = 0, 50 do
				pcall(function()
					spread = spread - 0.03
				end)
				wait()
			end
		end)()
		wait(1)
		debounce = false
	end

end)









mouse.Button1Down:connect(function(key)

	if attack == false and Wep == 1 then
		attack = true

		AttackAnim1()
		combo = 1
		Swing:Play()
		AttackAnim2()
		attack = false
		combo = 0
	end
end)



mouse.KeyDown:connect(function(key)

	if key == "f" and attack == false then
		No:Play()
		humanoid.WalkSpeed = 0
		attack = true 
		No1()
		No2()
		attack = false 
		humanoid.WalkSpeed = 16
	end
end)




mouse.KeyDown:connect(function(key)
	if attack == false or DA == true then
		if key == "r" and Wep == 3 then

			if DA == false then
				DA = true
				RUS:Play()
				attack=true
				humanoid.WalkSpeed = 0
				head.face.Texture = "http://www.roblox.com/asset/?id=393521316"
			else
				DA = false
				RUS:Stop()
				attack=false
				humanoid.WalkSpeed = 16
				head.face.Texture = "http://www.roblox.com/asset/?id=156600391"
			end
		end
	end
end)



mouse.KeyDown:connect(function(key)

	if key == "t" and attack == false then
		Taunt:Play()
		humanoid.WalkSpeed = 0
		attack = true 
		No1()
		Yes2()
		attack = false 
		humanoid.WalkSpeed = 16
	end
end)

mouse.KeyDown:connect(function(key)
	if key == "z" then



		if	NoSentry == false and attack == false and wait2 == false  then
			wait2 = true	
			circleturret.Parent = tcnn;
			largeturret.Parent = tcnn;
			Hat1n.Parent = tcnn;
	   Hat2n.Parent = tcnn;
	   Hat3n.Parent = tcnn;
	   Hat4n.Parent = tcnn;
	   Hat5n.Parent = tcnn;
			for _, c in pairs(workspace:GetChildren()) do
				if c:IsA("Model") and c.Name == "" then
					c.Humanoid.Health = 0
					print(c.Humanoid.Health)
				end
				NoSentry = true	
			end
		



		end



		if NoSentry == true and attack == false and wait2 == false and Wep == 1  then
			attack = true
			wait2 = true
			humanoid.WalkSpeed = 0
			AnimSit()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			BuildNow = true
			AnimSitHit2()		
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()		
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()	
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()	
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSitHit1()
			WSH = WSHM[math.random(1,#WSHM)]
			HitM.SoundId = "rbxassetid://"..WSH
			HitM:Play()	
			AnimSitHit2()
			AnimSit()			

			humanoid.WalkSpeed = 16		
			attack = false
			NoSentry = false

		end
		wait()

		wait2 = false
	end end)




print([[
	
	
----------------------------------------
Tf2 Engineer Class
----------------------------------------
Script by: 123jl123	
Sentry by: Madiik
TheBoozled gave me a Mesh and Sounds from tf2 
----------------------------------------
Dont leak and dont do it.....
----------------------------------------
]])

game:GetService("RunService"):BindToRenderStep("ew", 0, function()
	MusThingHat.Mesh.Scale = Vector3.new(MusThingHat.Mesh.Scale.X, RUS.PlaybackLoudness / 160, MusThingHat.Mesh.Scale.Z)
end)

local mesh1anan = Instance.new("SpecialMesh")
mesh1anan.MeshType = Enum.MeshType.FileMesh
mesh1anan.Scale = Vector3.new(3,3,3)
mesh1anan.MeshId = "http://www.roblox.com/asset/?id=521754610"
mesh1anan.TextureId = "http://www.roblox.com/asset/?id=521754612"

Glow1 = Color3.new(1,1,1)
Glow2 = Color3.new(0,0,0)

GlowParticle = Instance.new("ParticleEmitter")
GlowParticle.LightEmission = 1

GlowParticle.Size = NumberSequence.new(0,2)
GlowParticle.Texture = "http://www.roblox.com/asset/?id=52620985"
GlowParticle.Transparency = NumberSequence.new(0,1)
GlowParticle.LockedToPart = false
GlowParticle.Lifetime = NumberRange.new(0.5)
GlowParticle.Rate= 25
GlowParticle.Speed =NumberRange.new(0)	


function RainDucks()
	local locationanan = char.Torso.CFrame
	local tacoa = Instance.new("Part")
	tacoa.Size = Vector3.new(.5,.5,.5)
	tacoa.CanCollide = false
	tacoa.RotVelocity = Vector3.new(math.random(0,6),math.random(0,6),math.random(0,6))
	local meshanananan = mesh1anan:clone()
	meshanananan.Parent = tacoa
	meshanananan.Scale = Vector3.new(1,1,1)
	tacoa.CFrame = locationanan * CFrame.new(math.random(-8,8),math.random(10,40),math.random(-8,8))
	tacoa.Parent = workspace


	game:GetService("Debris"):AddItem(tacoa,4)	
	local GP = GlowParticle:clone()
	GP.Parent = tacoa
	Glow1 = Color3.new(math.random(), math.random(), math.random())
	GP.Color = ColorSequence.new(Glow1,Glow2)

end



--]]



game:GetService'RunService'.Stepped:connect(function()
	Swait()
	if BuildNow == true then
		BuildNow = false

		BuildSentry()		
	end
	if Shotuse == true then
		Shotuse	= false	
		attack = true 
		ShotAttackAnim1()
		GunParticle.Enabled = false
		ShotAttackAnim2()
		ShotAttackAnim3()
		ShotAttackAnim4()
		ShotAttackAnim3()
		attack = false 
	end




	if DA == true then
		DanAni1()	
		RainDucks()	
		local PointLight = Instance.new("PointLight", Torso);
		PointLight.Color = Color3.new(math.random(), math.random(), math.random())
		PointLight.Brightness = 50;
		PointLight.Range = MusThingHat.Mesh.Scale.Y*10;
		game:service'Debris':AddItem(PointLight, .3);

		DanAni2()	
		RainDucks()
		local PointLight = Instance.new("PointLight", Torso);
		PointLight.Color = Color3.new(math.random(), math.random(), math.random())
		PointLight.Brightness = 50;
		PointLight.Range = MusThingHat.Mesh.Scale.Y*10;
		game:service'Debris':AddItem(PointLight, .3);



	end	






end)


while true do

	Swait()
	
		if Wep == 1 then
			shotgunnn.Rotation = Vector3.new(-0, 0, -0)
			shotgunnn.Parent = handlennn
			wrenchnn.Rotation = Vector3.new(-180, -5.00896e-06, -180)
			wrenchnn.Parent = Reaper5
			equippedgun2 = false
			Reaper4.Transparency = 1	
			Reaper5.Transparency = 1 --0
			Reaper6.Transparency = 1
			Reaper7.Transparency = 1 --0
		end
		if Wep == 2 then
			shotgunnn.Rotation = Vector3.new(-55, 90, 0)
			wrenchnn.Rotation = Vector3.new(-0, 0, -0)
			wrenchnn.Parent = handlenn
			shotgunnn.Parent = Reaper4
			equippedgun2 = true
			Reaper4.Transparency = 1	 --0
			Reaper5.Transparency = 1
			Reaper6.Transparency = 0
			Reaper7.Transparency = 1
		end
		if Wep == 3 then
			equippedgun2 = false
			Reaper4.Transparency = 1	
			Reaper5.Transparency = 1 
			Reaper6.Transparency = 1
			Reaper7.Transparency = 1
		end
	
		Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
		velocity = RootPart.Velocity.y
		sine = sine + change
		local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
		if equipped == true or equipped == false then
			if RootPart.Velocity.y > 1 and hit == nil then 
				Anim = "Jump"
				if attack == false and Wep == 1 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(30)), .1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(-30)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -.9, -.3) * RHCF * angles(math.rad(3), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.7, -.5) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .1)
				end
			elseif RootPart.Velocity.y < -1 and hit == nil then 
				Anim = "Fall"
				if attack == false and Wep == 1 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), .1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -1, -.3) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8, -.3) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
				end
			elseif Torsovelocity < 1 and hit ~= nil then
				Anim = "Idle"
				if attack == false and Wep == 1 then
					change = 1
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.1 * math.cos(sine / 25)) * angles(math.rad(0), math.rad(0), math.rad(5)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5 - 2 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5 - -.1 * math.cos(sine / 25), 0) * angles(math.rad(50), math.rad(35 - 25 * math.cos(sine / 25)), math.rad(5 + 3 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(80 + 7 * math.cos(sine / 25)), math.rad(-30), math.rad(35 - 1 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.1 * math.cos(sine / 25), 0) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.1 * math.cos(sine / 25), 0) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
				end
			elseif Torsovelocity > 2 and hit ~= nil then
				Anim = "Walk"
				if attack == false and Wep == 1 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(5 * math.cos(sine / 5))), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2 - -.05 * math.cos(sine / 4), 0.5 - -.05 * math.cos(sine / 4), 0) * angles(math.rad(50), math.rad(57 - .1 * math.cos(sine / 25)), math.rad(5 + 3 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2 - -.05 * math.cos(sine / 4), 0.4 - -.05 * math.cos(sine / 4), -.4) * angles(math.rad(80 + 1 * math.cos(sine / 25)), math.rad(-30), math.rad(35 - 1 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 + -.1 * math.cos(sine / 4),0 + -.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 + .1 * math.cos(sine / 4), 0 + .1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)
				end
			end
		end
		-----------------------[Anim2]--------------------------------------------------------------------------------------------------------------------------
	
		if equipped == true or equipped == false then
			if RootPart.Velocity.y > 1 and hit == nil then 
				Anim = "Jump"
				if attack == false and Wep == 2 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.2, 0) * angles(math.rad(60), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.1, -.4) * angles(math.rad(55 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9, -.3) * RHCF * angles(math.rad(3), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.7, -.5) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .1)
				end
	
			elseif RootPart.Velocity.y < -1 and hit == nil then 
				Anim = "Fall"
				if attack == false and Wep == 2 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.8, 0) * angles(math.rad(60), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.05)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.7, -.4) * angles(math.rad(55 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.05)
					RH.C0 = clerp(RH.C0, cn(1, -1, -.3) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8, -.3) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
				end
			elseif Torsovelocity < 1 and hit ~= nil then
				Anim = "Idle"
				if attack == false and Wep == 2 then
					change = 1
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.1 * math.cos(sine / 25)) * angles(math.rad(0), math.rad(0), math.rad(5)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5 - 2 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(60), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(55 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.1 * math.cos(sine / 25), 0) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.1 * math.cos(sine / 25), 0) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
				end
			elseif Torsovelocity > 2 and hit ~= nil then
				Anim = "Walk"
				if attack == false and Wep == 2 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(-25 - 5 * math.cos(sine / 5))), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(25 + 5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(60), math.rad(0 - .01 * math.cos(sine / 25)), math.rad(-40 + 0.1 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.4) * angles(math.rad(55 + 1 * math.cos(sine / 25)), math.rad(15), math.rad(-10 - 1 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(.95, -.9 + -.1 * math.cos(sine / 4),-.35) * RHCF * angles(math.rad(-2), math.rad(25), math.rad(50 * math.cos(sine / 4))), .3)
					LH.C0 = clerp(LH.C0, cn(-.95, -.9 + .1 * math.cos(sine / 4), .35) * LHCF * angles(math.rad(-2), math.rad(25), math.rad(50 * math.cos(sine / 4))), .3)
				end
	
			end
		end
	
	
	
		-----------------------[Noraml Anim]--------------------------------------------------------------------------------------------------------------------------
	
		if equipped == true or equipped == false then
			if RootPart.Velocity.y > 1 and hit == nil then 
				Anim = "Jump"
				if attack == false and Wep == 3 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(30)), .1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(-30)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -.9, -.3) * RHCF * angles(math.rad(3), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.7, -.5) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .1)
				end
			elseif RootPart.Velocity.y < -1 and hit == nil then 
				Anim = "Fall"
				if attack == false and Wep == 3 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), .1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -1, -.3) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8, -.3) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
				end
			elseif Torsovelocity < 1 and hit ~= nil then
				Anim = "Idle"
				if attack == false and Wep == 3 then
					change = 1
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.1 * math.cos(sine / 25)) * angles(math.rad(0), math.rad(0), math.rad(5)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5 - 2 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5 - 0 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(0 - 0 * math.cos(sine / 25)), math.rad(5 + 3 * math.cos(sine / 25))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0 + 0 * math.cos(sine / 25)), math.rad(-0), math.rad(-5 - 3 * math.cos(sine / 25))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.1 * math.cos(sine / 25), 0) * RHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.1 * math.cos(sine / 25), 0) * LHCF * angles(math.rad(-2 + 1 * math.cos(sine / 25)), math.rad(-5), math.rad(0 + 2 * math.cos(sine / 25))), .1)
				end
			elseif Torsovelocity > 2 and hit ~= nil then
				Anim = "Walk"
				if attack == false and Wep == 3 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.05 + .1 * math.cos(sine / 3)) * angles(math.rad(5), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(5 * math.cos(sine / 5))), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-5 * math.cos(sine / 5)) + RootPart.RotVelocity.Y / 9), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 - -0 * math.cos(sine / 4), 0.5 - -.05 * math.cos(sine / 4), 0) * angles(math.rad(10 + -50 * math.cos(sine / 4)), math.rad(0 - .1 * math.cos(sine / 25)), math.rad(5 + 3 * math.cos(sine / 25))), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5 - -0 * math.cos(sine / 4), 0.5 - -.05 * math.cos(sine / 4), 0) * angles(math.rad(10 + 50 * math.cos(sine / 4)), math.rad(-0), math.rad(-5 - 3 * math.cos(sine / 25))), 0.3)
					RH.C0 = clerp(RH.C0, cn(1, -.9 + -.1 * math.cos(sine / 4),0 + -.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 + .1 * math.cos(sine / 4), 0 + .1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(50 * math.cos(sine / 4))), .3)
				end
			end
		end	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		if #Effects > 0 then
			for e = 1, #Effects do
				if Effects[e] ~= nil then
					local Thing = Effects[e]
					if Thing ~= nil then
						local Part = Thing[1]
						local Mode = Thing[2]
						local Delay = Thing[3]
						local IncX = Thing[4]
						local IncY = Thing[5]
						local IncZ = Thing[6]
						if Thing[1].Transparency <= 1 then
							if Thing[2] == "Block1" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block2" then
								Thing[1].CFrame = Thing[1].CFrame
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Cylinder" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Blood" then
								local Mesh = Thing[7]
								Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, .5, 0)
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Elec" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Disappear" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Shatter" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
								Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
								Thing[6] = Thing[6] + Thing[5]
							end
						else
							Part.Parent = nil
							table.remove(Effects, e)
						end
					end
				end
			end
		end
	end
	
end)

Section:NewButton("Frost Giant", "ButtonInfo", function()
    print("Clicked")
local lp = game:GetService("Players").LocalPlayer

local c = lp.Character
local targetnnn
local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function Destroy_Mesh(hat)
	print(hat)
	local hat1 = hat.Handle:FindFirstChildOfClass("SpecialMesh") or hat.Handle:FindFirstChildOfClass("Mesh")
	if hat1 then
		hat1:Destroy()
		print("Destroy")
	end
	print("Not Destroy")
end
local hat1n = gp(c, "PaperBagRanger", "Accessory")
Destroy_Mesh(hat1n)

local hat2n = gp(c, "DreamCap", "Accessory")
Destroy_Mesh(hat2n)

local hat3n = gp(c, "PanicCap", "Accessory")
Destroy_Mesh(hat3n)

local hat4n = gp(c, "gradcap_18", "Accessory")
Destroy_Mesh(hat4n)

local hat5n = gp(c, "Scarlett", "Accessory")
Destroy_Mesh(hat5n)

local hat6n = gp(c, "Cyber Peacock Tail 2.0", "Accessory")
Destroy_Mesh(hat6n)

local hat7n = gp(c, "VANS_Umbrella", "Accessory")
Destroy_Mesh(hat7n)

local hat8n = gp(c, "MeshPartAccessory", "Accessory")
Destroy_Mesh(hat8n)

local hat9n = gp(c, "ShavedIce", "Accessory")
Destroy_Mesh(hat9n)

local hat10n = gp(c, "Nike Shoebox Costume", "Accessory")
Destroy_Mesh(hat10n)

wait(0.2)
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))() 

wait(.1)

script = game:GetObjects("rbxassetid://5759990161")[1].Algor
--require(script.EzConvert)()
	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
-- converter by Drahazar

--created by helkern
--some things might be taken from other scripts

--[[
Algor, The Frozen Titan
Started 2020/1/27
]]

wait(1/60)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Character)
RootPart.CFrame = CFrame.new(0,40,0)
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))

local neck2 = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
ANIMATOR:Destroy()
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function Clerp(a, b, t)
    return a:lerp(b,t)
end



function weld(parent, part0, part1, c0, c1)
	local w = IT("Weld")
	w.Part0 = part0
	w.Part1 = part1
	w.C0 = c0
	w.C1 = c1
	w.Parent = parent
	return w
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end


function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						--local CAMSHAKER = script.CamShake:Clone()
						--CAMSHAKER.Shake.Value = INTENSITY
						--CAMSHAKER.Timer.Value = TIME
						--CAMSHAKER.Parent = CHILD
						--CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

function debree(col,mat,transp,pos,amnt,size,cleartime,power)
		for i = 1, amnt do
			local db = CreatePart(3, Effects, mat, 0, transp, "Peal", "Debree", size, false)
			db.Color = col
			db.CFrame = pos * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			db.Velocity = VT(MRANDOM(-power,power),MRANDOM(-power,power),MRANDOM(-power,power))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				db.Parent = workspace
				db.CanCollide = true
				Debris:AddItem(db,cleartime)
			end))
		end
end


function AttachmentCFrame(What)
	return What.Parent.CFrame*CF(What.Position)
end


--weap
--Humanoid.Parent = nil
local siz = 2
--15
local NECKC0 = CF(0, 1*(siz*1.5), 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
LeftArm.Size = LeftArm.Size*siz
RightArm.Size = RightArm.Size*siz
Torso.Size = Torso.Size*siz
RootPart.Size = RootPart.Size*siz
RightLeg.Size = RightLeg.Size*siz
LeftLeg.Size = LeftLeg.Size*siz
Head.Size = Head.Size*siz

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new


local hat2 = gp(cplayer, "Cyber Peacock Tail 2.0", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = Character.Torso
att2.Position = v3(0,0,0)
att2.Rotation = v3(90, 0, 0)

local hat3 = gp(cplayer, "Scarlett", "Accessory")
local handle3 = gp(hat3, "Handle", "BasePart")
local att3 = gp(handle3, "att1_Handle", "Attachment")
att3.Parent = Character["Right Arm"]
att3.Position = v3(0,0,0)
att3.Rotation = v3(0, 0, 0)


local handle4 = gp(gp(cplayer, "gradcap_18", "Accessory"), "Handle", "BasePart")
local att4 = gp(handle4, "att1_Handle", "Attachment")
att4.Parent = Character["Left Arm"]
att4.Position = v3(0,0,0)
att4.Rotation = v3(0, 0, 0)


local handle5 = gp(gp(cplayer, "PanicCap", "Accessory"), "Handle", "BasePart")
local att5 = gp(handle5, "att1_Handle", "Attachment")
att5.Parent = Character["Right Leg"]
att5.Position = v3(0,0,0)
att5.Rotation = v3(0, 90, 0)


local handle6 = gp(gp(cplayer, "DreamCap", "Accessory"), "Handle", "BasePart")
local att6 = gp(handle6, "att1_Handle", "Attachment")
att6.Parent = Character["Left Leg"]
att6.Position = v3(0,0,0)
att6.Rotation = v3(0, 90, 0)

local handle7= gp(gp(cplayer, "PaperBagRanger", "Accessory"), "Handle", "BasePart")
local att7 = gp(handle7, "att1_Handle", "Attachment")
att7.Parent = Character["Head"]
att7.Position = v3(0,-0.5,0)
att7.Rotation = v3(0, 0, 0)


local handle8= gp(gp(cplayer, "MeshPartAccessory", "Accessory"), "Handle", "BasePart")
local att8 = gp(handle8, "att1_Handle", "Attachment")

local handle9 = gp(gp(cplayer, "ShavedIce", "Accessory"), "Handle", "BasePart")
local att9 = gp(handle9, "att1_Handle", "Attachment")

att9.Parent = gp(gp(cplayer.Model, "MeshPartAccessory", "Accessory"), "Handle", "BasePart")

local handle10 = gp(gp(cplayer, "VANS_Umbrella", "Accessory"), "Handle", "BasePart")
local att10 = gp(handle10, "att1_Handle", "Attachment")

local handle11 = gp(gp(cplayer, "Nike Shoebox Costume", "Accessory"), "Handle", "BasePart")
local att11 = gp(handle11, "att1_Handle", "Attachment")
att11.Rotation = Vector3.new(-0, 0, -90)
att11.Position = Vector3.new(0, 3, 0)

tcnn=Instance.new('Part')
tcnn.CFrame=handle8.CFrame*CFrame.new(0,-2,0)
tcnn.Anchored=true
tcnn.Transparency=1
tcnn.Name='Anchor'
tcnn.CanCollide=false
tcnn.Parent=Character

att8.Parent = tcnn
att10.Parent = tcnn
att11.Parent = tcnn

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if ATTACK == false then


	elseif ATTACK  == true then


			if targetnnn ~= nil then
				GlobalFunctions.fling(targetnnn)
				wait(0.1)
				targetnnn = nil
			end
		end
	end
end)

--att8.Parent = PartHats

local SONG = 3890747311
d = CF(0,0,0)
local la = IT("Weld")
local ra = IT("Weld")
RightShoulder.Parent = nil
LeftShoulder.Parent = nil
ra.Name = "ra"
ra.Part0 = Torso 
ra.C0 = CF(1.5*siz, 0.5*siz, 0)
ra.C1 = CF(0, 0.5*siz, 0)
ra.Part1 = RightArm
ra.Parent = Torso  

la.Name = "la"
la.Part0 = Torso 
la.C0 = CF(-1.5*siz, 0.5*siz, 0*siz)
la.C1 = CF(0*siz, 0.5*siz, 0*siz) 
la.Part1 = LeftArm
la.Parent = Torso

local lh = weld(LeftLeg,Torso,LeftLeg,CF(-.5*siz,-1*siz,0*siz),d)
lh.C1 = CF(0,1*siz,0)
local rh = weld(RightLeg,Torso,RightLeg,CF(.5*siz,-1*siz,0*siz),d)
rh.C1 = CF(0,1*siz,0)
--Humanoid.Parent = Character
local booz = script.booz
local la2 = weld(LeftArm,booz.la,LeftArm,d,d)
local ra2 = weld(RightArm,booz.ra,RightArm,d,d)
local tor = weld(Torso,booz.tors,Torso,d,d)
local ll = weld(LeftLeg,booz.ll,LeftLeg,CF(0,0,0)*ANGLES(0,RAD(0),0),d)
local rl = weld(RightLeg,booz.rl,RightLeg,CF(0,0,0)*ANGLES(0,RAD(0),0),d)
local hw = weld(Head,booz.hed,Head,d,d)
booz.Parent = Character
for _,v in pairs(booz:GetChildren()) do
	if  v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
		print(v)

	end
end
--Player:ClearCharacterAppearance()
for t,u in pairs(booz:GetDescendants()) do if u:IsA("BasePart") then u.Anchored = false u.Transparency = 1  end end
for h,j in pairs(Character:GetChildren()) do if j:IsA("Part") then j.Transparency=1 end end
if Head:FindFirstChild("face") then Head.face.Transparency=1 end
local spike = script.spike
--spike.Size = spike.Size/7.5
spike.Size = spike.Size/7.5
spike.Parent = nil
local icecol = Color3.fromRGB(116, 138, 165)



function refit()
	
end

function Parents()

end



--dmg
function ApplyDamage(Humanoid,Damage)
	Damage = Damage
	if Humanoid.Health < 2000 then
		if Humanoid.Health - Damage > 0 then
			targetnnn = Humanoid.Parent
			--Humanoid.Health = Humanoid.Health - Damage
		else
			targetnnn = Humanoid.Parent
			--Humanoid.Parent:BreakJoints()
		end
	else
		targetnnn = Humanoid.Parent
		--Humanoid.Parent:BreakJoints()
	end
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							--CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--attacks
function cs()
	if SONG == 3890747311 then
	SONG = 184896130
	elseif SONG == 184896130 then
	SONG = 1842946718
	elseif SONG == 1842946718 then
	SONG = 4368744074
	elseif SONG == 4368744074 then
	SONG = 2830978698
	elseif SONG == 2830978698 then
	SONG = 144121562
	elseif SONG == 144121562 then
	SONG = 3890747311					
	end
end

	
function iceblock()
	ATTACK = true
	for i = 0,30 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(25.8),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.5*siz,0.1*siz)*ANGLES(RAD(1.6),RAD(7.5),RAD(-4.7)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5*siz,0.6*siz,0.1*siz)*ANGLES(RAD(-177.1),RAD(-1.3),RAD(3.8)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-25.8),RAD(0))*NECKC0,Alpha)
	end
	local attpart = CreatePart(3,Effects,"Plastic",0,1,"White","STUPID WELDING",VT(.1,.1,.1),false)
	attpart.CFrame = RightArm.CFrame*CF(0,-2*(siz)/1.5,0)
	weldBetween(attpart,RightArm)
	local boozc = CreatePart(3,attpart,"Ice",0,0,"White","booz",VT(20,20,20),true) boozc.Color = icecol boozc.CanCollide = false
	boozc.Size = boozc.Size/7.5
	att8.Parent = boozc
	CreateSound(243711369,boozc,10,1,false)
	--boozc.CFrame = boozc.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
	local www = weld(boozc,boozc,attpart,CF(0,0,0)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))	,d)
	boozc.Anchored = false
	spike.cold:Clone().Parent = boozc
	WACKYEFFECT2({Time = 50, EffectType = "Box", Size = boozc.Size, Size2 = boozc.Size*1.45, Transparency = 0, Transparency2 = 1, CFrame = boozc.CFrame, MoveToPos = nil, RotationX = MRANDOM(-15,15), RotationY = MRANDOM(-15,15), RotationZ = MRANDOM(-15,15), Material = "Neon", Color = boozc.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = boozc.Size, Size2 = boozc.Size*2.45, Transparency = 0, Transparency2 = 1, CFrame = boozc.CFrame, MoveToPos = nil, RotationX = MRANDOM(-15,15), RotationY = MRANDOM(-15,15), RotationZ = MRANDOM(-15,15), Material = "Neon", Color = boozc.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	for i = 1,4 do
	WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.01,.01,.01)*4, Size2 = VT(.3,.03,.3)*1.5, Transparency = 0, Transparency2 = 1, CFrame = boozc.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-5,5), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 3})
	end
	local thr = false
	local sp  = 0
	for i = 0,10 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(25.8),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.5*siz,0.1*siz)*ANGLES(RAD(1.6),RAD(7.5),RAD(-4.7)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5*siz,0.8*siz,0.1*siz)*ANGLES(RAD(-173.7),RAD(13.4),RAD(16.2)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-25.8),RAD(0))*NECKC0,Alpha)
	end
	swait(.1)
	for i = 0,25 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0.1*siz,0.2*siz)*ANGLES(RAD(12.5),RAD(25.8),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(-10.2),RAD(7.4),RAD(-8.7)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1.1*siz,0*siz)*ANGLES(RAD(-11.5),RAD(-7),RAD(-1.7)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.5*siz,0.1*siz)*ANGLES(RAD(1.6),RAD(7.5),RAD(-4.7)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4*siz,0.8*siz,0.3*siz)*ANGLES(RAD(-146),RAD(9.2),RAD(4.6)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-25.8),RAD(0))*NECKC0,Alpha)
	end
	for i = 0,5 do   	ra.C0 = ra.C0:lerp(CF(1.2*siz,0.2*siz,-0.6*siz)*ANGLES(RAD(140.8),RAD(-50.3),RAD(71.8)),.5) end
	attpart:BreakJoints()
	boozc.Parent = Effects
	attpart:Destroy()
	boozc.Anchored = true
	thr = true
	local ogp = boozc.Position
	local hpp,ppp = CastProperRay(boozc.Position,  Mouse.Hit.p, 500, Character)
	boozc.Position = ppp
	local dist = (ppp-boozc.Position).Magnitude
	
	
	--boozc.CFrame = CF(boozc.Position,Mouse.Hit.p)
	ApplyAoE(ppp,10,90,100,200,false)
	--ApplyAoE(ppp,60,90,100,200,false)
	--debree(boozc.Color,boozc.Material,0,CF(ppp)*CF(0,10,0),MRANDOM(12,15),VT(MRANDOM(4,7),MRANDOM(4,7),MRANDOM(4,7)),7,135)
	WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1,1,1), Size2 = boozc.Size*5.2, Transparency = 0, Transparency2 = 1, CFrame = CF(ppp), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = boozc.Color,SoundID = 87015121, SoundPitch = 1, SoundVolume = 10, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 10})
	for i = 1,5 do
	WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.01,.01,.01), Size2 = VT(.35,.03,.35)*1.5, Transparency = 0, Transparency2 = 1, CFrame = CF(ppp)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-6,6), RotationZ = 0, Material = "Neon", Color = boozc.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 5})
	end
	--for i = 1,2 do
	WACKYEFFECT2({Time = 60, EffectType = "Box", Size = boozc.Size, Size2 = boozc.Size*1.4, Transparency = 0, Transparency2 = 1, CFrame = CF(ppp), MoveToPos = ppp+VT(0,20,0), RotationX = MRANDOM(-15,15)/15, RotationY = MRANDOM(-15,15)/15, RotationZ = MRANDOM(-15,15)/15, Material = boozc.Material, Color = boozc.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 15, SizeBoomerang = 0})	
	--end
	WACKYEFFECT2({Time = 30, EffectType = "Box", Size = VT(5,5,dist), Size2 = VT(10,10,dist), Transparency = 0, Transparency2 = 1, CFrame = CF(ogp,ppp)*CF(0,0,-dist/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = boozc.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	wait(0.5)
	att8.Parent = tcnn
	boozc:Destroy()
	for i = 0,15 do
		Swait()
		  	local Alpha = .23
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0.1*siz,-0.1*siz)*ANGLES(RAD(-8.4),RAD(25.8),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.4*siz,-1.1*siz,-0.2*siz)*ANGLES(RAD(7.5),RAD(7.2),RAD(0.4)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.6*siz,-1.1*siz,-0.2*siz)*ANGLES(RAD(8.5),RAD(-7.2),RAD(7.4)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.5*siz,0.1*siz)*ANGLES(RAD(1.6),RAD(7.5),RAD(-4.7)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(0.5*siz,0.2*siz,-1*siz)*ANGLES(RAD(-1.1),RAD(-41.2),RAD(-60.9)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-25.8),RAD(0))*NECKC0,Alpha)
	end
	ATTACK = false
end
	
function stomp()
	ATTACK = true
	for i = 0,35 do
		Swait()
	  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0.3*siz)*ANGLES(RAD(9.9),RAD(3.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1.1*siz,-0.2*siz)*ANGLES(RAD(-9.4),RAD(7),RAD(-3.9)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.6*siz,0*siz,-.5*siz)*ANGLES(RAD(-9.5),RAD(-7.5),RAD(3.1)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.5*siz,0.1*siz)*ANGLES(RAD(-8.6),RAD(7.6),RAD(-3.2)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5*siz,0.5*siz,0.1*siz)*ANGLES(RAD(-13.2),RAD(-8.5),RAD(3.1)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0.1*siz)*ANGLES(RAD(-5.9),RAD(-3.6),RAD(-0.4))*NECKC0,Alpha)	
	end
	for i = 1,3 do
	WACKYEFFECT2({Time = 50, EffectType = "Wave", Size = VT(1,1,1), Size2 = VT(80-i*15,1,80-i*15)*2, Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(.6*siz,-2.9*siz,-.5), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-2,2), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	CreateSound(192410084,RightLeg,8,MRANDOM(9,10)/10,false)
	ApplyAoE(RightLeg.CFrame*CF(.6*siz,-2.9*siz,-.5*siz).p,40,70,90,150,false)
	for i = 0,25 do
		Swait()
		  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0.2*siz)*ANGLES(RAD(-9.4),RAD(3.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.3*siz)*ANGLES(RAD(9.7),RAD(7),RAD(-2.7)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.9*siz)*ANGLES(RAD(9.9),RAD(-7.5),RAD(4.4)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.4*siz,0.2*siz)*ANGLES(RAD(-20.8),RAD(7.8),RAD(-3.9)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4*siz,0.4*siz,0.2*siz)*ANGLES(RAD(-25.5),RAD(-8.3),RAD(2.4)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0.1*siz)*ANGLES(RAD(-5.9),RAD(-3.6),RAD(-0.4))*NECKC0,Alpha)
	end
	ATTACK = false
end

function spikesfront()
	for i = 0,20 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(3.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.5*siz,0.1*siz)*ANGLES(RAD(0.3),RAD(7.5),RAD(-2.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(0.9*siz,0.3*siz,-0.9*siz)*ANGLES(RAD(0.6),RAD(-8.6),RAD(-90.8)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-3.7),RAD(0))*NECKC0,Alpha)
	end
	local currentspikes = {}
	local val = 0
	local strp = RootPart.CFrame
	coroutine.resume(coroutine.create(function()
	for i = 1,120 do
	Swait()
	local cspike = spike:Clone()
	table.insert(currentspikes,cspike)
	cspike.Parent = Effects
	cspike.Orientation = VT(0,0,0)
	cspike.CFrame = strp*CF(MRANDOM(-i/2,i/2),-2.9*siz,-i*1.65)*ANGLES(RAD(MRANDOM(-5,5)),0,RAD(MRANDOM(-30,30)))
	cspike.Size = cspike.Size*(i/40)
	WACKYEFFECT2({Time = 20, EffectType = "Sphere", Size = cspike.Size, Size2 = cspike.Size*1.5, Transparency = 0, Transparency2 = 1, CFrame = cspike.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = cspike.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	val=val+1 if val>=2 then val=0 end
	if val==1 then
	CreateSound(338594606,cspike,6.5,1,false)
	ApplyAoE(cspike.Position,1+i/4,10+i/2,20+i/2,40+i*2,false)	
	WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1+i,1,1+i/4), Size2 = VT(1+(i*1.5),1,1+i/4), Transparency = 0, Transparency2 = 1, CFrame = strp*CF(0,-2.9*siz,-i*1.65), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = icecol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	end
	swait(.5)
	for _,kerwan in pairs(currentspikes) do
	Swait()
	coroutine.resume(coroutine.create(function()
	for i = 1,20 do Swait()
	kerwan.CFrame = kerwan.CFrame:lerp(kerwan.CFrame*CF(0,-50,0),.05)
	end
	kerwan:Destroy()
	end))
	end	
	end))
	for i = 0,15 do
		Swait()
		  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0.1*siz)*ANGLES(RAD(0),RAD(-35.8),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(1.6),RAD(25.7),RAD(-3.6)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.3*siz,0.5*siz,0.1*siz)*ANGLES(RAD(3.4),RAD(15.7),RAD(-20.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.4*siz,0*siz)*ANGLES(RAD(1.9),RAD(-33.3),RAD(93)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(35.8),RAD(0))*NECKC0,Alpha)
	end
end

function spikefrombelow()
	ATTACK = true
	for i = 0,20 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0.1*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-27.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(1.4),RAD(23.5),RAD(-3.5)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.4*siz,0.1*siz)*ANGLES(RAD(40),RAD(4.1),RAD(-21.9)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.5*siz,0.2*siz)*ANGLES(RAD(6.4),RAD(-27.4),RAD(17.5)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(33.3),RAD(0))*NECKC0,Alpha)
	end
	local spkes = {}
	for i = 1,2 do
	local spke = spike:Clone()
	spke.Parent = Effects
	table.insert(spkes,spke)
	spke.Orientation = VT(0,0,0)
	CreateSound(338594687,spke,7,1,false)
	spke.CFrame = Mouse.Hit*CF(MRANDOM(-10,10)/2,0,MRANDOM(-10,10)/2)*ANGLES(RAD(MRANDOM(-20,20)/2),0,RAD(MRANDOM(-20,20)/2))
	spke.Size = spke.Size*MRANDOM(2,4)--VT(spke.Size.X-MRANDOM(5,7)/10,spke.Size.Y+i,spke.Size.Z+MRANDOM(5,7)/10)
	WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = spke.Size*1.6, Size2 = spke.Size*.3, Transparency = 0, Transparency2 = 1, CFrame = spke.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = spke.Color,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})	
	end
	print(spkes[1].Parent)
	att10.Parent = spkes[1]
	att11.Parent = spkes[1]
	
	coroutine.resume(coroutine.create(function()
	swait(1)
	for _,bruh in pairs(spkes) do
		ApplyAoE(bruh.Position,25,60,80,175,false)
		--CreateSound(,bruh,10,1,false)
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = bruh.Size, Size2 = bruh.Size*2, Transparency = 0, Transparency2 = 1, CFrame = bruh.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = bruh.Color,SoundID = 87015121, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

		--debree(bruh.Color,bruh.Material,0,bruh.CFrame,4,VT(MRANDOM(7,12),MRANDOM(7,12),MRANDOM(7,12))/2,5,100)
		
		
		end	
		att10.Parent = tcnn
		att11.Parent = tcnn
		wait(0.2)
		for _,bruh in pairs(spkes) do
			bruh:Destroy()
		end
	end))
	for i = 0,15 do
		Swait()
			local Alpha = .23
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0.1*siz,0*siz,0.4*siz)*ANGLES(RAD(10.4),RAD(-27.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.6*siz,-1*siz,-0.2*siz)*ANGLES(RAD(-9.8),RAD(23.1),RAD(1.6)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.4*siz,-0.9*siz,-0.2*siz)*ANGLES(RAD(-8.1),RAD(-7.8),RAD(8.5)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.6*siz,-0.6*siz)*ANGLES(RAD(129),RAD(-21.9),RAD(-4.2)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.5*siz,0.2*siz)*ANGLES(RAD(6.4),RAD(-27.4),RAD(17.5)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(-0.1*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(33.3),RAD(0))*NECKC0,Alpha)
	end
	ATTACK = false
end

function icytp()
	ATTACK = true
	for i = 0,15 do
		Swait()
	  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(3.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.4),RAD(7),RAD(-3.3)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0.5),RAD(-7.5),RAD(3.8)),Alpha)
  	la.C0 = la.C0:lerp(CF(-0.7*siz,0.4*siz,-0.7*siz)*ANGLES(RAD(-6.3),RAD(2.5),RAD(85.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(0.7*siz,0.2*siz,-0.4*siz)*ANGLES(RAD(-13.5),RAD(-11.1),RAD(-87.9)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-3.7),RAD(0))*NECKC0,Alpha)
	end
	
	local hf,hp = Raycast(Mouse.Hit.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 100, Character)
	if hf then
			for j,g in pairs(Character:GetChildren()) do
	if g:IsA("BasePart") then
	local gsiz
	if g.Name == "Head" then gsiz = VT(g.Size.Z,g.Size.Y,g.Size.Z) else gsiz = g.Size end
	WACKYEFFECT2({Time = 70, EffectType = "Box", Size = gsiz, Size2 = gsiz, Transparency = 0, Transparency2 = 1, CFrame = g.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Ice", Color = icecol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end	
	end
	hp = hp + VT(0,3.5,0)
	local po = RootPart.Position
	RootPart.CFrame = CF(hp,CF(po,hp)*CF(0,0,-100000).p)
	CreateSound(338594524,RootPart,10,.65,false)	
	for t,h in pairs(Character:GetChildren()) do
	if h:IsA("BasePart") then
	local hsiz
	if h.Name == "Head" then hsiz = VT(h.Size.Z,h.Size.Y,h.Size.Z) else hsiz = h.Size end
	WACKYEFFECT2({Time = 70, EffectType = "Box", Size = hsiz, Size2 = hsiz*2, Transparency = 0, Transparency2 = 1, CFrame = h.CFrame, MoveToPos = h.Position+VT(0,30,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = icecol,SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end	
	end		
	end
	ATTACK = false
end

local vibing = false

function FUNKYDANCEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE()
	--use 3012615169
	ATTACK = true
		vibing = true
	local oldid = SONG
	RootPart.Anchored = true
	local oldtimepos = sick.TimePosition
	SONG = 1125637044
	sick.TimePosition = 0
	repeat
	for i = 0,30 do
		Swait()
		  	local Alpha = .1
			if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,-0.2*siz)*ANGLES(RAD(0),RAD(31.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0),RAD(7.5),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,-0.1*siz)*ANGLES(RAD(0),RAD(-23.6),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.6*siz,0*siz)*ANGLES(RAD(0),RAD(0),RAD(-9.7)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5*siz,0.5*siz,-0.2*siz)*ANGLES(RAD(141.7),RAD(26),RAD(5.6)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0.1*siz,0*siz,-0.1*siz)*ANGLES(RAD(2.2),RAD(-31.7),RAD(1.2))*NECKC0,Alpha)
	end
	for i = 0,MRANDOM(45,55) do
		Swait()
		  	local Alpha = .1
			if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-11.4),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(20.6),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(-2),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.6*siz,1*siz,-0.2*siz)*ANGLES(RAD(151.8),RAD(44.8),RAD(43.3)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.1*siz,0.3*siz,-0.7*siz)*ANGLES(RAD(0),RAD(-9.9),RAD(-88.2)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(31.2),RAD(0))*NECKC0,Alpha)
	end
	for i = 0,MRANDOM(45,55) do
		Swait()
		  	local Alpha = .1
			if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1*siz,0*siz,-0.1*siz)*ANGLES(RAD(0),RAD(17.3),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(25.3),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(-9.2),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4*siz,0.5*siz,0.3*siz)*ANGLES(RAD(0),RAD(15.4),RAD(0)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.6*siz,0.1*siz)*ANGLES(RAD(123.8),RAD(12),RAD(16.5)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0.2*siz,0*siz,-0.2*siz)*ANGLES(RAD(14.9),RAD(-16.7),RAD(4.4))*NECKC0,Alpha)
	end
	for i = 0,MRANDOM(45,55) do
		Swait()
		  	local Alpha = .1
			if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.2*siz,0*siz,0.5*siz)*ANGLES(RAD(-7.2),RAD(47.1),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5*siz,-1.1*siz,-0.3*siz)*ANGLES(RAD(-160.5),RAD(70),RAD(164.5)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.6*siz,-1*siz,-0.3*siz)*ANGLES(RAD(9),RAD(-38.2),RAD(6.7)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5*siz,0.5*siz,0*siz)*ANGLES(RAD(0),RAD(11),RAD(-4.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.5*siz,-0.1*siz)*ANGLES(RAD(99.4),RAD(6.7),RAD(40)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0.1*siz,0*siz,-0.1*siz)*ANGLES(RAD(9.3),RAD(-48.7),RAD(7))*NECKC0,Alpha)
	end
	for i = 0,MRANDOM(45,55) do
		Swait()
  	local Alpha = .1
	if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(-19),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.6*siz,-0.9*siz,-0.5*siz)*ANGLES(RAD(-0.3),RAD(13.8),RAD(-2.7)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(-17.7),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.1*siz,0.7*siz,0.5*siz)*ANGLES(RAD(0),RAD(0),RAD(131.1)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1*siz,0.4*siz,-0.8*siz)*ANGLES(RAD(-9),RAD(-1.8),RAD(-78.5)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0*siz,0*siz,0*siz)*ANGLES(RAD(0),RAD(19),RAD(0))*NECKC0,Alpha)
	end
	for i = 0,MRANDOM(45,55) do
		Swait()
		  	local Alpha = .1
			if vibing == false then break end
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0.1*siz,0*siz,-0.2*siz)*ANGLES(RAD(0),RAD(-68.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.8*siz,-1*siz,-0.3*siz)*ANGLES(RAD(-12.2),RAD(17.2),RAD(6.6)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.4*siz,-1*siz,0*siz)*ANGLES(RAD(0),RAD(-5.2),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.2*siz,0.4*siz,-0.8*siz)*ANGLES(RAD(86.2),RAD(-2.4),RAD(67.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.3*siz,0.5*siz,0.2*siz)*ANGLES(RAD(5.8),RAD(-28.6),RAD(14.4)),Alpha)
  	Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0.3*siz,0*siz,0.1*siz)*ANGLES(RAD(-18),RAD(65.9),RAD(16.6))*NECKC0,Alpha)
	end
	until vibing == false
	SONG = oldid
	ATTACK= false
	RootPart.Anchored = false
	sick.TimePosition = oldtimepos
end




--keys
function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		stomp()
	end
	if Key == "x" and ATTACK == false then
		iceblock()
	end

	if Key == "c" and ATTACK == false then
		spikesfront()
	end

	if Key == "v" and ATTACK == false then
		spikefrombelow()
	end

	if Key == "b" and ATTACK == false then
		icytp()
	end
	
	if Key=="n" and ATTACK == false and vibing == false then
	
		FUNKYDANCEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE()
	elseif Key=="n" and ATTACK == true and vibing == true then
		vibing = false
	end
	
	if Key=="m" then cs() end

	if Key == "]" and ATTACK == false then
		if sick.Parent ~= Character and sick.Parent ~= Character.Model then
			sick = IT("Sound",Character)
			sick.SoundId = "rbxassetid://"..SONG
		end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart and c ~= tcnn then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--loop stuff

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

while true do
	Swait()
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*siz, Character)
	local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
	local WALKSPEEDVALUE = 18 / (Humanoid.WalkSpeed / 16)
	refit() Parents() Humanoid.PlatformStand = false Humanoid:SetStateEnabled("Dead",false)Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)Humanoid:SetStateEnabled("GettingUp",true)Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)Humanoid:SetStateEnabled("Ragdoll",false) Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5*siz, 0.5*siz, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5*siz, 0.5*siz, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5*siz, -0.4*siz, -0.6*siz) * ANGLES(RAD(1), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5*siz, -1*siz, 0*siz) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)*siz) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5*siz, 0.5*siz, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5*siz, 0.5*siz, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5*siz, -0.3*siz, -0.7*siz) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5*siz, -0.8*siz, -0.3*siz) * ANGLES(RAD(-10), RAD(10), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		local Alpha = .1
		ANIM = "Idle"
		if ATTACK == false then
  		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0*siz,0*siz+0.18*COS(SINE/40),0*siz)*ANGLES(RAD(-5.8+1*SIN(SINE/40)),RAD(27),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.4*siz,-1*siz-0.18*COS(SINE/40),-0.1*siz)*ANGLES(RAD(5.3-1*SIN(SINE/40)),RAD(7.1),RAD(-0.6)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.6*siz,-1*siz-0.18*COS(SINE/40),-0.1*siz)*ANGLES(RAD(6.5-1*SIN(SINE/40)),RAD(-17.1),RAD(6.6)),Alpha)
  		la.C0 = la.C0:lerp(CF(-1.5*siz,0.5*siz+.07*SIN(SINE/40),0.1*siz)*ANGLES(RAD(0.3),RAD(7.5-3*COS(SINE/40)),RAD(-2.6-2.85*COS(SINE/40))),Alpha)
  		ra.C0 = ra.C0:lerp(CF(1.5*siz,0.5*siz+.07*SIN(SINE/40),0.1*siz)*ANGLES(RAD(0.6),RAD(-8.6+3*COS(SINE/40)),RAD(4+2.85*COS(SINE/40))),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0*siz,0*siz,0*siz+ ((1) - 1))*ANGLES(RAD(-3*SIN(SINE/40)),RAD(0+2*COS(SINE/80)),RAD(-27)),Alpha)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,-.05+0.04*siz*SIN(SINE/WALKSPEEDVALUE*2),0*siz-.10*COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-2+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.Z)*.7,RAD(10*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.5*siz,-.9*siz+0.95*COS(SINE/WALKSPEEDVALUE)/2,-.1*siz-.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+15*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/-75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-15*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+5*SIN(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.5*siz,-.9*siz-0.95*COS(SINE/WALKSPEEDVALUE)/2,-.1*siz+.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-15*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-15*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+5*SIN(SINE/WALKSPEEDVALUE)*-RAD(TiltVelocity.X)*5.5)),Alpha)
  		la.C0 = la.C0:lerp(CF(-1.5*siz,0.5*siz,0)*ANGLES(RAD(-14*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		ra.C0 = ra.C0:lerp(CF(1.5*siz,0.5*siz,0)*ANGLES(RAD(14*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0)*ANGLES(RAD(0+3.5*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(-10*COS(SINE/WALKSPEEDVALUE))-RAD(TiltVelocity.X)*3),Alpha)
		end
	end
	unanchor()
	Humanoid.MaxHealth = 1e4
	Humanoid.Health = 1e4
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 3
	sick.Playing = true
end
end)

Section:NewButton("Master Hand", "Extra Hand for ya", function()
    print("Clicked")


GlobalFunctions = {}
getgenv().HatCollide = false
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
-- -gh 4794315940,48474313,63690008,1103003368,48474294,62234425,451220849,62724852,376524487,3822880197

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

wait(7)

local HatChar = game.Players.LocalPlayer.Character.Model

-- Mesh Remover that probally doesnt work
function removeMesh(hat)
    for i,v in pairs(hat:GetChildren()) do
        if v:IsA("Mesh") or v:IsA("SpecialMesh") then
            v:Destroy()
            print(v)
        end
    end
end


plr = game.Players.LocalPlayer
char=game.Players.LocalPlayer.Character
ct={}
te=table.insert
reanim = char
vargun = false
HumanDied=false
mwouse = plr:GetMouse()


wt = 0.05 s = script it = Instance.new v3 = Vector3.new c3 = Color3.new ud = UDim2.new cf = CFrame.new ca = CFrame.Angles pi = math.pi rd = math.rad
bc = BrickColor.new ab = math.abs de = math.deg ts = tostring tn = tonumber ti = table.insert tr = table.remove  
cr = coroutine.resume cc = coroutine.create
asset = "http://www.roblox.com/asset/?id="
sr = string.reverse sl = string.lower su = string.upper 
Serv = {} Serv.p = game:GetService(sr("sreyalP")) Serv.l = game:GetService(sr("gnithgiL")) 
Serv.is = game:GetService(sr("ecivreStresnI")) if game:findFirstChild(sr("revreSkrowteN")) then Serv.ns = game:GetService(sr("revreSkrowteN")) else NetworkServer = nil end 
Serv.sg = game:GetService(sr("iuGretratS")) Serv.sp = game:GetService(sr("kcaPretratS")) Serv.d = game:GetService(sr("sirbeD"))
Decs = {}
Decs.Crack = "49173398" Decs.Cloud = "1095708" Decs.Spike = "1033714" Decs.Rock = "1290033" Decs.Crown = "1323306"
function ft(tablez,item) if not tablez or not item then return nil end for i=1,#tablez do if tablez[i] == item then return i end end return nil end
function re(par,obj) if type(par) ~= "userdata" or type(obj) ~= "string" then return nil end if par:findFirstChild(obj) then par[obj]:Remove() end end 
function pa(pa,sh,x,y,z,c,a,tr,re,bc2) local fp = nil if sh ~= "Wedge" and sh ~= "CornerWedge" then  fp = it("Part",pa) fp.Shape = sh  fp.formFactor = "Custom" elseif sh == "Wedge" then fp = it("WedgePart",pa)  fp.formFactor = "Custom"
elseif sh == "CornerWedge" then fp = it("CornerWedgePart",pa)  end  fp.Size = v3(x,y,z) fp.CanCollide = c fp.Anchored = false fp.BrickColor = bc(bc2) fp.Transparency = tr fp.Reflectance = re fp.BottomSurface = 0
fp.TopSurface = 0 fp.CFrame = t.CFrame + Vector3.new(0,50,0) fp.Velocity = Vector3.new(0,10,0) fp:BreakJoints() return fp  end 
function clearit(tab) for xx=1,#tab do tab[xx]:Remove() end end 
function weld(pa,p0,p1,x,y,z,a,b,c) local fw = it("Weld",pa) fw.Part0 = p0 fw.Part1 = p1 fw.C0 = cf(x,y,z) *ca(a,b,c) return fw end
function spm(ty,pa,ss) local sp = it("SpecialMesh",pa) sp.MeshType = ty sp.Scale = Vector3.new(ss,ss,ss) end function mbm(pa,sx,sy,sz) local bm = Instance.new("BlockMesh",pa) bm.Scale = Vector3.new(sx,sy,sz) end 
function ra(mn,mx,dc) local tms = 1 if dc == nil then dc = 0 end if type(dc) == "number" and dc > 5 then dc = 5 end for zx=1,dc do tms = tms*10 end   return math.random(mn*tms,mx*tms)/tms end 
p = Serv.p.LocalPlayer -----Your Name Here
bp = p.Backpack
pg = p.PlayerGui
c = p.Character
he = c.Head
t = c.Torso
hu = c.Humanoid
mou = nil
re(c,"Hand")
s = 0.8
     
--tool var
Equip = false
HTrans = 0
HRef = 0
HCol = "a"
LaserCol = "New Yeller"
LaserCol2 = "Really red"
LaserCol3 = "Alder"
Posing = "Follow"
Facing = "Owner"
Anim = {}
Anim.a = "None"
Anim.b = "None"
Anim.Welding = 0
local fingwide = 1.5*s
local finghei = 2.8
local tiphei = 2.55
handoffset = v3(5,18,-8)*s
bgx,bgy,bgz = -90,0,0
w = {}
Button = false 
--
BlastMesh = it("FileMesh")
BlastMesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
RingMesh = it("FileMesh")
RingMesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
RockMesh = it("FileMesh")
DiamondMesh = it("FileMesh")
DiamondMesh.MeshId = "http://www.roblox.com/Asset/?id=9756362"
m = Instance.new("Model",c) m.Name = "Hand"
Palm = pa(m,"Block",6*s,7*s,fingwide*2,true,false,HTrans,HRef,HCol) mbm(Palm,1,1,0.6)
local x,y,z = Palm.Size.x,Palm.Size.y,Palm.Size.z
bPoint1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point1 = weld(bPoint1,Palm,bPoint1,-x/2+(fingwide/2),y/2,0,0,0,0)
pPoint1 = pa(m,"Block",fingwide,finghei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint1,0.9,1,0.9)
wPoint1 = weld(pPoint1,bPoint1,pPoint1,0,pPoint1.Size.y/2,0,0,0,0)
bPoint2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point2 = weld(bPoint2,pPoint1,bPoint2,0,pPoint1.Size.y/2,0,0,0,0)
pPoint2 = pa(m,"Block",fingwide,finghei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint2,0.9,1,0.9)
wPoint2 = weld(pPoint2,bPoint2,pPoint2,0,pPoint1.Size.y/2,0,0,0,0)
bPoint3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point3 = weld(bPoint3,pPoint2,bPoint3,0,pPoint2.Size.y/2,0,0,0,0)
pPoint3 = pa(m,"Block",fingwide,tiphei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint3,0.9,1,0.9)
wPoint3 = weld(pPoint3,bPoint3,pPoint3,0,pPoint3.Size.y/2,0,0,0,0)
bMid1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid1 = weld(bMid1,Palm,bMid1,-x/2+((fingwide/2)+((fingwide)*1)),y/2,0,0,0,0)
pMid1 = pa(m,"Block",fingwide,(finghei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid1,0.9,1,0.9)
wMid1 = weld(pMid1,bMid1,pMid1,0,pMid1.Size.y/2,0,0,0,0)
bMid2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid2 = weld(bMid2,pMid1,bMid2,0,pMid1.Size.y/2,0,0,0,0)
pMid2 = pa(m,"Block",fingwide,(finghei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid2,0.9,1,0.9)
wMid2 = weld(pMid2,bMid2,pMid2,0,pMid1.Size.y/2,0,0,0,0)
bMid3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid3 = weld(bMid3,pMid2,bMid3,0,pMid2.Size.y/2,0,0,0,0)
pMid3 = pa(m,"Block",fingwide,(tiphei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid3,0.9,1,0.9)
wMid3 = weld(pMid3,bMid3,pMid3,0,pMid3.Size.y/2,0,0,0,0)
bRing1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring1 = weld(bRing1,Palm,bRing1,-x/2+((fingwide/2)+((fingwide)*2)),y/2,0,0,0,0)
pRing1 = pa(m,"Block",fingwide,(finghei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing1,0.9,1,0.9)
wRing1 = weld(pRing1,bRing1,pRing1,0,pRing1.Size.y/2,0,0,0,0)
bRing2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring2 = weld(bRing2,pRing1,bRing2,0,pRing1.Size.y/2,0,0,0,0)
pRing2 = pa(m,"Block",fingwide,(finghei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing2,0.9,1,0.9)
wRing2 = weld(pRing2,bRing2,pRing2,0,pRing1.Size.y/2,0,0,0,0)
bRing3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring3 = weld(bRing3,pRing2,bRing3,0,pRing2.Size.y/2,0,0,0,0)
pRing3 = pa(m,"Block",fingwide,(tiphei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing3,0.9,1,0.9)
wRing3 = weld(pRing3,bRing3,pRing3,0,pRing3.Size.y/2,0,0,0,0)
bPinkie1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie1 = weld(bPinkie1,Palm,bPinkie1,-x/2+((fingwide/2)+((fingwide)*3)),y/2,0,0,0,0)
pPinkie1 = pa(m,"Block",fingwide,(finghei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie1,0.9,1,0.9)
wPinkie1 = weld(pPinkie1,bPinkie1,pPinkie1,0,pPinkie1.Size.y/2,0,0,0,0)
bPinkie2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie2 = weld(bPinkie2,pPinkie1,bPinkie2,0,pPinkie1.Size.y/2,0,0,0,0)
pPinkie2 = pa(m,"Block",fingwide,(finghei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie2,0.9,1,0.9)
wPinkie2 = weld(pPinkie2,bPinkie2,pPinkie2,0,pPinkie1.Size.y/2,0,0,0,0)
bPinkie3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie3 = weld(bPinkie3,pPinkie2,bPinkie3,0,pPinkie2.Size.y/2,0,0,0,0)
pPinkie3 = pa(m,"Block",fingwide,(tiphei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie3,0.9,1,0.9)
wPinkie3 = weld(pPinkie3,bPinkie3,pPinkie3,0,pPinkie3.Size.y/2,0,0,0,0)
bThumb1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb1 = weld(bThumb1,Palm,bThumb1,-x/2+(fingwide/7),-y*0.1,-fingwide*0.25,0,0,0)
pThumb1 = pa(m,"Block",fingwide*1.4,(finghei*1)*s,fingwide*1.4,true,false,HTrans,HRef,HCol) mbm(pThumb1,0.9,1,0.9)
wThumb1 = weld(pThumb1,bThumb1,pThumb1,0,pThumb1.Size.y/2,0,0,0,0)
bThumb2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb2 = weld(bThumb2,pThumb1,bThumb2,0,pThumb1.Size.y/2,0,0,0,0)
pThumb2 = pa(m,"Block",fingwide*1.3,(finghei*1)*s,fingwide*1.3,true,false,HTrans,HRef,HCol) mbm(pThumb2,0.9,1,0.9)
wThumb2 = weld(pThumb2,bThumb2,pThumb2,0,pThumb1.Size.y/2,0,0,0,0)
bThumb3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb3 = weld(bThumb3,pThumb2,bThumb3,0,pThumb2.Size.y/2,0,0,0,0)
pThumb3 = pa(m,"Block",fingwide*1.25,(tiphei*1)*s,fingwide*1.25,true,false,HTrans,HRef,HCol) mbm(pThumb3,0.9,1,0.9)
wThumb3 = weld(pThumb3,bThumb3,pThumb3,0,pThumb3.Size.y/2,0,0,0,0)
w["a1"] = Pinkie1
w["a2"] = Pinkie2
w["a3"] = Pinkie3
w["b1"] = Ring1
w["b2"] = Ring2
w["b3"] = Ring3
w["c1"] = Mid1
w["c2"] = Mid2
w["c3"] = Mid3
w["d1"] = Point1
w["d2"] = Point2
w["d3"] = Point3
w["e1"] = Thumb1
w["e2"] = Thumb2
w["e3"] = Thumb3
w.e1.C1 = ca(0,rd(35),rd(-20))
w.e2.C1 = ca(rd(20),0,0)
w.e3.C1 = ca(rd(20),0,0)
w.d1.C1 = ca(0,0,rd(-3))
w.c1.C1 = ca(0,0,rd(-1))
w.b1.C1 = ca(0,0,rd(1))
w.a1.C1 = ca(0,0,rd(3))


function AttachPartsHat(hat,parthand,rotation,position)
hat = cnnnnn[hat].Name
local HatChoice = gp(gp(gp(cnnnnn, hat, "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
HatChoice.Parent = parthand
HatChoice.Position = position or Vector3.new(0,-2,0)
HatChoice.Rotation = rotation or Vector3.new(0,0,0)
parthand.Transparency = 1 --0.8
removeMesh(HatChar[hat].Handle)

end

 AttachPartsHat("MeshPartAccessory",Palm,Vector3.new(0,0,0),Vector3.new(0,0,0))
  AttachPartsHat("Robloxclassicred",bPoint1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
    AttachPartsHat("Pal Hair",bPoint2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
      AttachPartsHat("RedBeanieWithHair",bThumb1,Vector3.new(0,0,0),Vector3.new(0,1.5,0))
        AttachPartsHat("Pink Hair",bRing1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
           AttachPartsHat("Hat1",bRing2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
         AttachPartsHat("LavanderHair",bMid1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
   AttachPartsHat("Kate Hair",bMid2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
    AttachPartsHat("MessyHair",bPinkie1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
     AttachPartsHat("International Fedora",bPinkie2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))

 pPoint1.Transparency = 1 --0.8

pPoint2.Transparency = 1 --0.8

pPoint3.Transparency = 1

pThumb1.Transparency = 1 --0.8

pThumb2.Transparency = 1

pThumb3.Transparency = 1

pMid1.Transparency = 1 --0.8

pMid2.Transparency = 1 --0.8

pMid3.Transparency = 1

pRing1.Transparency = 1 --0.8

pRing2.Transparency = 1 --0.8

pRing3.Transparency = 1
bRing3.Transparency = 1

pPinkie1.Transparency = 1 --0.8

pPinkie2.Transparency = 1 --0.8

pPinkie3.Transparency = 1

bPinkie1.Transparency = 1 --0.8

bPinkie2.Transparency = 1 --0.8

bPinkie3.Transparency = 1

function c1(wexx,smmx,xx,yy,zz) 
coroutine.resume(coroutine.create(function()
local xx2,yy2,zz2 = wexx.C1:toEulerAnglesXYZ() 
local aa,bb,cc = wexx.C0.x,wexx.C0.y,wexx.C0.z
local twa = smmx/wt
Anim.Welding = Anim.Welding + 1
for i=0,twa,1 do wexx.C0 = cf(aa,bb,cc)
wexx.C1 = ca(xx2-(((xx2-rd(xx))/twa)*i),yy2-(((yy2-rd(yy))/twa)*i),zz2-(((zz2-rd(zz))/twa)*i))
wait()
end 
Anim.Welding = Anim.Welding - 1
end))
end 
function CloseFing(fingz,spee)  if spee == nil then spee = 1 end c1(w[fingz.. "1"],spee,80,0,0) c1(w[fingz.. "2"],spee,110,0,0) c1(w[fingz.. "3"],spee,30,0,0) end
function OpenFing(fingz,spee) if spee == nil then spee = 1 end c1(w[fingz.. "1"],spee,2,0,0) c1(w[fingz.. "2"],spee,2,0,0) c1(w[fingz.. "3"],spee,2,0,0)  end 
function HandSign(form,spee) form = form:lower() if spee == nil then spee = 1 end 
if form == "f" then 
CloseFing("d",spee) CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,0,0,0) c1(w["c2"],spee,0,0,0) c1(w["c3"],spee,0,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "fist" then
CloseFing("d",spee) CloseFing("a",spee) CloseFing("b",spee) CloseFing("c",spee)
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "pointer" then
CloseFing("a",spee) CloseFing("b",spee) CloseFing("c",spee)
c1(w["d1"],spee,5,0,0) c1(w["d2"],spee,5,0,0) c1(w["d3"],spee,5,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "v" then
CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,1,0,15) c1(w["c2"],spee,1,0,0) c1(w["c3"],spee,1,0,0) 
c1(w["d1"],spee,1,0,-15) c1(w["d2"],spee,1,0,0) c1(w["d3"],spee,1,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "free" or form == "five" then
OpenFing("a",spee) OpenFing("b",spee) OpenFing("c",spee) OpenFing("d",spee) 
c1(w["e1"],spee,0,35,-20) c1(w["e2"],spee,20,0,0) c1(w["e3"],spee,20,0,0) 
elseif form == "ride" then 
c1(w["a1"],spee,60,0,0) c1(w["a2"],spee,-30,0,0) c1(w["a3"],spee,-30,0,0) 
c1(w["b1"],spee,30,0,0) c1(w["b2"],spee,65,0,0) c1(w["b3"],spee,60,0,0) 
c1(w["c1"],spee,30,0,0) c1(w["c2"],spee,65,0,0) c1(w["c3"],spee,60,0,0) 
c1(w["d1"],spee,30,0,0) c1(w["d2"],spee,65,0,0) c1(w["d3"],spee,60,0,0) 
c1(w["e1"],spee,-70,185,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
elseif form == "gun" then


CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,0,0,1) c1(w["c2"],spee,0,0,0) c1(w["c3"],spee,0,0,0) 
c1(w["d1"],spee,0,0,-1) c1(w["d2"],spee,0,0,0) c1(w["d3"],spee,0,0,0) 
c1(w["e1"],spee,-60,90,0) c1(w["e2"],spee,20,0,0) c1(w["e3"],spee,-20,0,0) 
elseif form == "wide" then
c1(w["a1"],spee,-3,0,45) c1(w["a2"],spee,-3,0,0) c1(w["a3"],spee,-3,0,0) 
c1(w["b1"],spee,-3,0,15) c1(w["b2"],spee,-3,0,0) c1(w["b3"],spee,-3,0,0) 
c1(w["c1"],spee,-3,0,-15) c1(w["c2"],spee,-3,0,0) c1(w["c3"],spee,-3,0,0) 
c1(w["d1"],spee,-3,0,-45) c1(w["d2"],spee,-3,0,0) c1(w["d3"],spee,-3,0,0) 
c1(w["e1"],spee,-70,90,0) c1(w["e2"],spee,10,0,0) c1(w["e3"],spee,-10,0,0) 
elseif form == "wide2" then
c1(w["a1"],spee,-18,0,45) c1(w["a2"],spee,36,0,0) c1(w["a3"],spee,30,0,0) 
c1(w["b1"],spee,-18,0,15) c1(w["b2"],spee,36,0,0) c1(w["b3"],spee,30,0,0) 
c1(w["c1"],spee,-18,0,-15) c1(w["c2"],spee,36,0,0) c1(w["c3"],spee,30,0,0) 
c1(w["d1"],spee,-18,0,-45) c1(w["d2"],spee,36,0,0) c1(w["d3"],spee,30,0,0) 
c1(w["e1"],spee,-50,90,-10) c1(w["e2"],spee,5,0,-30) c1(w["e3"],spee,-10,0,-40) 
elseif form == "grab2" then
c1(w["a1"],spee,-70,-65,0) c1(w["a2"],spee,40,0,0) c1(w["a3"],spee,20,0,0) 
c1(w["b1"],spee,-70,-20,0) c1(w["b2"],spee,40,0,0) c1(w["b3"],spee,20,0,0) 
c1(w["c1"],spee,-70,20,-0) c1(w["c2"],spee,40,0,0) c1(w["c3"],spee,20,0,0) 
c1(w["d1"],spee,-70,65,-0) c1(w["d2"],spee,40,0,0) c1(w["d3"],spee,20,0,0) 
c1(w["e1"],spee,-70,150,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
elseif form == "grab3" then
c1(w["a1"],spee,-30,-40,30) c1(w["a2"],spee,50,0,0) c1(w["a3"],spee,35,0,0) 
c1(w["b1"],spee,-30,-15,12) c1(w["b2"],spee,50,0,0) c1(w["b3"],spee,35,0,0) 
c1(w["c1"],spee,-30,15,-12) c1(w["c2"],spee,50,0,0) c1(w["c3"],spee,35,0,0) 
c1(w["d1"],spee,-30,40,-30) c1(w["d2"],spee,50,0,0) c1(w["d3"],spee,35,0,0) 
c1(w["e1"],spee,-55,205,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
end
end
function ColFings(iscol)
pPinkie1.CanCollide = iscol
pPinkie2.CanCollide = iscol
pPinkie3.CanCollide = iscol
pRing1.CanCollide = iscol
pRing2.CanCollide = iscol
pRing3.CanCollide = iscol
pMid1.CanCollide = iscol
pMid2.CanCollide = iscol
pMid3.CanCollide = iscol
pPoint1.CanCollide = iscol
pPoint2.CanCollide = iscol
pPoint3.CanCollide = iscol
pThumb1.CanCollide = iscol
pThumb2.CanCollide = iscol
pThumb3.CanCollide = iscol
end
function ray(Pos, Dir) 
return Workspace:FindPartOnRay(Ray.new(Pos, Dir.unit *999), c) 
end 
function Earthsplosion(pos,siz,dmg,rndmg,forc,eos) local colz22 = "Earth green" if eos == nil or eos == "earth" then eos = "earth" else colz22 = "Pastel brown" eos = "sand" end 
coroutine.resume(coroutine.create(function() 
if eos == "earth" then local cr = pa(m,"Block",((14*siz)/10)*s,0,((14*siz)/10)*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = pos *ca(rd(0),rd(ra(-360,360)),rd(0)) cr.CFrame = cr.CFrame + v3(ra(-siz*10,siz*10)/22,0,ra(-siz*10,siz*10)/22)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,25) end
for i=1,4 do
coroutine.resume(coroutine.create(function() 
local sw = pa(m,"Block",(siz/3)*s,(siz*1.3)*s,(siz/3)*s,true,true,0,0,colz22) sw.Anchored = true sw.CFrame = pos *cf(ra(-3*s,3*s),0,ra(-3*s,3*s)) *ca(rd(ra(-27,27)),rd(ra(-360,360)),rd(ra(-27,27))) local swm = it("SpecialMesh",sw) if eos == "earth" then swm.MeshType = "FileMesh"
swm.MeshId = asset .. Decs.Spike else swm.MeshType = "Sphere" end if eos == "earth" then swm.Scale = v3(sw.Size.x/1.3,sw.Size.y*1.2,sw.Size.z/1.3)
else swm.Scale = v3(sw.Size.x/10,sw.Size.y/37,sw.Size.z/10) end sw.CFrame = sw.CFrame + v3(ra(-0.3*siz*s,0.3*siz*s,7),0,ra(-0.3*siz*s,0.3*siz*s)) sw.CFrame = sw.CFrame * cf(0,-sw.Size.y/1.4,0)
Dustplosion(cf(pos.p+v3(0,2*s,0)),18*s,{"Dark green","Bright green","Brown"},1)
if eos == "earth" then 
for x=1,8 do
sw.CFrame = sw.CFrame *cf(0,sw.Size.y/8,0) wait() end wait(ra(1,5))
for x=1,20 do
sw.CFrame = sw.CFrame *cf(0,-sw.Size.y/20,0) wait()
end sw:Remove()
else 
for x=1,25 do
sw.CFrame = sw.CFrame *cf(0,sw.Size.y/25,0) sw.Transparency = x/25 - 0.1 swm.Scale = swm.Scale + v3(0.025,0.025,0.025) wait() end
end sw:Remove()
end)) end 
wait(0.3)
DmgHumanoidsNear(pos.p,dmg,rndmg,5.5*s*(siz/4),forc)
end))
end
function Dustplosion(onb,scale,col,cls) coroutine.resume(coroutine.create(function() 
for x=1,cls do coroutine.resume(coroutine.create(function()  
local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col[ra(1,#col)]) sw.Anchored = true sw.CFrame = onb *ca(rd(ra(-35,35)),rd(ra(-360,360)),rd(ra(-35,35))) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh"
swm.MeshId = asset .. Decs.Cloud sw.CFrame = sw.CFrame + v3(ra(-scale,scale)/8,ra(-scale,scale)/8,ra(-scale,scale)/8) 
for i=1,scale,0.25 do 
swm.Scale = v3(i*1.5,i*1,i*1.5) sw.Transparency = ((i/scale)/2) + 0.45
wait()
end
sw:Remove()
end)) end 
end)) end 
function ShockWave(onb,scale,col) coroutine.resume(coroutine.create(function()  local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col) sw.Anchored = true sw.CFrame = onb *ca(rd(90),0,0) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh" swm.MeshId = RingMesh.MeshId  
for i=1,scale,0.75 do  swm.Scale = v3(i*1.5,i*1.5,i*1.5) sw.Transparency = (i/scale) + 0 wait() end sw:Remove() end)) end 
function BlastWave(onb,scale,ymes,col) coroutine.resume(coroutine.create(function() 
local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col) sw.Anchored = true sw.CFrame = onb *ca(rd(0),0,0) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh"
swm.MeshId = BlastMesh.MeshId 
for i=1,scale,scale/11 do 
swm.Scale = v3(i*1.25,i*ymes,i*1.25) sw.CFrame = sw.CFrame *ca(0,rd(720*(i/scale)),0) sw.Transparency = (i/scale) + 0
wait()
end
sw:Remove()
end))
end 
function Explode(onb,scale,col) local Torm = m coroutine.resume(coroutine.create(function() local e1 = Instance.new("Part") e1.Anchored = true e1.formFactor = "Custom" e1.CanCollide = false e1.Size = Vector3.new(1,1,1) e1.BrickColor = BrickColor.new(col) 
e1.Transparency = 0.6 e1.TopSurface = 0 e1.BottomSurface = 0 e1.Parent = Torm e1.CFrame = onb local e1m = Instance.new("SpecialMesh") 
e1m.MeshType = "Sphere" e1m.Parent = e1 local r1 = Instance.new("Part") r1.Anchored = true r1.formFactor = "Custom" r1.CanCollide = false r1.Size = Vector3.new(1,1,1) r1.BrickColor = BrickColor.new(col) r1.Transparency = 0.6 r1.TopSurface = 0 r1.BottomSurface = 0 r1.Parent = Torm r1.CFrame = e1.CFrame *CFrame.Angles(math.rad(180),0,0) local r1m = Instance.new("SpecialMesh") r1m.MeshType = "FileMesh" 
r1m.Scale = Vector3.new(3,3,3) r1m.Parent = r1 r1m.MeshId = RingMesh.MeshId local r2 = Instance.new("Part") r2.Anchored = true r2.formFactor = "Custom" r2.CanCollide = false r2.Size = Vector3.new(1,1,1) r2.BrickColor = BrickColor.new(col) r2.Transparency = 0.6 r2.TopSurface = 0 r2.BottomSurface = 0 r2.Parent = Torm r2.CFrame = e1.CFrame *CFrame.Angles(0,math.rad(180),0) local r2m = Instance.new("SpecialMesh") r2m.MeshType = "FileMesh" 
r2m.Parent = r2 r2m.Scale = Vector3.new(3,3,3) r2m.MeshId = RingMesh.MeshId local bla = Instance.new("Part") bla.Anchored = true 
bla.formFactor = "Custom" bla.CanCollide = false bla.Size = Vector3.new(1,1,1)  bla.BrickColor = BrickColor.new(col) bla.Transparency = 0.6 bla.TopSurface = 0 bla.BottomSurface = 0 bla.Parent = Torm bla.CFrame = onb local blam = Instance.new("SpecialMesh") 
blam.MeshType = "FileMesh" blam.Parent = bla blam.Scale = Vector3.new(5,5,5) blam.MeshId = BlastMesh.MeshId for i=1,30 do local pluscal = scale/38 e1m.Scale = e1m.Scale + Vector3.new(pluscal,pluscal,pluscal) 
r1m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal) r2m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal)
blam.Scale = blam.Scale + Vector3.new(pluscal,pluscal/2,pluscal) bla.CFrame = bla.CFrame * CFrame.Angles(0,math.rad(12),0) r1.CFrame = r1.CFrame * CFrame.Angles(math.rad(6),0,0) r2.CFrame = r2.CFrame * CFrame.Angles(0,math.rad(6),0) wait() end for i=1,30 do local pluscal = scale/38 e1m.Scale = e1m.Scale + Vector3.new(pluscal,pluscal,pluscal)  r1m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal) r2m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal)
blam.Scale = blam.Scale + Vector3.new(pluscal/3,pluscal/3,pluscal/3) bla.CFrame = bla.CFrame * CFrame.Angles(0,math.rad(12),0) r1.CFrame = r1.CFrame * CFrame.Angles(math.rad(6),0,0) r2.CFrame = r2.CFrame * CFrame.Angles(0,math.rad(6),0) bla.Transparency = bla.Transparency + 0.1 e1.Transparency = e1.Transparency + 0.1 r1.Transparency = r1.Transparency + 0.1 r2.Transparency = r2.Transparency + 0.1 wait() end e1:Remove() r1:Remove() r2:Remove() end)) end
function Hurtsplosion(pos,dmg,rndmg,siz,forc)
coroutine.resume(coroutine.create(function() local boomcol = {"Bright red","New Yeller","Neon orange"}
for i=1,3 do 
coroutine.resume(coroutine.create(function()
local plos = pa(m,"Block",1*s*siz,1.5*s*siz,0.7*s*siz,false,false,0.3,0,boomcol[i]) spm("Sphere",plos,1) plos.Anchored = true
plos.CFrame = cf(pos + v3(0,0,0)) * ca(rd(ra(-360,360)),rd(ra(-360,360)),rd(ra(-360,360)))
plos.Mesh.Scale = v3(0.1,0.1,0.1)
for i=0.3,1,0.03 do local plc = plos.CFrame
plos.Mesh.Scale = v3(i*6,i*6,i*6) plos.Transparency = i plos.CFrame = plc * ca(rd(3),rd(3),0)
wait()
end
plos:Remove()
end))
end 
end))
wait(0.1)
DmgHumanoidsNear(pos,dmg,rndmg,5.5*s*siz,forc)
end
function DmgHumanoidsNear(pos,dmg,rndmg,mag,forc) 
    --[[
local function kidive(ob) 
for i,v in pairs(ob:children()) do 
if v:IsA("BasePart") and v.Parent.Parent:findFirstChild("Humanoid") == nil and v.Parent:findFirstChild("Humanoid") == nil and (v.Position - pos).magnitude < mag*1.3 and v.Anchored == false  and v:GetMass() < 150 then 
 
end
if v:IsA("Humanoid") and v ~= hu and v.Parent:findFirstChild("Torso") then 
if (pos - v.Parent.Torso.Position).magnitude < mag then local tdmg = dmg*ra(1,rndmg) 
if v.Parent:findFirstChild("Hh") == nil then local hh= Instance.new("NumberValue",v.Parent) hh.Name = "Hh"
hh.Value = v.Health - tdmg else v.Parent.Hh.Value = v.Health - (tdmg*3.5) end 
 if v.Parent.Hh.Value < 1 then end 
end  
end 
if v:IsA("Model") or v:IsA("Workspace") then kidive(v) end end end 
kidive(workspace)  ]]
end 
function Fire(bullet,typez,siz,dmg,rndmg,forc)
if typez == 1 then
bullet.Anchored = true 
local bullethit = false
local tyms = 0
repeat
tyms = tyms + 2
local bhit,bpos = ray(bullet.Position,bullet.Position - (bullet.CFrame *cf(0,0,-1)).p) 
if bpos ~= nil and (bpos - bullet.Position).magnitude < 7  then bullethit = true else bullet.CFrame = bullet.CFrame *cf(0,0,-1*s) *ca(rd(-0.0025),rd(0),0) end 
if tyms%32 == 0 then wait() end 
until bullethit or bullet.Position.y < -300 or tyms > 800 
bullet.CFrame = bullet.CFrame *cf(0,0,8) bullet:Remove()
if bullet.Position.y < -300 then
else
Hurtsplosion(bullet.Position,dmg,rndmg,siz,forc)
end
elseif typez == 2 then
bullet.Anchored = true 
local bullethit = false
local tyms = 0
local ming = 0.001
repeat 
if tyms > 70 and (ming == 0.001 or ming == -2.5) then ming = -2.5
local bpos = (bullet.CFrame *cf(0,0,-300)).p if (bpos - v3(Palm.Position.x,bpos.y,Palm.Position.z)).magnitude < 25*s then ming = 0 end 
end
tyms = tyms + 2
local bhit,bpos = ray(bullet.Position,bullet.Position - (bullet.CFrame *cf(0,0,-1)).p) 
if bpos ~= nil and (bpos - bullet.Position).magnitude < 7  then bullethit = true else bullet.CFrame = bullet.CFrame *cf(0,0,-0.5) *ca(rd(ming),rd(0),0) end
if tyms%16 == 0 then wait() end 
until bullethit or bullet.Position.y < -300 or tyms > 500 
bullet.CFrame = bullet.CFrame *cf(0,0,8) bullet:Remove()
if bullet.Position.y < -300 then
else
Hurtsplosion(bullet.Position,dmg,rndmg,siz,forc)
end
elseif typez == 3 then 
end
end 
function ShortifiedAnim(theanim)
if theanim == "Beam" then
local crom = pa(m,"Block",0,0,0,true,true,0.5,0,LaserCol3) local cromm = it("SpecialMesh",crom) cromm.MeshType = "FileMesh" cromm.MeshId = asset .. Decs.Crown
cromm.Scale = v3(15*s,5*s,15*s) crom.Anchored = true --local cromw = weld(crom,Palm,crom,0,Palm.Size.y/3.6,-Palm.Size.z*1.8,rd(-90),0,0)
dias = {} loldiv = 360/8 for x=0,360,loldiv do 
local dia = pa(m,"Block",0,0,0,false,false,0,0,LaserCol2) dia.Anchored = true local diam = it("SpecialMesh",dia) diam.MeshType = "FileMesh" diam.MeshId = DiamondMesh.MeshId
diam.Scale = v3(3*s,9*s,3*s) table.insert(dias,dia)
end Button = true coroutine.resume(coroutine.create(function() local tardz = 0 repeat wait() tardz = tardz+ 15
crom.CFrame = Palm.CFrame *ca(rd(-90),0,0) *cf(0,5.5*s,2*s) *ca(0,rd(tardz),0) 
for rofl=1,#dias do dias[rofl].CFrame = crom.CFrame *ca(0,rd(rofl*loldiv),0) *cf(0,-19*s,0) *ca(rd(25),0,0) *cf(0,32*s,0) end 
 until not Button for x2=0.5,1,0.05 do wait() crom.Transparency = x2 end   end))
coroutine.resume(coroutine.create(function() for xk=1,0.5,-0.02 do wait() for i=1,#dias do dias[i].Transparency =xk end end end))
wait(1) local beamoffset = v3(0,0,0)
local b1 = pa(m,"Ball",10*s,10*s,10*s,false,false,0.1,0,LaserCol) b1.Anchored = true 
local b2 = pa(m,"Block",10*s,1,10*s,false,false,0.1,0,LaserCol) b2.Anchored = true  local b2m = it("CylinderMesh",b2)
local b3 = pa(m,"Ball",10*s,10*s,10*s,false,false,0.1,0,LaserCol) b3.Anchored = true 
local bpos = nil local bhit = nil local ts = 0
 repeat beamoffset = v3(ra(-2*s,2*s),ra(-2*s,2*s),ra(-2*s,2*s)) ts = ts + 1
bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,0,1)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 1500 then break end 
b1.CFrame = Palm.CFrame *cf(0,3*s,-11*s) 
b3.CFrame = cf(bpos) local lenz = (b1.Position - b3.Position).magnitude 
b2.CFrame = cf(b1.Position,b3.Position) *ca(rd(90),0,0) *cf(0,-lenz/2,0)  b2m.Scale = v3(1,lenz,1)
b1.CFrame = b1.CFrame + beamoffset b2.CFrame = b2.CFrame + beamoffset b3.CFrame = b3.CFrame + beamoffset 
if ts%10 == 0 then DmgHumanoidsNear(b3.Position,3,10,(14*s)+2,100) Explode(b3.CFrame*cf(0,b3.Size.y/3,0),25*s,LaserCol2) end
wait()  until not Button or ts > 600
  coroutine.resume(coroutine.create(function() for xk=0.1,1.1,0.08 do wait() b1.Transparency = xk  b2.Transparency = xk  b3.Transparency = xk  end b1:Remove() b2:Remove() b3:Remove() end))
 coroutine.resume(coroutine.create(function() for xk=0.5,1.1,0.02 do wait() for i=1,#dias do dias[i].Transparency =xk end end end))
wait(1)  clearit(dias) crom:Remove()
end
end 
PalmLev = it("BodyPosition",Palm) 
PalmFace = it("BodyGyro",Palm) PalmFace.maxTorque = v3(0,0,0)
coroutine.resume(coroutine.create(function()
PalmLev.position = (t.CFrame *cf(handoffset)).p
local yspi = 0
while true do yspi = yspi + 8
if Anim.a == "Gun" or Anim.a == "Ride" or Anim.a == "Pound" then 
Facing = "Mouse" bgx = -90 bgy = 90 bgz = 0 
elseif Anim.a == "Fu" or Anim.a == "Fist" or Anim.a == "GroundGrip" then 
Facing = "Mouse" bgx = -90 bgy = 0 bgz = 0 
elseif Anim.a == "Splat" or Anim.a == "Beam" then
Facing = "Mouse" bgx = 0 bgy = 0 bgz = 0 
elseif Anim.a == "None" then 
Facing = "Owner" bgx = -90 bgy = 0 bgz = 0 Posing = "Follow"
elseif Anim.a == "Shower" then
Facing = "None" bgx = 0 bgy = 0 bgz = 0 Posing = "TopOwner"
end 
if Posing == "Follow" then 
PalmLev.maxForce = v3(1/0,1/0,1/0) PalmLev.position = (t.CFrame *cf(handoffset) *cf(0,0,0)).p 
elseif Posing == "TopOwner" then
PalmLev.maxForce = v3(1/0,1/0,1/0) PalmLev.position = (t.CFrame *cf(0,12*s,0)).p 
end 
if Facing == "Owner" then 
PalmFace.maxTorque = v3(1/0,1/0,1/0) PalmFace.cframe = cf(Palm.Position,he.Position) *ca(rd(bgx),rd(bgy),rd(bgz))
elseif Facing == "Mouse" and mou ~= nil and Equip then 
if Anim.a == "Gun" or Anim.a == "Beam" or Anim.a == "Ride" or Anim.a == "GroundGrip" or Anim.a == "Fu" or Anim.a == "Pound" or Anim.a == "Splat" or Anim.a == "Fist" then 
if Anim.b == "None" or Anim.a == "Beam" or Anim.a == "Ride" then 
PalmFace.cframe = cf(Palm.Position,mou.Hit.p) *ca(rd(bgx),rd(bgy),rd(bgz)) wait(0.05)
end end end
wait(0.05)
end 
end))
function FireFinger(lasercol,ffingz,targ,typez,siz,dmg,rndmg,forc) coroutine.resume(coroutine.create(function() 
local laser = pa(m,"Block",fingwide*1.3,fingwide*1.3,fingwide*2.5,true,false,0,0,lasercol) spm("Sphere",laser,1+(siz/5.5)) laser.Name = "Projectile"
local lw = weld(laser,ffingz,laser,0,ffingz.Size.y/0.8 +(siz/2.5),0,rd(90),0,0)
for i=1,0.4,-0.05 do laser.Transparency = i wait() end 
BlastWave(ffingz.CFrame*cf(0,ffingz.Size.y*1.3,0)*ca(0,0,0),ffingz.Size.x*1.6,1.8,LaserCol2)
lw:Remove() laser.CFrame = cf(laser.Position,targ)
Fire(laser,typez,siz,dmg,rndmg,forc) 
end))
end
GrabWeld = it("Weld",m)
Palm.Touched:connect(function(touch)
print(touch) print(touch.Parent)  print(touch.Parent.Parent)
if Anim.a == "Ride" and GrabWeld.Part1 == nil and touch.Parent:findFirstChild("HumanoidRootPart") and touch.Parent:findFirstChild("Humanoid") then
local tor = touch.Parent.HumanoidRootPart touch.Parent.Humanoid.PlatformStand = true 
GrabWeld.Part0 = Palm GrabWeld.Part1 = tor GrabWeld.C0 = cf(-3*s,4.5*s,-Palm.Size.x/2) GrabWeld.C1 = ca(0,rd(90),rd(-90)) *ca(0,rd(0),0)
end
end)
re(bp,"Hand")
hb = it("HopperBin",bp) hb.Name = "Hand"
hb.Selected:connect(function(mouse) mou = mouse Equip = true
mouse.KeyDown:connect(function(k)  k = k:lower()
if Anim.a == "Ride" and k == "f" then FireFinger(LaserCol,pPinkie3,mouse.Hit.p,1,2.25,1,18,30)  end
if Anim.b ~= "None" or Anim.Welding ~= 0 then  return end 
if Anim.a == "None" then
if k == "f" then -- on anim on
Anim.a = "Gun" HandSign("Gun",0.7)
vargun = true
elseif k == "p" then
Anim.a = "Fu" HandSign("f",1)
elseif k == "g" then
Anim.a = "Fist" HandSign("fist",1)
elseif k == "c" then
Anim.a = "Splat" HandSign("wide",1)
elseif k == "r" then
Anim.a = "Ride" HandSign("ride",1) Posing = "None"
elseif k == "v" then
Anim.a = "Shower" HandSign("grab2",1) PalmFace.cframe = cf(0,0,0) *ca(0,0,0)
elseif k == "b" then
Anim.a = "Pound" HandSign("fist",1)
elseif k == "x" then
Anim.a = "GroundGrip" HandSign("grab2",1)
elseif k == "z" then
Anim.a = "Beam" HandSign("wide2",1) 
end 
else
if k == "f" and Anim.a == "Gun" then -- on anim off
vargun = false
Anim.a = "None" HandSign("five",0.8)
elseif k == "p" and Anim.a == "Fu" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "g" and Anim.a == "Fist" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "c" and Anim.a == "Splat" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "r" and Anim.a == "Ride" then
Anim.a = "None" HandSign("five",0.8) GrabWeld.Part0 = nil Anim.b = "None" Posing = "Follow"  Facing = "Owner"
if GrabWeld.Part1 ~= nil and GrabWeld.Part1.Parent:findFirstChild("Humanoid") ~= nil then GrabWeld.Part1.Parent.Humanoid.PlatformStand = false end GrabWeld.Part1 = nil
elseif k == "v" and Anim.a == "Shower" then
Anim.a = "None" HandSign("five",0.8) Posing = "Follow" Facing = "Owner"
elseif k == "b" and Anim.a == "Pound" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "x" and Anim.a == "GroundGrip" then 
Anim.a = "None" HandSign("five",0.8)
elseif k == "z" and Anim.a == "Beam" then 
Anim.a = "None" HandSign("five",0.8)
end
end
end)
mouse.Button1Down:connect(function()
if Anim.a == "None" or Anim.b ~= "None" then return end 
if Anim.a == "Gun" then
Anim.b = "Gun" FireFinger(LaserCol,pPoint3,mouse.Hit.p,1,2.25,1,10,60) FireFinger(LaserCol,pMid3,mouse.Hit.p,1,2.25) wait(1) Anim.b = "None"
elseif Anim.a == "Fu" then
Anim.b = "Fu" FireFinger(LaserCol,pMid3,mouse.Hit.p,1,3.65,2,14,95) wait(0.25) Anim.b = "None"
elseif Anim.a == "Fist" then 
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
Anim.b = "Fist" Posing = "None" PalmFace.cframe = cf(Palm.Position,bpos) *ca(rd(-90),0,0)
PalmLev.position = (Palm.CFrame *cf(0,-15*s,0)).p
wait(0.45)
PalmLev.position = bpos + ((Palm.CFrame *cf(0,1*s,0)).p - Palm.Position)
local tz = 0 repeat wait()  BlastWave(Palm.CFrame*ca(rd(180),0,0),8*s,3.5,HCol) tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 8*s or tz > 1
Explode(Palm.CFrame *cf(0,6*s,0) *ca(rd(180),0,0),15*s,ts(bhit.BrickColor))
DmgHumanoidsNear((Palm.CFrame *cf(0,8,0)).p,3,10,(12*s)+2,105)
if not bhit.Anchored then PalmLev.position = (Palm.CFrame *cf(0,12*s,0)).p wait(0.5) end 
wait(1) Posing = "Follow" Anim.b = "None"
elseif Anim.a == "Splat" then
if mouse.Target == nil and (Palm.Position - mouse.Hit.p).magnitude > 500 then return end local bpos = mouse.Hit.p
Anim.b = "Splat" Posing = "None" 
local ya,yb,yc = PalmFace.cframe:toEulerAnglesXYZ() PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(-90),0,0) PalmLev.position = bpos + v3(0,10*s,0)
local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 5*s or tz > 1.3 
for i=-90,0,5 do 
PalmLev.position = PalmLev.position + v3(0,2*s,0) PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(i),0,0)
wait()
end  wait(0.2)
for i=0,-100,-10 do 
local lewd = i
if lewd < -50 then lewd = -95 end 
PalmLev.position = PalmLev.position - v3(0,4.7*s,0) PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(lewd),0,0)
wait()
end wait(0.2)
local cr = pa(m,"Block",16*s,0,16*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = cf(bpos) *ca(0,rd(ra(-360,360)),0)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,16)
DmgHumanoidsNear((Palm.CFrame *cf(0,0,-1)).p,3,20,(15*s)+2,110)
ShockWave(Palm.CFrame *ca(rd(90),0,0),25*s,LaserCol)
wait(1) Posing = "Follow" Anim.b = "None"
elseif Anim.a == "Ride" and Button == false then
Posing = "None" Anim.b = "Ride"
Button = true
repeat PalmLev.position = (Palm.CFrame *cf(0,10,0)).p wait() until Button == false
 Anim.b = "None"
elseif Anim.a == "Shower" and Button == false then
Anim.b = "Shower" Button = true 
repeat
local targz = Palm.Position + v3(0,20*s,0)
if ra(1,12) == 1 then FireFinger(LaserCol,pPinkie3,targz,2,4,1,18,55) end
if ra(1,13) == 1 then FireFinger(LaserCol,pRing3,targz,2,4,1,18,60) end
if ra(1,12) == 1 then FireFinger(LaserCol,pMid3,targz,2,4,1,18,65) end
if ra(1,13) == 1 then FireFinger(LaserCol,pPoint3,targz,2,4,1,18,70) end
if ra(1,12) == 1 then FireFinger(LaserCol,pThumb3,targz,2,4,1,18,80) end
PalmFace.cframe = PalmFace.cframe *ca(0,rd(10),0)
wait()
until Button == false
Anim.b = "None" 
elseif Anim.a == "Pound" and Anim.b == "None" then Posing = "None" Anim.b = "Pound"
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
PalmLev.position = bpos + v3(0,15*s,0) 
local ya,yb,yc = PalmFace.cframe:toEulerAnglesXYZ() PalmFace.cframe = ca(ya,yb,yc) 
 local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 5*s or tz > 1.3  wait(0.1)
for i=-90,-10,10 do
PalmFace.cframe = ca(ya,yb,yc) *ca(0,0,rd(i+90)) PalmLev.position = PalmLev.position + v3(0,2.5*s,0)
wait() end wait(0.25) local realcf = cf(v3(he.Position.x,0,he.Position.z),v3(Palm.Position.x,0,Palm.Position.z))
for i=-10,-90,-10 do
PalmFace.cframe =  ca(ya,yb,yc) *ca(0,0,rd(i+90)) PalmLev.position = PalmLev.position - v3(0,4*s,0)
wait() end PalmFace.cframe = realcf *ca(rd(-90),rd(90),0) wait(0.25)
local cr = pa(m,"Block",22*s,0,22*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = cf(bpos) *ca(0,rd(ra(-360,360)),0)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,16)
Dustplosion(Palm.CFrame *cf(2*s,0,0) *ca(rd(90),0,rd(90)),30*s,{"Dark green","Bright green","Brown"},3)
ShockWave(Palm.CFrame *cf(2*s,0,0) *ca(rd(90),0,rd(90)),20*s,ts(bhit.BrickColor))
DmgHumanoidsNear((Palm.CFrame *cf(0,1,0)).p,1,20,(15*s)+2,90) wait(0.2)
local palmcf = cf(bpos) local earthsplos = ra(5,8) palmcf = Palm.CFrame *ca(0,rd(90),0) *ca(rd(-90),0,rd(0))
for i=1,earthsplos do Earthsplosion(palmcf *cf(0,-2*s,((i*7)+7)*s),10,1,20,75) wait(0.1) end 
Earthsplosion(palmcf *cf(0,-2*s,(((earthsplos+1)*7)+7)*s),16,2,25,75)
      wait(1) Posing = "Follow" wait(0.25) Anim.b = "None" 
elseif Anim.a == "GroundGrip" then Posing = "None" Anim.b = "GroundGrip"
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
PalmLev.position = bpos + v3(0,27*s,0) ColFings(false)
local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 8*s or tz > 1.3  wait(0.1)
local thepos = (Palm.CFrame *cf(0,-0.1*s,0)).p - Palm.Position
PalmFace.cframe = cf(Palm.Position,bpos + thepos) *ca(rd(-90),0,0)
for i=27,1,-3 do PalmLev.position = bpos + v3(0,i*s,0) wait(0.07) end HandSign("grab3",0.4) wait(0.55)
local ro = pa(m,"Ball",0,0,0,false,false,0,0,"Earth green") ro.Name = "Rock" local row = it("SpecialMesh",ro) row.MeshType = "FileMesh" row.MeshId = asset .. Decs.Rock
local rowe = weld(ro,Palm,ro,0,Palm.Size.y,-Palm.Size.z*1.2,0,0,0) row.Scale = v3(9*s,10*s,9*s)
coroutine.resume(coroutine.create(function() for xz=1,70,7 do PalmLev.position = bpos + v3(0,xz*s,0) wait(0.06) end end))
wait(0.25) Dustplosion(cf(bpos),30*s,{"Dark green","Bright green","Brown"},3) local lolra = ra(-360,360)
Earthsplosion(cf(bpos),25,1,20,125,"sand") for yyy=0,360,60 do  coroutine.resume(coroutine.create(function()
for zzz=1,4 do 
Earthsplosion(cf(bpos) *ca(0,rd(yyy+lolra),0) *cf(0,0,zzz*15*s),10,1,20,75) wait(0.14)
end wait(0.25) Earthsplosion(cf(bpos) *ca(0,rd(yyy+lolra),0) *cf(0,0,5*18*s),25,1,20,120)  end)) end 
wait(0.3) HandSign("grab2",0.5) wait(0.75) Serv.d:AddItem(ro,20) rowe:Remove() ro.CanCollide = true local rocf = ro.CFrame ro.Size=v3(14*s,14*s,14*s) ro.CFrame = rocf wait(0.75) ColFings(true) Posing = "Follow" Anim.b = "None" 
elseif Anim.a == "Beam" and not Button and Anim.b == "None" then Anim.b = "Beam" 
ShortifiedAnim("Beam") wait(0.5) Anim.b = "None"
end
end)
mouse.Button1Up:connect(function()
Button = false
end)
mouse.Move:connect(function() 
end)
end)
hb.Deselected:connect(function(mouse)
Equip = false
end)
--lego
game.Players.LocalPlayer.Character.Humanoid.MaxHealth = math.huge  -----Put your name where it says "YourNameHere"
print(lego)

click = false

mwouse.Button1Down:Connect(function()
    click=true
    end)
    
 mwouse.Button1Up:Connect(function()
    click=false
    end)

    if getgenv().HatCollide == false then
--[[]]
game:GetService("RunService").Heartbeat:Connect(function()
    mwouse.TargetFilter=char
    if vargun == true then 
    if click == true then
    GlobalFunctions.fling(mwouse.Hit.p)
    --bppart.Position=mwouse.Hit.p
    --char['Right Arm'].Position=mwouse.Hit.p
    else
    --bppart.Position=char["Pal Hair"].Handle.Position
    --char['Right Arm'].Position=char["Pal Hair"].Handle.Position
    end
    else
    if click == true then
    GlobalFunctions.fling(mwouse.Hit.p)
    --bppart.Position=mwouse.Hit.p
    --char['Right Arm'].Position=mwouse.Hit.p
    else
    --bppart.Position=reanim.VANS_Umbrella.Handle.Position
    --char['Right Arm'].Position=reanim.VANS_Umbrella.Handle.Position
    end
    end
    end) 

end
end)

Section:NewButton("Mercenary", "ButtonInfo", function()
    print("Clicked")
kon=game:GetService("Players").LocalPlayer
--kon=require(script[':flushed: magic'])
Mouse,mouse,UserInputService,RenderStepped,Player=kon:GetMouse(),kon:GetMouse(),game:service'UserInputService',game:GetService('RunService').Heartbeat,kon
script = game:GetObjects("rbxassetid://5177488826")[1].Soldier
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- -gh 6198633506,7167966065
-- -gh 7604371176,6202097932
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

-----------------------------------------------------------------------
--weld fun by DrexxieTheLoaf
--Script Rikaku/RedSquid/Bean
--Nebula_Loafua for the footplanting n stuff
-- || VARIABLES || -- 
local Players = game:GetService("Players")
local Character = kon.Character
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local HUM = Character.Humanoid
local ROOT = HUM.Torso
script.Owner.Value = kon.Name
script.Owner.Parent = game:GetService("ReplicatedStorage")
Humanoid.WalkSpeed = 24
local Debris = game:GetService("Debris")
--script.Assets.Parent = game.ReplicatedStorage
local Assets = script.Assets
for i,v in pairs(Assets:GetDescendants()) do
	if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
local DEAGLE = Assets.DeagleHandle:Clone()
local DEAGLESHOOT = false
local AK12 = Assets.AKHandle:Clone()
local AKSHOOT = false
local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
local SHOOTING = false
OrgnC0 = Neck.C0
local gunScale = (Torso.Size.y/2) * 1
Dist = nil
Diff = nil

Humanoid.HipHeight = 0.1

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
TAN=math.tan
ATAN=math.atan
ATAN2=math.atan2
CE=math.ceil
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--><

script.Controls.Parent = Player.PlayerGui
Player.PlayerGui.Controls.Enabled =true
Player.PlayerGui.Controls.Main.Position = UDim2.new(0.715, 0,0.725, 0)

Animation_Speed = 3
Animation_Speed2 = 5
Frame_Speed = 1 / 60

local SINE = 0
local CHANGE = 2 / Animation_Speed
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local ANIM = "Idle"
local GUN = "Deagle"
local ATTACK = false
local WALKINGANIM = false
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(1, .50, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(-1, .50, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local RIGHTHIPC0 = CF(1, -1,  0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTHIPC0 = CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))


local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
ROBLOXIDLEANIMATION.Parent = Humanoid

local Effects = IT("Folder", Character)
Effects.Name = "Effects"




-- || ARTIFICIAL HEARTBEAT || -- 


ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

-- || FUNCTIONS || -- 


function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
local NEWWELD = IT(TYPE)
NEWWELD.Part0 = PART0
NEWWELD.Part1 = PART1
NEWWELD.C0 = C0
NEWWELD.C1 = C1
NEWWELD.Parent = PARENT
return NEWWELD
end
local function WeldBetween(a, b)
        local weldd = Instance.new("ManualWeld")
        weldd.Part0 = a
        weldd.Part1 = b
        weldd.C0 = CFrame.new()
        weldd.C1 = b.CFrame:inverse() * a.CFrame
        weldd.Parent = a
        return weldd
   end
local d = CF(0,0,0)
--Humanoid:removeAccessories()
local akhat = gp(gp(gp(cnnnnn, "Police K4LAS [Back]", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local aknnn = gp(gp(cnnnnn, "Police K4LAS [Back]", "Accessory"), "Handle", "BasePart")

local pistolhat = gp(gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local pistolnnn = gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart")

if Head.face then
Head.face.Transparency = 1
end
local Morph = script.Morph
for i,v in pairs(Morph:GetDescendants()) do
	if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
local hw = CreateWeldOrSnapOrMotor("Weld",Head,Morph.hed.Main,Head,d,d)
local lw = CreateWeldOrSnapOrMotor("Weld",LeftArm,Morph.la.Main,LeftArm,d,d)
local rw = CreateWeldOrSnapOrMotor("Weld",RightArm,Morph.ra.Main,RightArm,d,d)
local llw = CreateWeldOrSnapOrMotor("Weld",LeftLeg,Morph.ll.Main,LeftLeg,d,d)
local rlw = CreateWeldOrSnapOrMotor("Weld",RightLeg,Morph.rl.Main,RightLeg,d,d)
local tw = CreateWeldOrSnapOrMotor("Weld",Torso,Morph.tors.Main,Torso,CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(-90)),d)
for i,v in pairs(Morph:GetDescendants()) do
if v:IsA("BasePart") then
v.Anchored = false
end
end
Morph.Parent = Character
function QuaternionSClerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or ROOT.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = NewSound({ID = SOUNDID,PARENT = EFFECT,VOLUME = SOUNDVOLUME,PITCH = SOUNDPITCH,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end
function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "643098245", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end


function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						--local CAMSHAKER = script.CamShake:Clone()
						--CAMSHAKER.Shake.Value = INTENSITY
						--CAMSHAKER.Timer.Value = TIME
						--CAMSHAKER.Parent = CHILD
						--CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

function AttachmentCFrame(A)
	return A.Parent.CFrame*CF(A.Position)
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end


function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = Assets.Blood:Clone()
	BLOOD.Enabled = true
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,0.5)
end

function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end


function Clerp(a, b, t)
    return a:lerp(b,t)
end

function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			--ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			--MANHUM.BreakJointsOnDeath = false
			--MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				--local SCRIPT = script.R15Ragdoll:Clone()
				--SCRIPT.Parent = MAN
				--SCRIPT.Disabled = false
			else
				--local SCRIPT = script.R6Ragdoll:Clone()
				--SCRIPT.Parent = MAN
				--SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		--MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			--local MARK = IT("Folder",MAN)
			--MARK.Name = "Slaughtered"
			--for index, CHILD in pairs(MAN:GetChildren()) do
				--if CHILD:IsA("Script") and CHILD.Name ~= "Respawn" then
					--CHILD:Remove()
				--end
			--end
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					--TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end

if GUN == "Deagle" then
	local DEAGLE1 = DEAGLE:Clone()
	DEAGLE1.Parent = LeftArm
	WeldBetween(LeftArm,DEAGLE1)
	pistolhat.Parent = DEAGLE1
	pistolhat.Rotation = Vector3.new(180, 0, 90)
	pistolhat.Position = Vector3.new(0, 0.25, 0)
	local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",LeftArm,DEAGLE1,LeftArm,CF(-0.9,0,-0.8)*ANGLES(RAD(90),RAD(0),RAD(110)),CF(0,0,0))
end

local SONGS = {172843187,241184313,0,0,0,0}
local CHOICE = MRANDOM(1,2)
local sick = Instance.new("Sound",Torso)
sick.SoundId = "rbxassetid://172843187"
sick.Looped = true
sick.Parent = Torso
sick.Volume = .5
sick.Pitch = 1
sick:Play()

-----------------------------------
--------------------------------->
-----------------------------------

local HOLDINGMOUSE = false
local DEBOUNCE = false

-- || MOVES || -- 

local function DEALGEEQUIP()
	if GUN ~= "Deagle" then
		akhat.Parent = aknnn
		akhat.Rotation = Vector3.new()
		akhat.Position = Vector3.new()
		for i,v in pairs (LeftArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Left Arm" then
				v:Destroy()
			end
		end
		for i,v in pairs (RightArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Right Arm" then
				v:Destroy()
			end
		end
		GUN = "Deagle"
		local DEAGLE1 = DEAGLE:Clone()
		DEAGLE1.Parent = LeftArm
		WeldBetween(LeftArm,DEAGLE1)
		pistolhat.Parent = DEAGLE1
		
		pistolhat.Rotation = Vector3.new(180, 0, 90)
		pistolhat.Position = Vector3.new(0, 0.25, 0)
		local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",LeftArm,DEAGLE1,LeftArm,CF(-0.9,0,-0.8)*ANGLES(RAD(90),RAD(0),RAD(110)),CF(0,0,0))
	end
end


local HOLDINGMOUSE = false
local DEBOUNCE = false
local function DEAGLESHOOOT()
if DEBOUNCE == false then
	DEBOUNCE = true
		repeat
			local DETECTKILL = function(HIT,POS,FORCE)
				if HIT.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
--[[
						HIT.Parent.Humanoid:TakeDamage(50)
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ROOT.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
						BV.Parent = HIT
						Debris:AddItem(BV,0.05)
						OofOuchBlood(POS,ROOT.Position,50) ]]
					else
						--ManSlaughter(HIT.Parent)
						--OofOuchBlood(POS,ROOT.Position,1)
					end
					NewSound({ID = 5138136368,PARENT = HIT,VOLUME = 1,PITCH = MRANDOM(1,3),LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
						--OofOuchBlood(POS,ROOT.Position,50)
					else
						--OofOuchBlood(POS,ROOT.Position,1)
						--ManSlaughter(HIT.Parent.Parent)
					end
				end
			end
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 131205975, SoundPitch = 0.75, SoundVolume = 2.5})
		local HIT,POS = CastProperRay(AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p,mouse.Hit.p,900,Character)
			local DISTANCE = (POS - AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p).Magnitude
			if HIT then
				--DETECTKILL(HIT,POS,50)
			end
			WACKYEFFECT({Time = 8, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.5,0.5,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(LeftArm.DeagleHandle.Flame.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			--WACKYEFFECT({Time = 8, EffectType = "Block", Size = VT(0,0,DISTANCE), Size2 = VT(0.8,0.8,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(mouse.Hit.p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1,0.01 do
			Swait()
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(10), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.3,-0.5) * ANGLES(RAD(145), RAD(0), RAD(20)) * LEFTSHOULDERC0, i)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.3,0) * ANGLES(RAD(135), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, i)
		end
		for i = 1,1,0.01 do
			Swait()
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90), RAD(0), RAD(20)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
		end
		wait(0.5)
		until HOLDINGMOUSE ~= true
	DEBOUNCE = false
	end
end

local function AKEQUIP()
	if GUN ~= "AK12" then
		pistolhat.Parent = pistolnnn
		pistolhat.Rotation = Vector3.new()
		pistolhat.Position = Vector3.new()
		for i,v in pairs (LeftArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Left Arm" then
				v:Destroy()
			end
		end
		for i,v in pairs (RightArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Right Arm" then
				v:Destroy()
			end
		end
		GUN = "AK12"
		local AK121 = AK12:Clone()
		AK121.Parent = RightArm
		WeldBetween(RightArm,AK121)
		akhat.Parent = AK121
		akhat.Rotation = Vector3.new(0, 90, 0)
		akhat.Position = Vector3.new(0.8, 0.4, 0)
		local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",RightArm,AK121,RightArm,CF(-0.9,0,0.6)*ANGLES(RAD(90),RAD(0),RAD(90)),CF(0,0,0))
	end
end

local HOLDINGMOUSE1 = false
local DEBOUNCE1 = false

local function AKSHOOOT()
	if DEBOUNCE1 == false then
		DEBOUNCE1 = true
		repeat
			local DETECTKILL = function(HIT,POS,FORCE)
				if HIT.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
--[[
						HIT.Parent.Humanoid:TakeDamage(10)
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ROOT.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
						BV.Parent = HIT
						Debris:AddItem(BV,0.05)
						OofOuchBlood(POS,ROOT.Position,50) ]]
					else
						--ManSlaughter(HIT.Parent)
						--OofOuchBlood(POS,ROOT.Position,1)
					end
					NewSound({ID = 5138136368,PARENT = HIT,VOLUME = 1,PITCH = MRANDOM(1,3),LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true}) 
				elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
						--OofOuchBlood(POS,ROOT.Position,50)
					else
						--OofOuchBlood(POS,ROOT.Position,1)
						--ManSlaughter(HIT.Parent.Parent)
					end
				end
			end
			WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 153230559, SoundPitch = math.random(1,1.5), SoundVolume = 2.5})
		local HIT,POS = CastProperRay(AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p,mouse.Hit.p,900,Character)
			local DISTANCE = (POS - AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p).Magnitude
			if HIT then
				--DETECTKILL(HIT,POS,25)
			end
			WACKYEFFECT({Time = 9, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.3,0.3,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.AKHandle.Flame.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			for i = 1,1,0.01 do
				Swait()
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(22.5), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(130 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(130 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			end
			for i = 1,1,0.01 do
				Swait()
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			end
			wait(0.1)
		until HOLDINGMOUSE1 ~= true
		DEBOUNCE1 = false
	end
end

local DEBOUNCE2 = false

local function Dash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.lookVector*100
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30),RAD(10),RAD(0)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,-0.5,-2.25) * ANGLES(RAD(-70), RAD(0), RAD(0)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-20), RAD(0), RAD(0)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end

local function LeftDash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.rightVector*-50
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(20)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,1.25,0) * ANGLES(RAD(175 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.85,-0.50,0) * ANGLES(RAD(0), RAD(0), RAD(50)) * RIGHTSHOULDERC0, i / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,-0.25,-1.5) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(20)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end

local function RightDash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.rightVector*50
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(-20)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(-20)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0.25,-1.5) * ANGLES(RAD(-45), RAD(0), RAD(0)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end


-- || MOVE ACTIVATORS || -- 
Mouse.KeyDown:Connect(function(key)
	if key == "x" then
		DEALGEEQUIP()
		HOLDINGMOUSE1 = false
	elseif key == "c" then
		if HOLDINGMOUSE1 ~= true then
			HOLDINGMOUSE = false
			AKEQUIP()
		end
	elseif key == "z" then
		Dash()
	elseif key == "q" then
		LeftDash()
	elseif key == "e" then
		RightDash()
	elseif key:lower() == "1" and ATTACK == false then
		if CHOICE ~= 1 then
			CHOICE = 1
			sick:Play()
		end
    elseif key:lower() == "2" and ATTACK == false then
		if CHOICE ~= 2 then
			CHOICE = 2
			sick:Play()
		end
        elseif key:lower() == "3" and ATTACK == false then
            if CHOICE ~= 3 then
                CHOICE = 3
                sick:Play()
			end
       --[[ elseif key:lower() == "4" and ATTACK == false then
            if CHOICE ~= 4 then
                CHOICE = 4
                sick:Play()
			end
		elseif key:lower() == "5" and ATTACK == false then
            if CHOICE ~= 5 then
                CHOICE = 5
                sick:Play()
			end
		elseif key:lower() == "6" and ATTACK == false then
            if CHOICE ~= 6 then
                CHOICE = 6
                sick:Play() 	
			end]]
	end
end)

Mouse.Button1Down:Connect(function()
	if GUN == "Deagle" then
		HOLDINGMOUSE = true
		DEAGLESHOOOT()
	end
	if GUN == "AK12" then
		HOLDINGMOUSE1 = true
		AKSHOOOT()
	end
end)

Mouse.Button1Up:Connect(function()
	if GUN == "Deagle" then
		HOLDINGMOUSE = false
		HOLDINGMOUSE1 = false
	elseif GUN == "AK12" then
		HOLDINGMOUSE = false
		HOLDINGMOUSE1 = false
	end
end)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if HOLDINGMOUSE == true and GUN == "Deagle" then

			if DEBOUNCE == true then
				GlobalFunctions.fling(Mouse.Hit.p, 0.05)
			end
			
			
			
		end
		if HOLDINGMOUSE1 == true and GUN == "AK12" then


			
			GlobalFunctions.fling(Mouse.Hit.p, 0.01)
			
			
		end
	end
end)


--><
local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local WalkSpeed = 24
local Walking = Humanoid.MoveDirection.magnitude>0

while true do
	local sidevec = math.clamp((ROOT.Velocity*ROOT.CFrame.rightVector).X+(ROOT.Velocity*ROOT.CFrame.rightVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local forwardvec =  math.clamp((ROOT.Velocity*ROOT.CFrame.lookVector).X+(ROOT.Velocity*ROOT.CFrame.lookVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local sidevelocity = sidevec/Humanoid.WalkSpeed
	local forwardvelocity = forwardvec/Humanoid.WalkSpeed
	Swait()
--Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*4.8,0.55*4.8),math.random(-0.55*4.8,0.55*4.8),math.random(-0.55*4.8,0.55*4.8)),0.44)
		--script.Parent = GUI
ANIMATE.Parent = nil
	Humanoid.Parent = Character
	if Humanoid then
		local IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)
		IDLEANIMATION:Play()
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		if ATTACK == false and DEBOUNCE2 == false then
			ANIM = "Idle"
				local _, Point = workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), workspace, false, true)
           	 	Dist = (Head.CFrame.p-Point).magnitude
            	Diff = Head.CFrame.Y-Point.Y
				if GUN == "Deagle" then
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,.05 + .05 * COS(SINE/30)) * ANGLES(RAD(-2 - 3 * COS(SINE/30)), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
					Neck.C0 = Neck.C0:lerp(CF(0,0,0 + .05 * COS(SINE/31)) * ANGLES(RAD(-2 - 5 * COS(SINE/31)), RAD(0), RAD(0)) * NECKC0, 0.15 / Animation_Speed)
					LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(-0 + 5.05 * COS(SINE/30)), RAD(10), RAD(-2)) * LEFTHIPC0, 0.55 / Animation_Speed)
					RightHip.C0 = RightHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(0 + 5.05 * COS(SINE/30)), RAD(-12), RAD(2.1)) * RIGHTHIPC0, 0.55 / Animation_Speed)
				elseif GUN == "AK12" then
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
					Neck.C0 = Neck.C0:lerp(CF(0,0,0 + .05 * COS(SINE/31)) * ANGLES(RAD(-2 - 5 * COS(SINE/31)), RAD(30), RAD(0)) * NECKC0, 0.15 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,.05 + .05 * COS(SINE/30)) * ANGLES(RAD(-2 - 3 * COS(SINE/30)), RAD(-30), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
					LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(-0 + 5.05 * COS(SINE/30)), RAD(10), RAD(-2)) * LEFTHIPC0, 0.15 / Animation_Speed)
					RightHip.C0 = RightHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(0 + 5.05 * COS(SINE/30)), RAD(-12), RAD(2.1)) * RIGHTHIPC0, 0.15 / Animation_Speed)
				end
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		if ATTACK == false and DEBOUNCE2 == false then 
			Change=.5
			ANIM = "Run"
			local _, Point = workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), workspace, false, true)
            Dist = (Head.CFrame.p-Point).magnitude
            Diff = Head.CFrame.Y-Point.Y
            --LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5+.5*COS(SINE/3), -.5) * ANGLES(RAD(90), RAD(0), RAD(70- 25 * SIN(SINE/.02))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.5)*forwardvec, RAD(-0 - 0.5 * COS(SINE/4))*forwardvec, RAD(-sidevec/2)) * ROOTC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.5)*forwardvec, RAD(-0 - 0.5 * COS(SINE/4))*forwardvec, RAD(-sidevec/2)) * ROOTC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.8)*forwardvec, RAD(-0 - 0.7 * COS(SINE/4))*forwardvec, RAD(-sidevec/1.5)) * ROOTC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.8)*forwardvec, RAD(-0 - 0.7 * COS(SINE/4))*forwardvec, RAD(-sidevec/1.5)) * ROOTC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0 + 0.5 * COS(SINE/4.05)) * ANGLES(RAD(20 + 85 * COS(SINE/4.05)*forwardvelocity), RAD(-0 + 10 * COS(SINE/4)), RAD(sidevec*COS(SINE/4.05))) * RIGHTHIPC0, 0.15 / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0 - 1 * SIN(SINE/4.05),0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTHIPC0, 0.15 / Animation_Speed)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,0 - 0.5 * COS(SINE/4.05)) * ANGLES(RAD(20 - 85 * COS(SINE/4.05))*forwardvelocity, RAD(-0 - 10 * COS(SINE/4)), RAD(-sidevec*COS(SINE/4.05))) * LEFTHIPC0, 0.15 / Animation_Speed)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0 + 1 * SIN(SINE/4.05),0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTHIPC0, 0.15 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		if ATTACK == false and DEBOUNCE2 == false then
			ANIM = "Jump"
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
		RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30), RAD(0), RAD(0)) * RIGHTHIPC0, 0.15 / 2)
		LeftHip.C0 = LeftHip.C0:lerp(CF(0,1,-.8) * ANGLES(RAD(-20), RAD(0), RAD(0)) * LEFTHIPC0, 0.15 / 2)
		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(20), RAD(0), RAD(0)) * ROOTC0, 0.15 / 2)
		end
	elseif TORSOVERTICALVELOCITY < -0 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false and DEBOUNCE2 == false then
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30 + 20 * CE(SINE/100000)), RAD(0), RAD(0)) * RIGHTHIPC0, 0.05 / 2)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,1 - .5 * CE(SINE/100000),-.8 + 1 * CE(SINE/100000)) * ANGLES(RAD(-20 + 60 * CE(SINE/100000)), RAD(0), RAD(0)) * LEFTHIPC0, 0.05 / 2)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(20 - 40 * CE(SINE/100000)), RAD(0), RAD(0)) * ROOTC0, 0.05 / 2)
		end
	end
	sick.Parent = Torso
    sick:resume()
    sick.Volume = .5
    sick.Pitch = 1
    sick.SoundId = "rbxassetid://"..SONGS[CHOICE]
end
end)

Section:NewButton("Atlas Axe", "ButtonInfo", function()
    print("Clicked")
script = game:GetObjects("rbxassetid://6438361301")[1].AtlasAxe
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- -gh 5555611932,8527979605

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end


--require(script.EzConvert)()
wait(1/60)

Effects = {}
local Player = game.Players.LocalPlayer
local Character = Player.Character
local Humanoid = Character.Humanoid
local Head = Character.Head
local RootPart = Character.HumanoidRootPart
local Torso = Character.Torso
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Camera = game.Workspace.CurrentCamera
local RootJoint = RootPart.RootJoint
local Mouse = Player:GetMouse()
local Equipped = false
local Attack = false
local Anim = "Idle"
local Idle = 0
local Combo = 1
local TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
local Velocity = RootPart.Velocity.y
local Sine = 0
local Change = 1
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
co1 = 0
co2 = 0
co3 = 0
co4 = 0
coE = 0
cooldown1 = 0
cooldown2 = 0
cooldown3 = 0
cooldown4 = 0
cooldownE = 0
function round(num)
	local a, b = math.modf(num)
	if num % 1 ~= 0 then
		return math.floor(num) + math.floor(b * 10 + 0.5) / 10
	else
		return math.floor(num)
	end
end
local targetnnn = nil
local Guis = script:WaitForChild("Assets").Guis
local gui = Guis.Atlas
gui.Enabled = true
gui.Parent = Player.PlayerGui
local gf = gui:WaitForChild("GenStats")
local AttacksFrame = gf:WaitForChild("Attacks")
local att1 = AttacksFrame.Attack1.Reload
local att2 = AttacksFrame.Attack2.Reload
local att3 = AttacksFrame.Attack3.Reload
local att4 = AttacksFrame.Attack4.Reload
local skillE = AttacksFrame.ESkill.Reload
local NumberNabel = AttacksFrame.ESkill.NumberLabel
local Animator = Humanoid.Animator
local Animate = Character.Animate
local function newMotor(part0, part1, c0, c1)
	local w = Create("Motor")({
		Parent = nil,
		Part0 = part0,
		Part1 = part1,
		C0 = c0,
		C1 = c1
	})
	return w
end
function Lerp(Part, CFrame, Delay)
	return Part:lerp(CFrame, Delay)
end
RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckC0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
NeckC1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
local RShoulder = Torso["Right Shoulder"]
local LShoulder = Torso["Left Shoulder"]
local RHip = Torso["Right Hip"]
local LHip = Torso["Left Hip"]
local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0))
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(0.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-0.5, -2, 0), CFrame.new(0, 0, 0))
local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1
local resetc1 = false
function dabfastman(table, speed, bool)
	RootJoint.C0 = Lerp(RootJoint.C0, table[1], speed)
	Torso.Neck.C0 = Lerp(Torso.Neck.C0, table[2], speed)
	RW.C0 = Lerp(RW.C0, table[3], speed)
	LW.C0 = Lerp(LW.C0, table[4], speed)
	RH.C0 = Lerp(RH.C0, table[5], speed)
	LH.C0 = Lerp(LH.C0, table[6], speed)
	HandleWeld.C0 = Lerp(HandleWeld.C0, table[7], speed)
	FakeHandleWeld.C0 = Lerp(FakeHandleWeld.C0, table[8], speed)
	if bool == true and resetc1 == false then
		resetc1 = true
		RootJoint.C1 = RootJoint.C1
		Torso.Neck.C1 = Torso.Neck.C1
		RW.C1 = rarmc1
		LW.C1 = larmc1
		RH.C1 = rlegc1
		LH.C1 = llegc1
	end
end
function Weld(Part, SecondPart)
	local w = Create("Weld")({
		Parent = SecondPart,
		Part0 = SecondPart,
		Part1 = Part,
		C0 = SecondPart.CFrame:inverse() * Part.CFrame
	})
	return w
end
function WeldModel(Model, Directory)
	local prev = Directory
	local parts = Model:GetChildren()
	for i = 1, #parts do
		if parts[i]:IsA("BasePart") and prev ~= nil then
			local weld = Instance.new("Weld")
			weld.Part0 = prev
			weld.Part1 = parts[i]
			weld.C0 = prev.CFrame:inverse()
			weld.C1 = parts[i].CFrame:inverse()
			weld.Parent = parts[i]
		end
	end
end
ArtificialHB = Create("BindableEvent")({Parent = script, Name = "Heartbeat"})
script:WaitForChild("Heartbeat")
frame = 0.02857142857142857
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
Assets = script.Assets
Models = Assets.Models
Effects = Assets.Effects
Beams = Effects.Beams
Particles = Effects.Particles
Trails = Effects.Trails
Parts = Effects.Parts
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			if Size == Vector3.new() then
				Part.Size = Vector3.new(0.2, 0.2, 0.2)
			else
				Part.Size = Size
			end
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit, tim)
			local S = Create("Sound")({
				Volume = vol,
				Pitch = pit or 1,
				SoundId = "rbxassetid://" .. id,
				Parent = par or workspace
			})
			S:play()
			game:GetService("Debris"):AddItem(S, tim)
		end
	},
	Attachment = {
		Create = function(Name, Parent, Orientation, Position, Axis, SecondaryAxis)
			local Attachment = Create("Attachment")({
				Name = Name,
				Parent = Parent,
				Orientation = Orientation,
				Position = Position,
				Axis = Axis,
				SecondaryAxis = SecondaryAxis
			})
			return Attachment
		end
	},
	CreateTemplate = {}
}
function RayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
function FindNearestTorso(pos)
	local list = game.Workspace:children()
	local torso
	local dist = 1000
	local temp, human, temp2
	for x = 1, #list do
		temp2 = list[x]
		if temp2.className == "Model" and temp2.Name ~= Character.Name then
			temp = temp2:findFirstChild("Torso")
			human = temp2:findFirstChild("Humanoid")
			if temp ~= nil and human ~= nil and human.Health > 0 and dist > (temp.Position - pos).magnitude then
				local doHit = true
				if doHit == true then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso, dist
end
function ShowDamage(CF, Text, Color)
	local StatPart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
	StatPart.CFrame = CFrame.new(CF.p + Vector3.new(0, 1.5, 0))
	local BodyGyro = Instance.new("BodyGyro", StatPart)
	local BodyPosition = Instance.new("BodyPosition", StatPart)
	BodyPosition.P = 2000
	BodyPosition.D = 100
	BodyPosition.maxForce = Vector3.new(math.huge, math.huge, math.huge)
	BodyPosition.position = StatPart.Position + Vector3.new(math.random(-2, 2), 4, math.random(-2, 2))
	game:GetService("Debris"):AddItem(StatPart, 5)
	local BillboardGui = Instance.new("BillboardGui", StatPart)
	BillboardGui.Adornee = StatPart
	BillboardGui.Size = UDim2.new(2.5, 0, 2.5, 0)
	BillboardGui.StudsOffset = Vector3.new(-2, 2, 0)
	BillboardGui.AlwaysOnTop = false
	local TextLabel = Instance.new("TextLabel", BillboardGui)
	TextLabel.Rotation = math.random(-10, 10)
	TextLabel.BackgroundTransparency = 1
	TextLabel.Size = UDim2.new(2.5, 0, 2.5, 0)
	TextLabel.Text = Text
	TextLabel.Font = "SourceSans"
	TextLabel.FontSize = "Size42"
	TextLabel.TextColor3 = Color
	TextLabel.TextStrokeTransparency = 0
	TextLabel.TextTransparency = 1
	TextLabel.TextStrokeTransparency = 1
	TextLabel.TextScaled = true
	TextLabel.TextWrapped = true
	coroutine.resume(coroutine.create(function(ThePart, TheBodyPosition, TheTextLabel)
		for i = 1, 4 do
			swait()
			TheTextLabel.TextTransparency = TheTextLabel.TextTransparency - 0.25
			TheTextLabel.TextStrokeTransparency = TheTextLabel.TextStrokeTransparency - 0.25
		end
		swait(12)
		for i = 1, 5 do
			swait()
			TheTextLabel.TextTransparency = TheTextLabel.TextTransparency + 0.2
			TheTextLabel.TextStrokeTransparency = TheTextLabel.TextStrokeTransparency + 0.2
			TheBodyPosition.position = ThePart.Position + Vector3.new(0, 0.5, 0)
		end
		ThePart.Parent = nil
	end), StatPart, BodyPosition, TextLabel)
end
local BladeHitSounds = {
	"199149137",
	"199149186",
	"199149221",
	"199149235",
	"199149269",
	"199149297"
}
local ClangHitSounds = {
	"199148971",
	"199149025",
	"199149072",
	"199149109",
	"199149119"
}
local ArmorHitSounds = {
	"199149321",
	"199149338",
	"199149367",
	"199149409",
	"199149452"
}
local ShieldHitSounds = {"199148933", "199148947"}
local Sprinting = false
local Charged = false
local Charges = 0
function Damage(Part, Hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if Hit.Parent == nil then
		return
	end
	local h = Hit.Parent:FindFirstChild("Humanoid")
	for _, v in pairs(Hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and Hit.Parent.Name ~= Character.Name and Hit.Parent ~= Character.Model and Hit.Parent:FindFirstChild("Torso") ~= nil then
		if Hit.Parent:findFirstChild("DebounceHit") ~= nil and Hit.Parent.DebounceHit.Value == true then
			return
		end
		local c = Create("ObjectValue")({
			Name = "creator",
			Value = game.Players:GetPlayerFromCharacter(script.Parent) ,
			Parent = h
		})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, Hit.Parent.Torso, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = Hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		if Charged == true then
			if Charges >= 0 then
				Charges = Charges - 1
				CFuncs.Sound.Create("209545844", Hit.Parent.Torso, 1, 1 + math.random(), 5)
				local ecksdee = 25
				for i = 1, 3 do
					Lightning2(Hitbox.Position, Hit.Parent.Torso.Position + Vector3.new(math.random(-ecksdee, ecksdee), 0, math.random(-ecksdee, ecksdee)), 6, 2, "Toothpaste", 0.4, 0.5, 5)
				end
				print(Charges)
			end
			if Charges == 0 then
				cooldownE = 0
				Charges = 0
				Charged = false
			end
		end
		if blocked == false then
			targetnnn = h.Parent
			--h.Health = h.Health - Damage
			ShowDamage(Hit.Parent.Head.CFrame * CFrame.new(0, 0 + (Hit.Parent.Head.Size.z - 2), 0), -Damage, BrickColor.new("Toothpaste").Color)
		else
			targetnnn = h.Parent
			--h.Health = h.Health - Damage / 2
			ShowDamage(Hit.Parent.Head.CFrame * CFrame.new(0, 0 + (Hit.Parent.Head.Size.z - 2), 0), "Blocked!", BrickColor.new("Cyan").Color)
		end
		--[[
		if Type == "Knockdown" then
			local hum = Hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (Hit.Parent.Torso.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity")({
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = Hit
			})
			local rl = Create("BodyAngularVelocity")({
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = Hit
			})
			game:GetService("Debris"):AddItem(bodvol, 0.5)
			game:GetService("Debris"):AddItem(rl, 0.5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity")({
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
			})
			if knockback > 0 then
				vp.Parent = Hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, 0.5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = Hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = Hit.Parent.Torso.Position,
				Parent = Hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition")({
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = Hit.Parent.Torso.Position,
				Parent = Hit.Parent.Torso
			})
			local BodGy = Create("BodyGyro")({
				maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
				P = 20000,
				Parent = Hit.Parent.Torso,
				cf = Hit.Parent.Torso.CFrame
			})
			Hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part)
				swait(1.5)
				Part.Anchored = false
			end), Hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue")({
			Name = "DebounceHit",
			Parent = Hit.Parent,
			Value = true
		})
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue")({
			Name = "creator",
			Value = Player,
			Parent = h
		})
		game:GetService("Debris"):AddItem(c, 0.5)
		]]
	end
end
function MagnitudeDamage(Part, Magnitude, MinimumDamage, MaximumDamage, KnockBack, Type, Delay)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if Magnitude >= mag and c.Name ~= Player.Name then
					if Charged == false then
						Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, Delay, BladeHitSounds[math.random(1, #BladeHitSounds)], 0.9)
					elseif Charged == true then
						Damage(head, head, MinimumDamage + 5, MaximumDamage + 5, KnockBack, "Knockdown", RootPart, Delay, "300916105", 0.9)
						Effects.Ring.Create("Neon", BrickColor.new("Toothpaste"), head.CFrame * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.2, 0.2, 0.1, 3, 3, 0.1, 0.1)
						Effects.Block.Create("Neon", BrickColor.new("Toothpaste"), Hitbox.CFrame, 0.2, 0.2, 0.2, 1, 1, 1, 0.1, 3, head)
						Effects.Sphere.Create("Neon", BrickColor.new("Toothpaste"), Hitbox.CFrame, 0.2, 0.2, 0.2, 1.2, 1.2, 1.2, 0.1, 2, head)
					end
				end
			end
		end
	end
end

for _,v in pairs(Models:GetDescendants()) do
	if  v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
		print(v)

	end
end

WeaponModel = Models.Hammer:Clone()
WeaponModel.Parent = Character
Handle = WeaponModel.Handle
HandlePrt1 = WeaponModel.HandlePrt1
HandlePrt2 = WeaponModel.HandlePrt2
HandlePrt3 = WeaponModel.HandlePrt3
HandlePrt4 = WeaponModel.HandlePrt4
InnerModel = WeaponModel.Hammer2
FakeHandle = InnerModel.FakeHandle
Hitbox = InnerModel.Hitbox
GlassPrt = InnerModel.GlassPrt
NeonPrt = InnerModel.NeonPrt
WeldModel(InnerModel, FakeHandle)
local AxeHat = gp(gp(gp(cnnnnn, "FireaxeAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
AxeHat.Parent = HandlePrt1
AxeHat.Rotation = Vector3.new(120, -1.06722e-06, -95)
AxeHat.Position = Vector3.new(0.5, 0, 0)
spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if Attack == false then


		elseif Attack == true and Equipped == true then


			if targetnnn ~= nil then
				GlobalFunctions.fling(targetnnn)
				wait(0.2)
				targetnnn = nil
			end
		end
	end
end)

Mug = Assets.Models["Dee's Mug"]:Clone()
MugHandle = Mug.MugHandle
WeldModel(Mug, MugHandle)
HandleWeld = CFuncs.Weld.Create(Handle, Character.Torso, Handle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00617980957, 0.959973335, 0.451027453, -1, 0, 0, 0, 1, 1.29999999E-5, 0, 1.29999999E-5, -1))
FakeHandleWeld = CFuncs.Weld.Create(FakeHandle, Handle, FakeHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0, 0, 1, 0, 7.10542736E-15, 0, 1, 6.71229565E-16, 7.10542736E-15, 6.71229565E-16, 1))
HandlePrt1Weld = CFuncs.Weld.Create(HandlePrt1, FakeHandle, HandlePrt1, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.192504406, 9.53674316E-7, 2.98023224E-6, 1, 0, 0, 0, 1, 0, 0, 0, 1))
HandlePrt2Weld = CFuncs.Weld.Create(HandlePrt2, HandlePrt1, HandlePrt2, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.90474319, 7.77006149E-4, -2.98023224E-6, 1, 0, 0, 0, 1, 0, 0, 0, 1))
HandlePrt3Weld = CFuncs.Weld.Create(HandlePrt3, HandlePrt1, HandlePrt3, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.53274775, 7.78913498E-4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1))
HandlePrt4Weld = CFuncs.Weld.Create(HandlePrt4, HandlePrt1, HandlePrt4, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.76284456, 7.76052475E-4, -1.90734863E-6, 1, 0, 0, 0, 1, 0, 0, 0, 1))
MugHandleWeld = CFuncs.Weld.Create(MugHandle, Character["Left Arm"], MugHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0174064636, -0.153030396, -0.802868128, -1, 0, 0, 0, 0, -1, 0, -1, 0))
local CupHat = gp(gp(gp(cnnnnn, "Morning Coffee", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local CupHatHandle = gp(gp(cnnnnn, "Morning Coffee", "Accessory"), "Handle", "BasePart")

GlassPrt.Transparency = 1
NeonPrt.Transparency = 1
A1 = CFuncs.Attachment.Create("ParticleAttachment", Hitbox, Vector3.new(0, 180, 0), Vector3.new(0.391, 0.05, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 1, 0))
A2 = CFuncs.Attachment.Create("TrailAttachment1", Hitbox, Vector3.new(0, 180, 0), Vector3.new(1.341, 0.65, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 1, 0))
A3 = CFuncs.Attachment.Create("TrailAttachment2", Hitbox, Vector3.new(0, 180, 0), Vector3.new(-1.459, 0.65, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 1, 0))
Smoke = Particles.Smoke
Smoke2 = Particles.Smoke2
Sparkle = Particles.Sparkle
Wave = Particles.Wave
Wave2 = Particles.Wave2
Wave3 = Particles.Wave3
Wave4 = Particles.Wave4
ChargeBits = Particles.ChargeBits
ChargeBits2 = Particles.ChargeBits2
ChargeWave = Particles.ChargeWave
ChargeWave2 = Particles.ChargeWave2
ChargeWave3 = Particles.ChargeWave3
ChargeWave4 = Particles.ChargeWave4
Glow = Particles.Glow
Smoke.Parent = A1
Smoke2.Parent = A1
Sparkle.Parent = A1
Wave.Parent = A1
Wave2.Parent = A1
Wave3.Parent = A1
Wave4.Parent = A1
ChargeBits.Parent = A1
ChargeBits2.Parent = A1
ChargeWave.Parent = A1
ChargeWave2.Parent = A1
ChargeWave3.Parent = A1
ChargeWave4.Parent = A1
Glow.Parent = A1
Trail = Trails.Trail
Trail.Parent = Hitbox
Trail.Attachment0 = A2
Trail.Attachment1 = A3
EffectModel = Create("Model")({
	Parent = Character,
	Name = "EffectModel"
})
Effects = {
	Block = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay, Type, Part)
			local prt =  Assets.Effects.Parts.Block:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.CFrame = CF
			prt.Anchored = true
			prt.Size = Vector3.new(x1, y1, z1)
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			elseif Type == 3 then
				table.insert(Effects, {
					prt,
					"Block3",
					delay,
					x3,
					y3,
					z3,
					prt,
					Part
				})
			elseif Type == 4 then
				table.insert(Effects, {
					prt,
					"Block2Fire",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			end
		end
	},
	Sphere = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay, Type, Part)
			local prt =  Assets.Effects.Parts.Sphere:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.CFrame = CF
			prt.Size = Vector3.new(x1, y1, z1)
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 then
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block3",
					delay,
					x3,
					y3,
					z3,
					prt,
					Part
				})
			end
		end
	},
	Blood = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay)
			local prt =  Assets.Effects.Parts.Sphere:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.CFrame = CF
			prt.Size = Vector3.new(x1, y1, z1)
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Blood",
				delay,
				x3,
				y3,
				z3,
				prt
			})
		end
	},
	Blast = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay, Part)
			local prt =  Assets.Effects.Parts.Blast:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Block4",
				delay,
				x3,
				y3,
				z3,
				prt,
				Part
			})
		end
	},
	Ring = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay)
			local prt =  Assets.Effects.Parts.Ring:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				prt
			})
		end
	},
	Cylinder = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay, Type)
			local prt =  Assets.Effects.Parts.Cylinder:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Cylinder2",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			end
		end
	},
	Head = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay)
			local prt =  Assets.Effects.Parts.Head:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				prt
			})
		end
	},
	Wave = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay, type, Part)
			local prt =  Assets.Effects.Parts.Wave:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			if type == 1 then
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					prt
				})
			elseif type == 2 then
				table.insert(Effects, {
					prt,
					"Block4",
					delay,
					x3,
					y3,
					z3,
					prt,
					Part
				})
			end
		end
	},
	Break = {
		Create = function(Material, Color, CF, x1, y1, z1)
			local prt =  Assets.Effects.Parts.Sphere:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			local num = math.random(10, 50) / 1000
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end
	},
	Elec = {
		Create = function(Material, Color, CF, x, y, z)
			local prt =  Assets.Effects.Parts.Block:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(xval, yval, zval)
			prt.CFrame = CF * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 9
			yval = math.random() / 9
			zval = math.random() / 9
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				0.05,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				prt,
				euld,
				euld2
			})
		end
	},
	Elec2 = {
		Create = function(Material, Color, CF, x, y, z)
			local prt =  Assets.Effects.Parts.Block:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(xval, yval, zval)
			prt.CFrame = CF * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.CFrame = CFrame.new(prt.Position)
			prt.Anchored = true
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 7
			yval = math.random() / 7
			zval = math.random() / 7
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				0.1,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				prt,
				euld,
				euld2
			})
		end
	},
	Feather = {
		Create = function(Material, Color, CF, x1, y1, z1, x3, y3, z3, delay)
			local prt =  Assets.Effects.Parts.Crescent:Clone()
			prt.Parent = EffectModel
			prt.Material = Material
			prt.BrickColor = Color
			prt.Size = Vector3.new(x1, y1, z1)
			prt.CFrame = CF
			prt.Anchored = true
			table.insert(Effects, {
				prt,
				"Cylinder2",
				delay,
				x3,
				y3,
				z3,
				prt
			})
		end
	},
	EffectTemplate = {}
}
local HotChocolate = false
function CamShake(Part, Distan, Power, Times)
	local de = Part.Position
	for i, v in pairs(workspace:children()) do
		if v:IsA("Model") and v:findFirstChild("Humanoid") then
			for _, c in pairs(v:children()) do
				if c.ClassName == "Part" and Distan > (c.Position - de).magnitude then
					local Noob = v.Humanoid
					if Noob ~= nil and Noob:FindFirstChild("CamShake") == nil then
						--local ss = Assets.CamShake:clone()
						--ss.Parent = Noob
						--ss.Power.Value = Power
						--ss.Times.Value = Times
						--ss.Disabled = false
					end
				end
			end
		end
	end
end
function Disappear()
	coroutine.resume(coroutine.create(function(Part)
		for i = 0, 1, 0.1 do
			swait()
			--GlassPrt.Transparency = i
			--NeonPrt.Transparency = i
		end
		--GlassPrt.Transparency = 1
		--NeonPrt.Transparency = 1
	end))
end
function Appear()
	--GlassPrt.Transparency = 0.8
	coroutine.resume(coroutine.create(function(Part)
		for i = 0, 1, 0.1 do
			swait()
			--NeonPrt.Transparency = -i
		end
		--NeonPrt.Transparency = 0
	end))
end
Equip = {
	Equip = function()
		Attack = true
		Animate.Parent = nil
		Animator.Parent = nil
		RShoulder.Parent, LShoulder.Parent, RHip.Parent, LHip.Parent = nil, nil, nil, nil
		RW.Parent, LW.Parent, RH.Parent, LH.Parent = Torso, Torso, Torso, Torso
		RootJoint.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
		RootJoint.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
		Torso.Neck.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
		Torso.Neck.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(0, 0, 0)
		CFuncs.Sound.Create("1132378728", RightArm, 1, 0.8, 5)
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(0.00438702106, -0.0857315063, 0.444346547, 0.906307876, -6.11343504E-30, -0.422617942, 1.51827618E-29, 1, 1.80939388E-29, 0.422617942, -2.2815189E-29, 0.906307876) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0684240013, 1.47586977, -0.118513867, 0.866025507, 0.0868244767, -0.492403626, 0, 0.984807611, 0.173649028, 0.499999881, -0.150384456, 0.852868557) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.59531188, 0.0694129765, 0.845953524, 0.035232693, 0.498054087, -0.866429865, 0.334641963, 0.811039925, 0.47982201, 0.941686392, -0.306849211, -0.138094693) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.68157625, 0.141814098, 0.0690723956, 0.901943445, 0.394367933, 0.175988182, -0.349303007, 0.905836403, -0.2396826, -0.253939658, 0.15470694, 0.954767168) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.820333183, -1.99400401, 0.0444126427, 0.905676425, -0.0521400981, 0.420751244, 0.0574730001, 0.998347104, 4.68943153E-6, -0.420056045, 0.0241775904, 0.907175958) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.730562687, -1.98583698, 0.0150001049, 0.890379369, 0.0593397431, 0.451335132, -0.0664970055, 0.997786701, -1.85146189E-6, -0.450336218, -0.0300107878, 0.892354548) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.999999881, 0, 0, 0, 1, 0, 0, 0, 0.999999881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.999999881, 0, 0, 0, 1, 0, 0, 0, 0.999999881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.25, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.25)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.25)
		end
		CFuncs.Sound.Create("1132378960", Handle, 1, 1, 5)
		CFuncs.Sound.Create("1132378630", Handle, 2, 1, 5)
		Humanoid.WalkSpeed = 4
		HandleWeld.Part0 = RightArm
		AxeHat.Parent = HandlePrt1
		AxeHat.Rotation = Vector3.new(120, -1.06722e-06, -95)
		AxeHat.Position = Vector3.new(0.5, 0, 0)
		HandleWeld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		HandleWeld.C1 = CFrame.new(0.0102958679, 0.960311174, 0.015463829, 8.87080063E-8, 1.81498508E-5, -1, -4.11480734E-8, 1, 1.81498508E-5, 1, 4.1146464E-8, 8.87087452E-8)
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(-0.0181793608, -0.0999999046, 0.156361789, 0.984807849, -6.11343504E-30, -0.173647985, 9.98237025E-30, 1, 2.14069912E-29, 0.173647985, -2.2815189E-29, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.34110451E-7, 1.49999988, 1.93715096E-7, 0.942855477, 0.0674312413, -0.326307893, -0.0156480055, 0.987188756, 0.158787325, 0.33283475, -0.14460741, 0.931831479) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.68754506, 0.0974979699, 0.570059299, 0.0871559307, -0.340719432, -0.936116636, 0.640341997, 0.739006877, -0.209358931, 0.763129234, -0.581187963, 0.28258577) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.61811745, 0.102885678, -0.102297291, 0.958333313, 0.254887104, -0.128957435, -0.27245295, 0.95125103, -0.144537017, 0.0858302861, 0.17364946, 0.981060326) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.647160053, -1.98692703, -0.0259482116, 0.984306216, -0.0314291455, 0.173647985, 0.0319139883, 0.999490619, 0, -0.173559532, 0.00554179959, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.618272245, -1.95019007, -0.0718374848, 0.965490282, 0.0290115047, 0.258818477, -0.0300350115, 0.999548852, 3.49535696E-7, -0.258701742, -0.00777395302, 0.965926051) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, -1.49011612E-8, 0, -1.49011612E-8, 1.00000012, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0724603161, 0.0135632623, -0.0161543228, -0.950796604, 0.126985326, 0.28259635, 0.2750265, 0.765900433, 0.581168771, -0.14264074, 0.630294621, -0.763139844) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.25, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.25)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.25)
		end
		Humanoid.WalkSpeed = 0
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.0260905847, -9.37857165E-31, -0.0341156088, 0.963866234, -6.11343504E-30, 0.266387016, -1.85137163E-31, 1, 2.36193295E-29, -0.266387045, -2.2815189E-29, 0.963866234) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(3.35276127E-8, 1.50000012, -1.1920929E-7, 0.961998701, -0.0373823382, -0.270483464, 0, 0.990584373, -0.136904314, 0.273054451, 0.131701782, 0.952940762) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.64048052, 1.08139253, -0.508694291, 0.971551001, -0.206575915, 0.115824893, 0, -0.489060938, -0.872249663, 0.236831188, 0.847434878, -0.475147635) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.64097118, 0.254281759, 0.167096317, 0.897742391, 0.411827356, 0.156386808, -0.421996087, 0.905840278, 0.0370490551, -0.12640366, -0.0992551222, 0.987000883) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.633203983, -1.99720943, -0.0216619521, 0.941378117, -0.0217881631, -0.336649239, 0.0222620014, 0.999749243, -0.00245280471, 0.336618215, -0.00518546905, 0.941627026) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.64401269, -1.99565816, -0.022330787, 0.999557972, 0.0294323638, -0.00421100855, -0.0294510145, 0.999556363, -0.00443918398, 0.00407844782, 0.00456123985, 0.999981403) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 0, 9.31322575E-10, 0, 1.00000012, 0, 9.31322575E-10, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.113637097, -0.0312026143, 3.51471954E-6, 0.883229196, 0.468941927, 1.01933256E-5, -0.468941927, 0.883229077, 2.75056809E-5, 3.89653724E-6, -2.90740281E-5, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		end
		CamShake(RootPart, 15, 0.8, 12)
		Appear()
		Smoke:Emit(15)
		Sparkle:Emit(1)
		Wave:Emit(1)
		Wave2:Emit(5)
		local hitfloor2, posfloor2 = RayCast(Handle.Position, CFrame.new(Handle.Position, Handle.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2)
		game:GetService("Debris"):AddItem(ref2, 1)
		CFuncs.Sound.Create("199145534", Handle, 1, 0.9, 5)
		CFuncs.Sound.Create("824687369", Handle, 3, 0.9, 5)
		CFuncs.Sound.Create("824695253", Handle, 2, 0.9, 5)
		CFuncs.Sound.Create("822968467", Hitbox, 1, 1, 5)
		CFuncs.Sound.Create("200633077", Hitbox, 1, 1.2, 5)
		CFuncs.Sound.Create("278596476", Hitbox, 2, 0.9, 5)
		for i = 1, 3 do
			Effects.Feather.Create("Neon", BrickColor.new("Toothpaste"), Hitbox.CFrame * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.2, 0.02, 0.2, 2, 0.01, 2, 0.1)
		end
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 4, 0.2, 4, 0.1, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.1, 0.1, 3, 0.7, 3, 0.1, 1, ref2)
		Effects.Sphere.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 2, 0.4, 2, 0.1, 1, ref2)
		for i = 0, 1, 0.08 do
			swait()
			dabfastman({
				CFrame.new(-0.0260887463, -0.768541336, -0.0341161154, 0.963866234, -6.11343504E-30, 0.266387016, -1.85137163E-31, 1, 2.36193295E-29, -0.266387045, -2.2815189E-29, 0.963866234) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0445477292, 1.54431498, -0.157516822, 0.962090313, 0.0705334172, -0.263453066, 0.00216900022, 0.963970244, 0.266001433, 0.27272287, -0.25648883, 0.927273452) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.49130428, 0.573112845, -0.909861922, 0.97063607, -0.240362853, -0.00957315788, -0.0140609983, -0.0169630088, -0.99975723, 0.240142092, 0.97053504, -0.0198446494) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.62459767, 0.467496008, 0.0878586918, 0.820376396, 0.550023794, 0.15638566, -0.56135565, 0.826745033, 0.0370463766, -0.108914748, -0.118179992, 0.987001121) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.723542333, -1.29914653, -0.598597169, 0.941378117, -0.0217881631, -0.336649239, 0.0222620014, 0.999749243, -0.00245280471, 0.336618215, -0.00518546905, 0.941627026) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.628989816, -1.43291903, 0.361597478, 0.999557853, 0.0184034109, 0.0233588815, -0.0294579882, 0.505308747, 0.862435758, 0.00406828523, -0.862742424, 0.505627394) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 0, 9.31322575E-10, 0, 1.00000012, -1.86264515E-9, 9.31322575E-10, -1.86264515E-9, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.436816901, 0.0413637385, -0.00122102071, 0.99930203, 0.0346196145, 0.014040851, -0.0346382186, 0.999399364, 0.00108350627, -0.013994907, -0.00156910531, 0.999900877) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.5, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.5)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.5)
		end
		Humanoid.WalkSpeed = 16
		Attack = false
		Equipped = true
	end,
	Unequip = function()
		Attack = true
		Humanoid.WalkSpeed = 5
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(-0.0563021079, -8.55646664E-30, -0.359947383, 0.995815516, -6.11343504E-30, 0.0913859531, 4.00286559E-30, 1, 2.32784008E-29, -0.0913859531, -2.2815189E-29, 0.995815516) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0317567252, 1.49999976, -0.0219708979, 0.822355807, 0.060495168, -0.565748394, 0, 0.994331658, 0.106323346, 0.568973541, -0.087435618, 0.817694366) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.66843605, 0.302004129, 0.232172459, 0.494170129, -0.841350675, -0.218917593, 0.441748202, 0.459891915, -0.770297408, 0.748768687, 0.283951432, 0.598929942) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.60288143, 0.144510865, -0.0723012537, 0.94148612, 0.296302497, -0.16065082, -0.307336122, 0.950376272, -0.0482650511, 0.138377666, 0.0948146731, 0.985830545) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.680147231, -1.99361694, -0.0319533348, 0.978258669, -0.0385481045, -0.203774542, 0.0413599946, 0.999098659, 0.00955673121, 0.203222454, -0.0177770685, 0.978971303) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.64950037, -2, -0.0756407157, 0.992064357, 0.0327638276, 0.121387169, -0.0324080102, 0.999462664, -0.00490491278, -0.121482641, 9.32072289E-4, 0.992593169) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.615874767, 1.76220739, -0.0322588943, 0.343129992, 0.592527151, 0.728816509, -0.93928802, 0.216463387, 0.266236454, -9.74535942E-6, -0.775922298, 0.630828738) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
		CFuncs.Sound.Create("200633029", Hitbox, 1, 1.1, 5)
		CFuncs.Sound.Create("1132378960", Handle, 1, 0.6, 5)
		CFuncs.Sound.Create("1132378630", Handle, 2, 0.8, 5)
		Disappear()
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(-0.0563021079, -8.55646664E-30, -0.359947383, 0.995815516, -6.11343504E-30, 0.0913859531, 4.00286559E-30, 1, 2.32784008E-29, -0.0913859531, -2.2815189E-29, 0.995815516) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0317567252, 1.49999976, -0.0219708979, 0.822355807, 0.060495168, -0.565748394, 0, 0.994331658, 0.106323346, 0.568973541, -0.087435618, 0.817694366) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.66843605, 0.302004129, 0.232172459, 0.494170129, -0.841350675, -0.218917593, 0.441748202, 0.459891915, -0.770297408, 0.748768687, 0.283951432, 0.598929942) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.60288143, 0.144510865, -0.0723012537, 0.94148612, 0.296302497, -0.16065082, -0.307336122, 0.950376272, -0.0482650511, 0.138377666, 0.0948146731, 0.985830545) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.680147231, -1.99361694, -0.0319533348, 0.978258669, -0.0385481045, -0.203774542, 0.0413599946, 0.999098659, 0.00955673121, 0.203222454, -0.0177770685, 0.978971303) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.64950037, -2, -0.0756407157, 0.992064357, 0.0327638276, 0.121387169, -0.0324080102, 0.999462664, -0.00490491278, -0.121482641, 9.32072289E-4, 0.992593169) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.615874767, 1.76220739, -0.0322588943, 0.343129992, 0.592527151, 0.728816509, -0.93928802, 0.216463387, 0.266236454, -9.74535942E-6, -0.775922298, 0.630828738) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.5)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.5)
		end
		CFuncs.Sound.Create("1132378728", RightArm, 1, 0.8, 5)
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.145560831, -1.14713136E-30, -0.0112755867, 0.988049626, -6.11343504E-30, -0.154135928, 9.55701809E-30, 1, 2.16002387E-29, 0.154135942, -2.2815189E-29, 0.988049626) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-4.84287739E-8, 1.50000036, 1.78813934E-7, 0.976130307, 0.015721539, -0.21661596, 0, 0.997376621, 0.0723875612, 0.217185721, -0.0706596896, 0.973569512) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.14831018, 0.0852671415, 0.794371665, -0.204826787, -0.0756526217, 0.975870132, -0.346486986, 0.9380548, -3.60545118E-6, -0.9154194, -0.338127106, -0.218351394) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.60564482, 0.0384459235, -0.175445795, 0.974547505, 0.201915562, -0.097402513, -0.217276067, 0.957724035, -0.188562423, 0.0552110672, 0.204926282, 0.977218926) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.62239188, -2, -0.0187949017, 0.988442421, 0, 0.151597157, 0, 1, 0, -0.151597142, 0, 0.988442421) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.607923388, -2.00405931, 0.0275797471, 0.967212379, 0.0563355759, 0.2476421, -0.0581489839, 0.998307884, 8.69902306E-6, -0.247222558, -0.0144085456, 0.968851626) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.02298558, 0.043397665, 0.587206006, 0.980978966, -0.00217291433, -0.194102302, 0.072403267, 0.931872189, 0.355488896, 0.180106044, -0.36278069, 0.914304256) * CFrame.new(-1, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
		Humanoid.WalkSpeed = 16
		Animate.Parent = Character
		Animator.Parent = Humanoid
		RW.Parent, LW.Parent, RH.Parent, LH.Parent = nil, nil, nil, nil
		RShoulder.Parent, LShoulder.Parent, RHip.Parent, LHip.Parent = Torso, Torso, Torso, Torso
		RootJoint.C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		RootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		Torso.Neck.C0 = NeckC0
		Torso.Neck.C1 = NeckC1
		FakeHandleWeld.C0 = CFrame.new()
		HandleWeld.Part0 = Torso
		AxeHat.Parent = HandlePrt1
		AxeHat.Rotation = Vector3.new(120, -1.06722e-06, -95)
		AxeHat.Position = Vector3.new(0.5, 0, 0)
		HandleWeld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.Angles(0, 0, 0)
		HandleWeld.C1 = CFrame.new(-0.00617980957, 0.959973335, 0.451027453, -1, 0, 0, 0, 1, 1.29999999E-5, 0, 1.29999999E-5, -1) * CFrame.Angles(0, 0, 0)
		Attack = false
		Equipped = false
	end
}
ClickCombo = {
	["1"] = function()
		Attack = true
		Humanoid.WalkSpeed = 10
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(-0.0665549561, -0.184942499, 0.260904461, 0.842577159, -1.9774717E-7, -0.538575768, -0.0577830151, 0.994227886, -0.0903992504, 0.535467088, 0.10728886, 0.837713718) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.024227526, 1.51099086, -0.0975070521, 0.969676435, -0.0517281033, 0.238855511, 0.028536763, 0.994623184, 0.0995519683, -0.242720783, -0.0897170454, 0.965938687) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.69279671, 1.20368886, -0.41858381, 0.656214595, -0.550312281, -0.516274154, -0.743745148, -0.587208569, -0.319420338, -0.127379656, 0.593584776, -0.794626892) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.29748428, 0.524334848, -0.785402477, 0.445712447, -0.00549083948, -0.895159483, -0.890980363, 0.0939857587, -0.444208115, 0.0865713432, 0.9955585, 0.0369983912) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.934148014, -1.86132014, 0.233382672, 0.855251253, -0.179025233, 0.486308008, 0.0711145476, 0.970099032, 0.232057452, -0.513311028, -0.163883865, 0.84240967) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.844822466, -1.95213306, -0.0881804228, 0.697618008, -0.00135508412, 0.716468692, -0.0982789025, 0.990364671, 0.0975662544, -0.709697366, -0.138477728, 0.690763116) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.99999994, 0, -1.49011612E-8, 0, 1.00000024, -9.31322575E-9, -1.49011612E-8, -9.31322575E-9, 0.99999994) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.47747862, 1.28062272, -0.455777705, 0.729630232, 0.670418918, -0.134827092, -0.659259439, 0.741983056, 0.121813573, 0.181705534, 7.12275505E-6, 0.983352959) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
		end
		RootPart.Velocity = RootPart.CFrame.lookVector * 40
		Humanoid.WalkSpeed = 5
		Trail.Enabled = true
		CFuncs.Sound.Create("234365549", Hitbox, 1, 0.6, 5)
		CFuncs.Sound.Create("203691447", Hitbox, 1, 0.96, 5)
		CamShake(RootPart, 5, 0.3, 5)
		for i = 0, 1, 0.11 do
			swait()
			MagnitudeDamage(Hitbox, 7, 5, 10, math.random(1, 5), "Normal", 0.3)
			dabfastman({
				CFrame.new(0.0161325932, -0.602928936, -0.949280977, 0.438432008, -0.194854885, 0.877387583, -0.443948001, 0.801855743, 0.399921924, -0.781464994, -0.564853013, 0.265053809) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.47223473E-5, 1.50001645, -1.76280737E-5, 0.44463551, -0.272446513, -0.853271484, -0.074146986, 0.938153505, -0.338186622, 0.892637491, 0.213637307, 0.396935314) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.708687305, 0.761763871, -1.38039231, 0.552033722, 0.592411399, -0.58677727, -0.813777447, 0.229406357, -0.533984005, -0.181727752, 0.772283435, 0.608731031) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.56217611, 0.344860077, 0.28979665, 0.303951502, 0.674820244, 0.672481358, 0.370265543, 0.566708088, -0.736033559, -0.877791107, 0.472715139, -0.0776108801) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.20208561, -0.855071068, -0.642530799, 0.655695736, -0.456514388, -0.601379931, 0.0721468776, 0.830742002, -0.551962554, 0.751570284, 0.318531841, 0.57765007) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.399105519, -1.90095735, -0.266068459, 0.93827045, 0.040555805, -0.343516767, -0.030138284, 0.998911023, 0.035613507, 0.344587058, -0.0230621099, 0.938471079) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, -2.98023224E-8, -3.7252903E-9, -2.98023224E-8, 1, -1.86264515E-9, -3.7252903E-9, -1.86264515E-9, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.03958654, -0.0043371506, -0.30864197, 0.979702353, 0.167458206, -0.110187747, -0.119968176, 0.930171847, 0.346969754, 0.160596475, -0.326708049, 0.931381106) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.35, false)
		end
		Humanoid.WalkSpeed = 16
		Trail.Enabled = false
		Attack = false
	end,
	["2"] = function()
		Attack = true
		Humanoid.WalkSpeed = 10
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(-0.0340179801, -0.65971595, 0.112671107, 0.23382397, -3.48424822E-9, 0.972279012, -0.229029968, 0.971859872, 0.0550795682, -0.944918871, -0.235559955, 0.227244139) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0266713575, 1.51750851, -0.0480759218, 0.763152361, 0.0653594136, -0.642904997, 0.0264164284, 0.990885377, 0.132093325, 0.64567858, -0.117790572, 0.754469872) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.970878959, 0.501977801, -0.665212989, 0.160206035, 0.215078026, 0.963366866, 0.985827506, 0.0143594239, -0.16714704, -0.049783051, 0.976491392, -0.209729388) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.45606375, 0.408450752, -0.856636822, 0.277140737, 0.077929005, 0.957663894, 0.935174048, -0.250663549, -0.250234842, 0.22055085, 0.96493274, -0.142346263) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.794200659, -1.39497304, -0.452756345, 0.917407572, -0.159488022, -0.364591539, 0.14066112, 0.986995161, -0.0778140724, 0.372260511, 0.0201033596, 0.927910686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.81090641, -1.78941345, -0.0892592072, 0.954557538, 0.16277808, -0.249646366, -0.117167234, 0.9751845, 0.187848955, 0.274028957, -0.150062248, 0.949941874) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 9.31322575E-10, 2.98023224E-8, 9.31322575E-10, 1.00000024, -9.31322575E-10, 2.98023224E-8, -9.31322575E-10, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.16085732, -0.25967291, 0.177137613, 0.971839309, 0.233326152, 0.0329749286, -0.233192012, 0.972398639, -0.0079106465, -0.0339105129, -1.60932541E-6, 0.999424875) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
		end
		Trail.Enabled = true
		CFuncs.Sound.Create("822966419", Torso, 1, 0.6, 5)
		CFuncs.Sound.Create("199145433", Torso, 1, 0.9, 5)
		Humanoid.WalkSpeed = 5
		CamShake(RootPart, 5, 0.32, 6)
		for i = 0, 1, 0.11 do
			swait()
			RootPart.Velocity = RootPart.CFrame.lookVector * 60
			MagnitudeDamage(Hitbox, 7, 5, 10, math.random(1, 5), "Normal", 0.3)
			dabfastman({
				CFrame.new(-0.0340159237, -0.455236256, -1.52985823, 0.233824104, -5.57480249E-8, 0.972278953, -0.39965418, 0.911613345, 0.0961131901, -0.886342406, -0.411048889, 0.213157147) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.123362988, 1.48799706, -0.00907865912, 0.252159953, -0.180140644, -0.950770676, -0.00342359021, 0.982348084, -0.187031507, 0.96767956, 0.0504169129, 0.247092128) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.02185225, 0.729695082, -0.554418266, -0.0470581353, 0.500806987, 0.864278853, 0.998882771, 0.0273512974, 0.0385382771, -0.00433889776, 0.865126848, -0.501534581) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.44783199, 0.261507213, -0.542955756, 0.277140468, 0.077928558, 0.957664013, 0.935174167, -0.250663251, -0.250234723, 0.220550716, 0.96493274, -0.142345712) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.756569862, -1.56914091, -0.421967208, 0.855612636, 0.208123505, -0.473932147, -0.094945401, 0.963173389, 0.251560271, 0.508834362, -0.170240447, 0.843863726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.07984817, -1.80126035, 0.171072051, 0.693185568, 0.428673118, -0.579424918, -0.120373592, 0.86147207, 0.49333179, 0.710636437, -0.272223055, 0.648760855) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.999999881, -1.49011612E-8, -2.98023224E-8, -1.49011612E-8, 1.00000012, 7.4505806E-9, -2.98023224E-8, 7.4505806E-9, 0.999999881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0250184089, 0.101048745, 0.260947466, 0.824333131, 0.533173084, 0.190265998, -0.529878974, 0.844996631, -0.0721757412, -0.199256286, -0.0413210914, 0.979075789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.32, false)
		end
		Trail.Enabled = false
		Humanoid.WalkSpeed = 16
		Attack = false
	end,
	["3"] = function()
		Attack = true
		Humanoid.WalkSpeed = 10
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-9.95263457E-4, -0.356713831, -0.343811631, 0.421647161, -0.149692878, 0.89431864, -0.210404068, 0.943208396, 0.257076025, -0.882011294, -0.296563625, 0.366205156) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.012703497, 1.5224067, -0.0916073471, 0.923252702, 0.0225188136, -0.383533001, 0.020732522, 0.993905962, 0.108264297, 0.383633703, -0.107906908, 0.917159438) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.03113949, 0.375998408, -1.21733522, -0.359196663, 0.313398093, 0.879067481, 0.900514066, 0.363721043, 0.238288999, -0.245056003, 0.877205193, -0.412866741) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.52890682, 0.0435836539, -0.473066777, -0.169298112, 0.268664032, 0.948239446, 0.707798004, 0.702662528, -0.0727150142, -0.68582809, 0.658851504, -0.309119314) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.981677651, -1.46450436, -0.506846607, 0.83675158, -0.239640921, -0.49236089, 0.152971447, 0.965653658, -0.210030973, 0.525782049, 0.100426599, 0.844670296) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.705997229, -1.96887791, 0.069483012, 0.900152147, 0.108244538, -0.421911538, -0.0456059575, 0.986727178, 0.155851543, 0.433181643, -0.121048391, 0.89314115) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 9.31322575E-10, 0, 9.31322575E-10, 0.999999881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.52258325, -0.210853919, 0.0413353071, 0.992684484, 0.0894600749, 0.0810836852, -0.0965465009, 0.991416812, 0.0881555155, -0.0725013316, -0.0953389108, 0.99280113) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.25, false)
		end
		RootPart.Velocity = RootPart.CFrame.lookVector * 30
		Trail.Enabled = true
		CFuncs.Sound.Create("203691467", Hitbox, 1, 0.9, 5)
		CFuncs.Sound.Create("234365549", Hitbox, 1, 0.6, 5)
		Humanoid.WalkSpeed = 5
		CamShake(RootPart, 5, 0.25, 5)
		for i = 0, 1, 0.1 do
			swait()
			MagnitudeDamage(Hitbox, 7, 5, 10, math.random(1, 5), "Normal", 0.3)
			dabfastman({
				CFrame.new(0.0827158391, -0.431660205, -0.221472621, 0.396513045, -0.0640119016, -0.915794671, -0.198106036, 0.968095839, -0.153441906, 0.89639914, 0.242266163, 0.371181518) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(9.92417336E-6, 1.50000167, 6.92158937E-6, 0.359398037, -0.180999383, 0.915462852, -0.0307139941, 0.978183806, 0.20545803, -0.932678878, -0.101958729, 0.345998108) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.71579444, 0.850375116, 0.625552297, 0.158359349, -0.986507654, -0.0415334105, 0.98158896, 0.161840707, -0.101443961, 0.106797077, -0.0247041881, 0.993973851) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.329022169, 0.358067065, -1.52914762, 0.32024318, -0.740332365, 0.591060281, 0.91105336, 0.069664821, -0.406360328, 0.259665638, 0.66862154, 0.696791887) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.07205665, -1.61642611, 0.439670354, 0.938681126, -0.253307045, 0.233909011, 0.106574625, 0.858359516, 0.501857281, -0.327902049, -0.446155131, 0.832722008) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.650901496, -2.00436831, -0.235267341, 0.841717243, -0.114475906, 0.527643263, 5.27501106E-6, 0.977266133, 0.212016359, -0.539918661, -0.178455025, 0.822582364) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.999999881, -2.98023224E-8, 0, -2.98023224E-8, 1, 0, 0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.90462077, 0.945885122, -0.45939967, 0.874663889, -0.481609076, 0.0549148396, 0.474493116, 0.873839974, 0.106113762, -0.0990921259, -0.066757217, 0.992836595) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.31, false)
		end
		Trail.Enabled = false
		Humanoid.WalkSpeed = 16
		Attack = false
	end,
	["4"] = function()
		Attack = true
		Humanoid.WalkSpeed = 5
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.0630185828, -0.489610553, 0.176186547, 0.918316007, 1.36839788E-7, -0.395848095, -0.088225998, 0.974846363, -0.2046725, 0.38589099, 0.222878128, 0.895217061) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.00167241693, 1.52400136, -0.00336959958, 0.895320058, -0.0922970846, 0.435755908, 2.66358256E-6, 0.978297174, 0.20720683, -0.445423365, -0.18551527, 0.87588948) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.18471086, 1.29328787, 0.42868647, 0.897346675, -0.139672607, -0.418641448, -2.6778318E-5, -0.948615372, 0.31643194, -0.441326618, -0.283937931, -0.851240456) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.780820489, 1.07899392, -1.24912989, 0.604390621, -0.462227583, -0.648889601, -0.789608538, -0.45588401, -0.410716832, -0.105973706, 0.760602176, -0.640510798) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.976371765, -1.65881336, 0.330952764, 0.827035189, -0.266684741, 0.494865745, 0.0934763774, 0.933294058, 0.346734345, -0.554323971, -0.240503252, 0.796795607) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.716628075, -1.83640146, 0.101153493, 0.827439308, -0.0363899991, 0.560374916, -0.130501226, 0.958117068, 0.254914463, -0.546181142, -0.284055889, 0.788034618) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 0, 3.7252903E-9, 0, 1.00000012, -1.86264515E-9, 3.7252903E-9, -1.86264515E-9, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.4848963, 1.17755246, 1.59305255E-5, 0.761023521, 0.648724437, -2.3137778E-5, -0.648724496, 0.761023462, -4.2706728E-5, -1.00955367E-5, 4.75086272E-5, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
		end
		Humanoid.WalkSpeed = 0
		CFuncs.Sound.Create("203691492", Hitbox, 1, 1, 5)
		Trail.Enabled = true
		for i = 0, 1, 0.15 do
			swait()
			dabfastman({
				CFrame.new(0.211727202, -0.711087704, -1.13575423, 0.493907988, -0.0379241034, 0.868686795, -0.438315004, 0.851969123, 0.286406368, -0.750955999, -0.522216797, 0.404171616) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.00972136855, 1.43298638, -0.0570737869, 0.539564013, -0.269201934, -0.797747493, 1.01700425E-5, 0.947508037, -0.31973213, 0.841944695, 0.172507823, 0.511243939) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.61506772, 0.492749572, -0.48200047, 0.683789432, -0.46405071, -0.563106656, -0.517624676, 0.235433877, -0.822578669, 0.514292598, 0.853948534, -0.0792169571) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.58287859, -0.158723354, -1.00953376, 0.507138729, -0.588082314, -0.630055249, -0.170568094, 0.648095071, -0.742212415, 0.844817817, 0.483871937, 0.228366017) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.14025688, -1.11600804, -0.429702669, 0.568509936, -0.46061936, -0.681635082, 0.0726023614, 0.853416502, -0.516148567, 0.819466591, 0.243947238, 0.518617749) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.487157822, -2.00573635, -0.142733082, 0.88652575, 0.0200313032, -0.462245613, -2.05636024E-6, 0.999062538, 0.043290168, 0.462679446, -0.0383768678, 0.885694683) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 2.98023224E-8, 2.60770321E-8, 2.98023224E-8, 1.00000012, -1.86264515E-9, 2.60770321E-8, -1.86264515E-9, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.51132059, 0.647999585, -0.505859733, 0.886167109, 0.375624895, 0.271318734, -0.462250352, 0.676032305, 0.573851168, 0.0321325697, -0.633945167, 0.772710383) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.55, false)
		end
		Trail.Enabled = false
		CamShake(RootPart, 10, 0.6, 9)
		local hitfloor2, posfloor2 = RayCast(Hitbox.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2) * CFrame.new(0, -0.2, 0)
		game:GetService("Debris"):AddItem(ref2, 5)
		CFuncs.Sound.Create("834070282", ref2, 0.7, 0.9, 5)
		CFuncs.Sound.Create("824697277", ref2, 2, 0.85, 5)
		CFuncs.Sound.Create("834070239", ref2, 1, 0.86, 5)
		MagnitudeDamage(ref2, 15, 10, 25, math.random(1, 5), "Knockdown", 0.5)
		for i = 1, 3 do
			Effects.Feather.Create("Glass", BrickColor.new("Toothpaste"), ref2.CFrame * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.2, 0.02, 0.2, 3, 0.01, 3, 0.1)
		end
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 2, 1, 2, 0.1, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.1, 0.1, 1, 2, 1, 0.1, 1, ref2)
		Effects.Sphere.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 1, 0.4, 1, 0.1, 1, ref2)
		for i = 0, 1, 0.13 do
			swait()
			dabfastman({
				CFrame.new(0.211727202, -0.711087704, -1.13575423, 0.493907988, -0.0379241034, 0.868686795, -0.438315004, 0.851969123, 0.286406368, -0.750955999, -0.522216797, 0.404171616) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.00972136855, 1.43298638, -0.0570737869, 0.539564013, -0.269201934, -0.797747493, 1.01700425E-5, 0.947508037, -0.31973213, 0.841944695, 0.172507823, 0.511243939) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.61506772, 0.492749572, -0.48200047, 0.683789432, -0.46405071, -0.563106656, -0.517624676, 0.235433877, -0.822578669, 0.514292598, 0.853948534, -0.0792169571) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.58287859, -0.158723354, -1.00953376, 0.507138729, -0.588082314, -0.630055249, -0.170568094, 0.648095071, -0.742212415, 0.844817817, 0.483871937, 0.228366017) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.14025688, -1.11600804, -0.429702669, 0.568509936, -0.46061936, -0.681635082, 0.0726023614, 0.853416502, -0.516148567, 0.819466591, 0.243947238, 0.518617749) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.487157822, -2.00573635, -0.142733082, 0.88652575, 0.0200313032, -0.462245613, -2.05636024E-6, 0.999062538, 0.043290168, 0.462679446, -0.0383768678, 0.885694683) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 2.98023224E-8, 2.60770321E-8, 2.98023224E-8, 1.00000012, -1.86264515E-9, 2.60770321E-8, -1.86264515E-9, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.51132059, 0.647999585, -0.505859733, 0.886167109, 0.375624895, 0.271318734, -0.462250352, 0.676032305, 0.573851168, 0.0321325697, -0.633945167, 0.772710383) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.45, false)
		end
		Humanoid.WalkSpeed = 16
		Attack = false
	end
}
function Lightning2(Part0, Part1, Times, Offset, Color, Thickness, Trans, V)
	local magz = (Part0 - Part1).magnitude
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1, Times do
		do
			local li = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, Color, "Lightning", Vector3.new(Thickness, Thickness, magz / Times))
			li.Anchored = true
			li.Transparency = Trans
			local ora = Instance.new("BlockMesh", li)
			ora.Scale = Vector3.new(Thickness, Thickness, 1)
			local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
			local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
			if Times == i then
				local magz2 = (curpos - Part1).magnitude
				li.Size = Vector3.new(Thickness, Thickness, magz2)
				li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
			else
				li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
			end
			curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
			coroutine.resume(coroutine.create(function()
				for i = 1, V do
					swait()
					li.Transparency = i / V
				end
				li:Destroy()
			end))
		end
	end
end
Skills = {
	E = function()
		Attack = true
		ChargeBits.Enabled = true
		ChargeWave.Enabled = true
		ChargeWave2.Enabled = true
		CFuncs.Sound.Create("1614535601", Head, 2, 1, 5)
		Humanoid.WalkSpeed = 4
		CFuncs.Sound.Create("300916082", Hitbox, 1, 1.2, 5)
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.266697705, -0.211599946, 0.130362794, 0.855487585, -0.0190758761, -0.51747179, -0.0315909833, 0.995537221, -0.0889254808, 0.516858757, 0.0924220979, 0.851067066) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0303249434, 1.4953934, -0.0794907063, 0.817190766, -0.0551990755, 0.573718071, -0.0385621451, 0.987936914, 0.149979293, -0.575075924, -0.144685477, 0.805204272) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.877077103, 1.34950185, 0.774489403, 0.908336043, 0.406796336, 0.0971720815, 0.350186676, -0.866757452, 0.355107069, 0.228680849, -0.288528264, -0.929761589) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.522989988, 1.17179799, -0.961153626, -0.777674675, -0.57943207, -0.243886322, 0.438653737, -0.778026164, 0.449731588, -0.450338781, 0.242763191, 0.85922128) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.845042229, -1.83017659, 0.0710492283, 0.900673032, -0.154870331, 0.405959755, 0.104521252, 0.984110117, 0.143536389, -0.421738625, -0.0868479162, 0.902548611) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.687669039, -1.9060123, 0.0942255557, 0.750445604, -0.0487671271, 0.659130573, -0.0663864613, 0.986668944, 0.148584276, -0.657589614, -0.155261755, 0.737203896) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 2.23517418E-8, 2.98023224E-8, 2.23517418E-8, 1.00000012, -1.49011612E-8, 2.98023224E-8, -1.49011612E-8, 0.999999881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.4508574, 0.950321555, 0.0422772169, 0.783466816, 0.58874619, 0.198891342, -0.577034891, 0.808027804, -0.118836306, -0.230674058, -0.0216629356, 0.972789764) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.25, false)
		end
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.266696483, -0.19689706, 0.110607758, 0.855488002, -0.0190759748, -0.517471194, -0.0516339988, 0.991198361, -0.121901147, 0.515241981, 0.131004065, 0.8469733) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0303218439, 1.49539328, -0.0794886649, 0.816428423, 0.00115705281, 0.577445626, -0.0309221372, 0.998650849, 0.0417185798, -0.576618254, -0.0519160852, 0.815362692) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.862307787, 1.59006572, 0.741201282, 0.923586845, 0.364748776, 0.118091941, 0.285133541, -0.859401584, 0.424414933, 0.256293267, -0.358312011, -0.897734106) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.665583074, 1.44887292, -1.01020098, -0.834212184, -0.417310953, -0.360474288, 0.354536742, -0.906559765, 0.229027122, -0.422366947, 0.0632558614, 0.904215097) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.845040858, -1.83017504, 0.0710488856, 0.907654762, -0.105138026, 0.40633601, 0.046959348, 0.987477362, 0.150610656, -0.417082459, -0.117621198, 0.901225626) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.687670171, -1.90601075, 0.0942220092, 0.748608649, -0.0825275332, 0.657855928, -0.027892258, 0.987424493, 0.155611694, -0.662425339, -0.134841338, 0.736892521) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, -1.49011612E-8, 0, -1.49011612E-8, 0.99999994, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.873622537, 0.5251773, -0.127683192, 0.783467531, 0.588745475, 0.198890597, -0.577034116, 0.808028162, -0.118836448, -0.230673641, -0.0216621459, 0.972790062) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.15, false)
		end
		ChargeBits.Enabled = false
		ChargeWave.Enabled = false
		ChargeWave2.Enabled = false
		ChargeBits2:Emit(20)
		ChargeWave3:Emit(2)
		ChargeWave4:Emit(5)
		Smoke2:Emit(20)
		Wave3:Emit(1)
		CFuncs.Sound.Create("300916105", Hitbox, 1, 0.9, 5)
		CFuncs.Sound.Create("300916014", Hitbox, 1, 1, 5)
		CFuncs.Sound.Create("301031757", Hitbox, 1, 1, 5)
		CamShake(RootPart, 15, 0.9, 12)
		Humanoid.WalkSpeed = 0
		for i = 0, 1, 0.07 do
			swait()
			dabfastman({
				CFrame.new(-0.266694129, -0.622656584, 0.255405098, 0.855488002, -0.0190763772, -0.517471254, 0.0850469992, 0.990927041, 0.104070269, 0.510791004, -0.133040234, 0.849348485) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.075704366, 1.53773868, -0.146817595, 0.817193449, -0.151981741, 0.55596453, -0.0385638252, 0.94802779, 0.315842152, -0.57507205, -0.279544234, 0.768860996) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.02546072, 1.03335798, 0.669255257, 0.908336163, 0.406796664, 0.0971708, 0.350185841, -0.866755247, 0.355113268, 0.228682131, -0.288534284, -0.929759443) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.401787937, 0.843678594, -1.16011322, -0.687109292, -0.715794623, -0.124575645, 0.545103192, -0.621235609, 0.56296438, -0.480357587, 0.318911493, 0.817038536) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.763648331, -1.5767628, -0.292806178, 0.996835709, -0.0484557487, -0.0630138516, 0.0440192074, 0.996576548, -0.0699837282, 0.0661891997, 0.0669884533, 0.995555878) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.10323668, -1.30660725, -0.440535545, 0.750444949, 0.107946798, 0.652058363, -0.0663867816, 0.9938941, -0.0881332904, -0.657590628, 0.0228511132, 0.75302881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, 3.7252903E-9, 5.96046448E-8, 3.7252903E-9, 0.99999994, -1.49011612E-8, 5.96046448E-8, -1.49011612E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.64415967, 1.09268916, 0.0991941392, 0.78346777, 0.588745415, 0.198890567, -0.577032566, 0.80802846, -0.118842468, -0.230677158, -0.0216570497, 0.972789288) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.42, false)
		end
		print(Charges)
		Charges = 3
		Charged = true
		Humanoid.WalkSpeed = 16
		Attack = false
	end,
	C = function()
		Attack = true
		cooldown3 = 0
		Humanoid.WalkSpeed = 5
		local no = 0
		local ecksdee = 15
		local ref = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		game:GetService("Debris"):AddItem(ref, 5)
		CFuncs.Sound.Create("822950046", ref, 2, 1.2, 5)
		for i = 0, 1, 0.04 do
			swait()
			no = no + 1
			if no == 6 then
				no = 0
				CFuncs.Sound.Create("206083232", ref, 0.5, 2)
				for i = 1, 2 do
					Lightning2(LeftLeg.Position, Torso.Position + Vector3.new(math.random(-ecksdee, ecksdee), 0, math.random(-ecksdee, ecksdee)), 6, 2, "Cyan", 0.1, 0.5, 5)
				end
				Effects.Block.Create("SmoothPlastic", BrickColor.new("Cyan"), CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0, 0, 0, 0.2, 0.2, 0.2, 0.07, 3, ref)
				Effects.Sphere.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0, 0, 0, 0.15, 0.15, 0.15, 0.07, 2, ref)
			end
			ref.CFrame = LeftLeg.CFrame * CFrame.new(0, -0.8, 0)
			dabfastman({
				CFrame.new(-0.107274182, -0.0652196705, 0.165030107, 0.888410091, -7.87681756E-7, -0.459050745, -0.0687980056, 0.988705516, -0.133147866, 0.453866065, 0.149871677, 0.878375947) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.069534272, 1.53135335, -0.123537272, 0.879119754, -0.156619295, 0.450132221, -4.78560105E-6, 0.944460452, 0.32862553, -0.476601124, -0.288903356, 0.830293059) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.75511181, 0.568878531, -0.105572924, 0.71002388, -0.702813327, 0.0438138768, 0.355274796, 0.303809702, -0.884013295, 0.607985377, 0.643236518, 0.465404004) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.55200505, 0.242930666, 0.264319837, 0.917827487, 0.374675333, -0.131191701, -0.33608973, 0.909269273, 0.245506331, 0.21127373, -0.181240261, 0.960476756) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.682046235, -1.96377659, -0.00666022301, 0.990204275, -0.139626473, 1.29938126E-5, 0.13732335, 0.973887861, 0.180789739, -0.0252556801, -0.179017022, 0.983521879) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.867114425, -0.59998405, -0.571169972, 0.841233909, 0.0736081302, 0.535637438, 9.91858542E-7, 0.990689218, -0.13614361, -0.540671468, 0.114529178, 0.833401322) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, 0, 0, 0, 1.00000012, -2.98023224E-8, 0, -2.98023224E-8, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.481871754, 0.0505170971, 0.123012505, 0.0466884002, -0.980957091, -0.188530445, 0.998909533, 0.0458494201, 0.00881099701, 8.04662704E-7, -0.18873623, 0.982027948) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.1, false)
		end
		CFuncs.Sound.Create("203691467", LeftLeg, 1, 0.9, 5)
		Humanoid.WalkSpeed = 0
		for i = 0, 1, 0.25 do
			swait()
			dabfastman({
				CFrame.new(-0.107280195, -0.312153757, -0.559508681, 0.888410211, 8.14158284E-7, -0.459050626, 0.0857470185, 0.982399285, 0.165949717, 0.450971127, -0.186793625, 0.87277329) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0695299506, 1.53134918, -0.123543441, 0.879119992, -0.15662007, 0.450131625, -4.22028825E-6, 0.944460154, 0.328626364, -0.476600796, -0.288903773, 0.830292881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.733845, 0.573240042, -0.0267722979, 0.704455554, -0.709446728, 0.0206889808, 0.1714046, 0.141767204, -0.974947572, 0.688740134, 0.690353334, 0.221471041) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.81225157, 0.513196826, 0.226800188, 0.668622911, 0.734704971, -0.114683032, -0.740331113, 0.672166646, -0.0100982487, 0.0696668327, 0.0916553289, 0.993350804) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.679998755, -1.8252598, 0.0117866248, 0.999038994, -0.0153980777, 0.041038692, 0.0199625194, 0.993366718, -0.113244332, -0.0390227139, 0.113954738, 0.992719352) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.03717327, -1.54277754, -0.835801482, 0.841243505, 0.113741875, 0.528556943, -1.31875277E-6, 0.97762084, -0.210375279, -0.540656686, 0.1769761, 0.82241714) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, -2.98023224E-8, 0, 0.999999881, -1.49011612E-8, -2.98023224E-8, -1.49011612E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.481862098, 0.0505440496, 0.123008423, 0.0466890335, -0.980956912, -0.188530415, 0.998909473, 0.045849923, 0.00881187618, 0, -0.188736245, 0.982027829) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.5, false)
		end
		MagnitudeDamage(Torso, 14, 5, 10, math.random(-5, -2), "Normal", 0.1)
		CamShake(RootPart, 25, 0.8, 20)
		local hitfloor2, posfloor2 = RayCast(LeftLeg.Position, CFrame.new(LeftLeg.Position, LeftLeg.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2) * CFrame.new(0, -0.2, 0)
		game:GetService("Debris"):AddItem(ref2, 5)
		CFuncs.Sound.Create("824697277", ref2, 2, 0.95, 5)
		CFuncs.Sound.Create("834070239", ref2, 1, 0.96, 5)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 3, 1, 3, 0.1, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 2.5, 2, 2.5, 0.1, 1, ref2)
		local num1 = -1.57
		local num2 = 2
		local num3 = 0.785
		local dammin = 5
		local dammax = 20
		for i = num1, num2, num3 do
			coroutine.resume(coroutine.create(function(MagicCF)
				for i = 5, 25, 10 do
					local CeEf = MagicCF * CFrame.new(0, 0, -i)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Effect", Vector3.new(0.2, 0.2, 0.2))
					prt.Parent = nil
					prt.Anchored = true
					prt.CFrame = CeEf
					local hit, pos = RayCast(prt.Position, CFrame.new(prt.Position, prt.Position - Vector3.new(0, 1, 0)).lookVector, 500, Character)
					if hit ~= nil then
						prt.CFrame = CFrame.new(pos)
						prt.Parent = EffectModel
						game:GetService("Debris"):AddItem(prt, 2)
						CFuncs.Sound.Create("834070340", prt, 1, 1)
						CFuncs.Sound.Create("822969951", prt, 1.2, 1)
						MagnitudeDamage(prt, 8, dammin, dammax, math.random(20, 40), "Knockdown", 0.1)
						local eul = CFrame.fromEulerAnglesXYZ(math.random(-50, 50) / 100, 0, math.random(-50, 50) / 100)
						Effects.Block.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(pos) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0, 0, 0, 1.3, 1.3, 1.3, 0.1, 3, prt)
						Effects.Sphere.Create("SmoothPlastic", BrickColor.new("Toothpaste"), CFrame.new(pos) * eul, 0, 0, 0, 1.3, 4, 1.3, 0.1, 1, prt)
						Effects.Sphere.Create("Neon", BrickColor.new("Cyan"), CFrame.new(pos) * eul, 0, 0, 0, 1, 3, 1, 0.1, 1, prt)
						Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(pos), 0.1, 0.01, 0.1, 3, 1, 3, 0.15, 1, prt)
					end
					swait(7)
				end
			end), RootPart.CFrame * CFrame.fromEulerAnglesXYZ(0, i, 0))
		end
		for i = 0, 1, 0.05 do
			swait()
			dabfastman({
				CFrame.new(-0.107280195, -0.312153757, -0.559508681, 0.888410211, 8.14158284E-7, -0.459050626, 0.0857470185, 0.982399285, 0.165949717, 0.450971127, -0.186793625, 0.87277329) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0695299506, 1.53134918, -0.123543441, 0.879119992, -0.15662007, 0.450131625, -4.22028825E-6, 0.944460154, 0.328626364, -0.476600796, -0.288903773, 0.830292881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.733845, 0.573240042, -0.0267722979, 0.704455554, -0.709446728, 0.0206889808, 0.1714046, 0.141767204, -0.974947572, 0.688740134, 0.690353334, 0.221471041) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.81225157, 0.513196826, 0.226800188, 0.668622911, 0.734704971, -0.114683032, -0.740331113, 0.672166646, -0.0100982487, 0.0696668327, 0.0916553289, 0.993350804) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.679998755, -1.8252598, 0.0117866248, 0.999038994, -0.0153980777, 0.041038692, 0.0199625194, 0.993366718, -0.113244332, -0.0390227139, 0.113954738, 0.992719352) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.03717327, -1.54277754, -0.835801482, 0.841243505, 0.113741875, 0.528556943, -1.31875277E-6, 0.97762084, -0.210375279, -0.540656686, 0.1769761, 0.82241714) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, -2.98023224E-8, 0, 0.999999881, -1.49011612E-8, -2.98023224E-8, -1.49011612E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.481862098, 0.0505440496, 0.123008423, 0.0466890335, -0.980956912, -0.188530415, 0.998909473, 0.045849923, 0.00881187618, 0, -0.188736245, 0.982027829) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.5, false)
		end
		Humanoid.WalkSpeed = 16
		Attack = false
	end,
	X = function()
		Attack = true
		cooldown2 = 0
		CamShake(RootPart, 5, 0.15, 15)
		Humanoid.WalkSpeed = 5
		CFuncs.Sound.Create("300916082", Hitbox, 1, 1.2, 5)
		ChargeBits.Enabled = true
		ChargeWave.Enabled = true
		ChargeWave2.Enabled = true
		local ecksdee = 27
		local no = 0
		for i = 0, 1, 0.04 do
			swait()
			no = no + 1
			if no == 5 then
				no = 0
				Lightning2(Hitbox.Position, Torso.Position + Vector3.new(math.random(-ecksdee, ecksdee), 0, math.random(-ecksdee, ecksdee)), 6, 2, "Toothpaste", 0.35, 0.5, 5)
				CFuncs.Sound.Create("206083232", Hitbox, 1, 1)
				CFuncs.Sound.Create("206083232", Hitbox, 1, 2)
			end
			dabfastman({
				CFrame.new(-0.271033704, -0.204682887, -0.505019307, 0.592095315, 2.02926856E-7, -0.80586797, 0.152473077, 0.981937945, 0.112026766, 0.791312337, -0.189203694, 0.581400812) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0550705865, 1.51035261, -0.0398256034, 0.570951879, -0.0853554159, 0.816534579, -0.0524211675, 0.988761008, 0.140013784, -0.819308341, -0.122744814, 0.560060501) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.58584845, 0.682932138, -0.172696769, 0.241750926, -0.758836329, -0.604751348, -0.965475202, -0.250429392, -0.071714744, -0.0970277488, 0.601209283, -0.793179154) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.02794719, 0.609892249, -1.09767711, 0.385595441, -0.404885828, -0.829086185, -0.919316173, -0.245115638, -0.307857513, -0.0785747766, 0.880900621, -0.466733545) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.492733985, -1.98481548, 0.205348969, 0.884854078, 0.123789147, -0.449121088, -0.078728497, 0.989919186, 0.117736727, 0.459168106, -0.0688211769, 0.885679603) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.09586644, -1.67286193, -0.519937396, 0.893780351, 0.206185326, 0.398302048, -0.182666183, 0.978418946, -0.0965904817, -0.409621775, 0.0135743497, 0.912154496) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 1.49011612E-8, 2.98023224E-8, 1.49011612E-8, 1.00000012, -7.4505806E-9, 2.98023224E-8, -7.4505806E-9, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.42383099, 0.880835176, 6.99316786E-7, 0.848629117, 0.528988481, 4.47034836E-7, -0.528988421, 0.848629177, -1.04308128E-7, -4.17232513E-7, -1.34110451E-7, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
		end
		ChargeBits.Enabled = false
		ChargeWave.Enabled = false
		ChargeWave2.Enabled = false
		ChargeBits2:Emit(20)
		ChargeWave3:Emit(2)
		ChargeWave4:Emit(5)
		Smoke2:Emit(20)
		Wave3:Emit(1)
		CFuncs.Sound.Create("300916105", Hitbox, 1, 1, 5)
		CFuncs.Sound.Create("300916014", Hitbox, 1, 1.2, 5)
		CFuncs.Sound.Create("301031757", Hitbox, 1, 1.2, 5)
		local num2 = 0
		Humanoid.WalkSpeed = 0
		CamShake(RootPart, 15, 0.4, 15)
		for i = 0, 1, 0.08 do
			swait()
			dabfastman({
				CFrame.new(-0.271034062, -0.581023455, -0.459244579, 0.592095017, -5.58909865E-29, -0.805868208, 0.288827986, 0.933565855, 0.212210417, 0.752331018, -0.358405977, 0.552759647) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0550758019, 1.51035285, -0.0398334563, 0.566870749, -0.00597774982, 0.823785186, -0.0496912748, 0.997904778, 0.0414353013, -0.822306871, -0.0644233376, 0.565385938) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.76738882, 0.691155076, 0.197695911, 0.241753027, -0.871159911, -0.427359402, -0.965474725, -0.259994566, -0.0161680579, -0.0970261991, 0.416513354, -0.903937221) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.637141824, 0.776321471, -1.1271081, 0.38559261, -0.685977042, -0.617052734, -0.919317245, -0.34258917, -0.193619788, -0.078576833, 0.641925514, -0.76273036) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.608532429, -1.73569775, -0.132499397, 0.884304523, 0.101325393, -0.455783755, -0.00939744711, 0.979833603, 0.199594349, 0.466816127, -0.172218964, 0.867423475) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.00897551, -1.20835018, -0.537475944, 0.893776298, 0.267159581, 0.360263377, -0.182662487, 0.950427353, -0.251639247, -0.409631997, 0.159102619, 0.898269475) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, 0, -2.98023224E-8, 0, 1, -1.49011612E-8, -2.98023224E-8, -1.49011612E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.843224347, 0.63113749, -0.213439614, 0.848629057, 0.5289886, 1.81794167E-6, -0.528988481, 0.848628998, 1.90734863E-6, -5.36441803E-7, -2.59280205E-6, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.35, false)
		end
		for i = 0, 1, 0.12 do
			swait()
			dabfastman({
				CFrame.new(0.184920281, -0.13470155, -0.70915246, 0.822610676, -0.0327313021, 0.567662179, -0.115219958, 0.968034923, 0.222784281, -0.556808829, -0.248670757, 0.792544544) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0578408539, 1.49271989, -0.0444760695, 0.839568079, -0.0305012614, -0.542397738, -0.00155685376, 0.998283565, -0.0585474372, 0.543252468, 0.0499989688, 0.838079393) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.495738626, 0.556718171, -1.13458633, -0.140229255, 0.754078686, 0.641639471, 0.9812814, 0.0194537304, 0.191594705, 0.131995186, 0.656495929, -0.742691338) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.77242398, 0.306706488, -0.574737847, 0.0666475594, 0.586956799, 0.806870461, 0.863337994, 0.371478111, -0.341543019, -0.500205755, 0.719364882, -0.4819839) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.908449888, -1.76839364, -0.334151775, 0.934085369, -0.169040382, -0.314499438, 0.107751094, 0.973218143, -0.203067034, 0.34040302, 0.155794278, 0.927283168) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.735063374, -1.94055176, -0.389303803, 0.958843231, 0.0166913122, 0.283445358, -0.0650274754, 0.984647214, 0.161992803, -0.276389748, -0.173757434, 0.945207477) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.99999994, 0, 3.7252903E-9, 0, 1.00000012, -7.4505806E-9, 3.7252903E-9, -7.4505806E-9, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.07435524, -0.898124754, 0.0121428818, 0.647516131, 0.739669383, -0.183335751, -0.752422571, 0.658680797, 1.34855509E-6, 0.120760724, 0.137945086, 0.983050346) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.35, false)
		end
		Trail.Enabled = true
		Humanoid.WalkSpeed = 25
		for i = 1, 8 do
			Torso.Velocity = RootPart.CFrame.lookVector * 150
			MagnitudeDamage(Torso, 15, 2, 8, math.random(-5, -2), "Normal", 0.1)
			Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(Torso.Position), 0.1, 0.01, 0.1, 4, 1, 4, 0.09, 1, Torso)
			Effects.Feather.Create("Glass", BrickColor.new("Toothpaste"), Torso.CFrame * CFrame.Angles(0, math.random(-10, 10), 0), 0.2, 0.1, 0.2, 2, 0.1, 2, 0.07)
			Effects.Feather.Create("Neon", BrickColor.new("Toothpaste"), Torso.CFrame * CFrame.Angles(0, math.random(-5, 5), 0), 0.2, 0.1, 0.2, 1, 0.1, 1, 0.07)
			CFuncs.Sound.Create("234365549", Hitbox, 1, 0.4, 5)
			CFuncs.Sound.Create("203691447", Hitbox, 1, 0.86, 5)
			for i = 0, 1, 0.1 do
				swait()
				RootPart.Velocity = Torso.CFrame.lookVector * 70
				dabfastman({
					CFrame.new(0, -0.17491293, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, -6 * i, 0),
					CFrame.new(-2.0591554E-29, 1.49283361, -0.081883207, 1, -2.86879663E-29, 1.37185025E-28, 6.11343504E-30, 0.986823618, 0.161799937, -1.40019127E-28, -0.161799937, 0.986823618) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.495722234, 0.556721628, -1.13456321, -0.140230015, 0.754078805, 0.641639054, 0.981280088, 0.0194484647, 0.191601843, 0.132004008, 0.656495988, -0.742689669) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-1.77243161, 0.306706339, -0.574731529, 0.0666459948, 0.586957991, 0.806869686, 0.863340855, 0.371474385, -0.34153977, -0.500200927, 0.719365776, -0.481987506) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.728156149, -1.90905309, -0.408895075, 0.983684897, -0.127427742, -0.126989156, 0.0827729926, 0.947318435, -0.309413105, 0.159726977, 0.29385373, 0.942410469) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.735070527, -1.94055605, -0.389316916, 0.958840609, 0.151988581, 0.239842162, -0.0650210381, 0.939761996, -0.335588574, -0.276400179, 0.306181133, 0.910964429) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0, 0, 0, 1.00000012, 2.98023224E-8, 1.49011612E-8, 2.98023224E-8, 1.00000024, -7.4505806E-9, 1.49011612E-8, -7.4505806E-9, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.07433212, -0.898120582, 0.0121379644, 0.647515953, 0.739669204, -0.183337793, -0.75242269, 0.658680797, 9.43895429E-7, 0.120761774, 0.137946889, 0.983050108) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.3, false)
			end
		end
		Trail.Enabled = false
		Humanoid.WalkSpeed = 16
		Attack = false
	end,
	Z = function()
		Attack = true
		cooldown1 = 0
		local no = 0
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), RootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0), 0, 0, 0, 3, 1, 3, 0.08, 1, RootPart)
		CFuncs.Sound.Create("822966419", Torso, 1, 0.6, 5)
		CFuncs.Sound.Create("199145433", Torso, 1, 0.9, 5)
		for i = 0, 1, 0.1 do
			swait()
			no = no + 1
			if no == 2 then
				no = 0
				Effects.Feather.Create("Glass", BrickColor.new("Toothpaste"), RootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0), 0, 0, 0, 2, 0.1, 2, 0.09)
			end
			RootPart.Velocity = RootPart.CFrame.lookVector * 120
			dabfastman({
				CFrame.new(0.129669785, -0.665138662, -0.92136848, 0.405922145, 0.0395309702, -0.91305232, 0.44574216, 0.863612592, 0.235557184, 0.79783529, -0.502603769, 0.33293885) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(5.06639481E-6, 1.49999142, -4.17232513E-6, 0.443343639, 0.313770682, 0.839639425, 3.67686152E-6, 0.936729193, -0.350054771, -0.896351814, 0.155197605, 0.415291786) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.49923801, 0.0531132221, -0.67177844, -0.27534163, -0.410131484, -0.869470596, -0.420721352, 0.864627481, -0.274614155, 0.864396095, 0.290192127, -0.410618991) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.18016124, 1.14220369, -0.543485224, -0.445107281, -0.668085575, -0.596272826, -0.641693592, -0.226472929, 0.732761502, -0.624586999, 0.708781958, -0.327901483) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.702166259, -1.96289086, -0.190708295, 0.728885651, -0.341361463, 0.593462825, 0.137116253, 0.922053218, 0.361962616, -0.670764327, -0.182455987, 0.718877614) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.928682148, -1.31489909, -0.0986025929, 0.32291922, -0.113528848, 0.939592719, -0.180263981, 0.967226982, 0.178820878, -0.929100752, -0.227119446, 0.291871011) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.999999881, 2.98023224E-8, 1.49011612E-8, 2.98023224E-8, 1, 1.49011612E-8, 1.49011612E-8, 1.49011612E-8, 0.99999994) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.994382024, 1.32220793, -0.145234957, 0.598924875, 0.689367056, -0.407506943, -0.789642155, 0.593063474, -0.157292962, 0.133244872, 0.415991336, 0.899553835) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
		end
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = RootPart.CFrame * CFrame.new(0, -2.6, -7)
		CFuncs.Sound.Create("824695253", ref2, 1, 0.8, 5)
		CFuncs.Sound.Create("834070239", ref2, 1, 0.8, 5)
		CFuncs.Sound.Create("822966721", ref2, 2, 1, 5)
		CFuncs.Sound.Create("822969951", ref2, 1, 1, 5)
		MagnitudeDamage(ref2, 12, 5, 15, math.random(10, 20), "Knockdown", 0.1)
		Effects.Sphere.Create("SmoothPlastic", BrickColor.new("Cyan"), ref2.CFrame * CFrame.Angles(math.rad(-50), 0, 0), 0.1, 0.01, 0.1, 0.6, 2, 0.6, 0.08, 1, ref2)
		Effects.Sphere.Create("Neon", BrickColor.new("Toothpaste"), ref2.CFrame * CFrame.Angles(math.rad(-50), 0, 0), 0.1, 0.01, 0.1, 0.4, 1.8, 0.4, 0.08, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), ref2.CFrame * CFrame.Angles(math.rad(-50), 0, 0), 0.1, 0.01, 0.1, 1, 2, 1, 0.08, 1, ref2)
		Effects.Wave.Create("Neon", BrickColor.new("Cyan"), ref2.CFrame * CFrame.Angles(math.rad(-50), 0, 0), 0.1, 0.01, 0.1, 1.3, 0.7, 1.3, 0.08, 1, ref2)
		game:GetService("Debris"):AddItem(ref2, 5)
		CamShake(RootPart, 15, 0.15, 10)
		Trail.Enabled = true
		CFuncs.Sound.Create("203691492", Hitbox, 1, 1.1, 5)
		for i = 0, 1, 0.1 do
			swait()
			MagnitudeDamage(Hitbox, 7, 15, 25, math.random(1, 5), "Normal", 0.3)
			RootPart.Velocity = RootPart.CFrame.lookVector * -10
			dabfastman({
				CFrame.new(-0.191391021, -0.451611787, -0.904046178, 0.0640180185, 0.179750025, 0.981627047, 0.280464083, 0.940759182, -0.190557346, -0.957727373, 0.287510216, 0.00981211383) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.042436868, 1.48425114, -0.189227045, 0.603658736, 0.107429802, -0.78997165, 0.120646447, 0.967158079, 0.223718002, 0.78806144, -0.230356544, 0.570872307) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.788605094, 0.815591812, -1.43796802, -0.0350032002, 0.415358514, -0.908984244, -0.956254125, -0.27824527, -0.0903201848, -0.290435791, 0.86605823, 0.406927764) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.6520828, 0.527174473, -0.199228644, 0.7826882, 0.621407568, -0.0353810787, -0.346727252, 0.38809815, -0.853908658, -0.516893983, 0.680611789, 0.519218802) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.53927803, -1.96448135, -0.0686130524, 0.848114848, 0.242917508, -0.470842242, -0.02553837, 0.906406879, 0.421633035, 0.52919662, -0.345568627, 0.774940848) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.00509846, -1.54768705, 0.559674382, 0.913536072, 0.282666594, 0.292492181, -0.406757981, 0.634841442, 0.656905115, -1.03376806E-6, -0.719079971, 0.694927394) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 2.98023224E-8, -2.98023224E-8, 2.98023224E-8, 1.00000024, 2.23517418E-8, -2.98023224E-8, 2.23517418E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.48701119, 0.0260481536, 0.182092682, 0.994939268, 0.07915923, 0.0618851185, -0.064024061, 0.974132717, -0.21671778, -0.0774395466, 0.211658925, 0.974270821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.45, false)
		end
		Trail.Enabled = false
		Attack = false
	end,
	V = function()
		Attack = true
		cooldown4 = 0
		local hitfloor2, posfloor2 = RayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2) * CFrame.new(0, -0.2, 0)
		game:GetService("Debris"):AddItem(ref2, 5)
		Humanoid.WalkSpeed = 0
		CFuncs.Sound.Create("300916082", Hitbox, 1, 0.7, 5)
		CFuncs.Sound.Create("300915867", Hitbox, 1, 0.9, 5)
		CFuncs.Sound.Create("300915902", Hitbox, 1, 0.9, 5)
		ChargeBits.Enabled = true
		ChargeWave.Enabled = true
		ChargeWave2.Enabled = true
		local ecksdee = 27
		local no = 0
		local no2 = 0
		CamShake(RootPart, 15, 0.5, 50)
		for i = 1, 2 do
			for i = 0, 1, 0.03 do
				swait()
				no2 = no2 + 5
				no = no + 1
				if no == 3 then
					no = 0
					Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 + no2, 0), 0.1, 0.01, 0.1, 3, 1, 3, 0.15, 1, ref2)
					Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 - no2, 0), 0.1, 0.01, 0.1, 2.5, 2, 2.5, 0.15, 1, ref2)
					CFuncs.Sound.Create("206083232", Hitbox, 1, 0.8)
					CFuncs.Sound.Create("206083232", Hitbox, 1, 2)
				end
				Lightning2(Hitbox.Position, Torso.Position + Vector3.new(math.random(-ecksdee, ecksdee), 0, math.random(-ecksdee, ecksdee)), 6, 2, "Toothpaste", 0.5, 0.5, 5)
				dabfastman({
					CFrame.new(-0.0190803409, -0.280589163, 0.17728886, 0.643556058, -0.0453877971, -0.764052212, -0.0789130256, 0.988986194, -0.125217706, 0.761320293, 0.14087829, 0.63288641) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.0748345628, 1.53442001, -0.0714365691, 0.686907411, -0.109603286, 0.718432784, -0.0145645523, 0.986287594, 0.164392412, -0.726599336, -0.123385966, 0.675892055) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.28274, 1.45621324, -0.0381636024, 0.820530176, 0.174172238, 0.544421375, 0.342797458, -0.912103772, -0.224848732, 0.457406491, 0.371121407, -0.808114409) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.166140333, 1.28882647, -1.38791645, 0.891926527, -0.286954045, -0.349463344, -0.435789108, -0.751697898, -0.495013565, -0.120644718, 0.593807936, -0.795510769) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.811502218, -1.66536462, 0.300970852, 0.880723357, -0.122004554, 0.457647741, 5.62518835E-7, 0.966253757, 0.257593095, -0.473631203, -0.226867959, 0.851002455) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.857407451, -1.90167356, -0.0811855197, 0.710502028, -0.0138915572, 0.703558266, -0.10933537, 0.985484242, 0.12987262, -0.69514966, -0.169198513, 0.698669791) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0, 0, 0, 1.00000024, 1.3038516E-8, 2.98023224E-8, 1.3038516E-8, 1, 4.47034836E-8, 2.98023224E-8, 4.47034836E-8, 1.00000036) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.884094, -0.114113867, -1.2737751, 0.749549031, 0.0185115263, -0.661690176, 0.108738318, 0.982586443, 0.150665432, 0.652956963, -0.184882164, 0.734483778) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.1, false)
			end
		end
		for i = 0, 1, 0.1 do
			swait()
			dabfastman({
				CFrame.new(0.0351538993, -0.141551584, 0.0408745259, 0.503565848, -0.068858996, -0.861208379, -0.131991953, 0.97898525, -0.155454338, 0.853814721, 0.191954091, 0.483894706) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0748296976, 1.53441608, -0.0714384615, 0.686905563, -0.109604083, 0.718434215, -0.0145653188, 0.986287296, 0.164393783, -0.726600766, -0.123387218, 0.67588979) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.13129449, 1.55930364, -0.168894231, 0.838326454, 0.0285281297, 0.544421792, 0.178617001, -0.957882464, -0.224849045, 0.515077651, 0.285739839, -0.808113754) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.298477888, 1.41978407, -1.41128218, 0.891926289, -0.286954105, -0.34946382, -0.435789555, -0.751697242, -0.495014012, -0.120644659, 0.593808711, -0.795510054) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.821559072, -1.80050313, 0.296708941, 0.970388174, -0.138881594, 0.197633386, 0.0793377459, 0.956044853, 0.282283545, -0.228150278, -0.258244783, 0.938752949) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.849092066, -1.98829532, -0.0590792894, 0.710504472, -0.092658557, 0.697565734, -0.109334394, 0.964718819, 0.239507243, -0.695147157, -0.246438876, 0.675306201) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, -1.76951289E-8, -1.86264515E-9, -1.76951289E-8, 1, 0, -1.86264515E-9, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.884108424, -0.114119977, -1.27377367, 0.749551594, 0.0185126737, -0.661687255, 0.108737521, 0.982586086, 0.150667399, 0.652953923, -0.184883177, 0.734485924) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.25, false)
		end
		Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 + no2, 0), 0.1, 0.01, 0.1, 3, 1, 3, 0.08, 1, ref2)
		Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 - no2, 0), 0.1, 0.01, 0.1, 2.5, 2, 2.5, 0.08, 1, ref2)
		for i = 1, 3 do
			Effects.Feather.Create("Neon", BrickColor.new("Toothpaste"), Hitbox.CFrame * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.5, 0.02, 0.5, 5, 0.01, 5, 0.1)
		end
		ChargeBits.Enabled = false
		ChargeWave.Enabled = false
		ChargeWave2.Enabled = false
		ChargeBits2:Emit(20)
		ChargeWave3:Emit(2)
		ChargeWave4:Emit(5)
		Smoke2:Emit(20)
		Wave3:Emit(1)
		CFuncs.Sound.Create("300916105", Hitbox, 1, 0.8, 5)
		CFuncs.Sound.Create("300916014", Hitbox, 1, 1, 5)
		CFuncs.Sound.Create("301031757", Hitbox, 1, 1, 5)
		CFuncs.Sound.Create("161006182", Hitbox, 1, 0.7, 5)
		CFuncs.Sound.Create("324867021", Hitbox, 1, 0.8, 5)
		CamShake(RootPart, 15, 0.7, 12)
		for i = 0, 1, 0.05 do
			swait()
			dabfastman({
				CFrame.new(-0.0190817621, -0.626589179, 0.058165811, 0.643555999, -0.045388151, -0.764052153, 0.113466002, 0.992867887, 0.036590822, 0.756941974, -0.110242173, 0.644116163) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0748347268, 1.53441858, -0.0714319125, 0.686907709, -0.109602667, 0.718432367, -0.0145647116, 0.986287713, 0.164391771, -0.726598799, -0.12338575, 0.675892353) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.25400198, 1.16005373, 0.257371038, 0.823101699, -0.161584139, 0.544421077, -0.0423820838, -0.973471403, -0.224849492, 0.566310465, 0.162000284, -0.80811429) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.146665037, 1.296736, -1.32605767, 0.839912176, -0.463713288, -0.28198874, -0.538565576, -0.776327074, -0.32751137, -0.0670441091, 0.426950246, -0.901786447) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.742291093, -1.45301855, 0.172273636, 0.99271673, -0.10735938, -0.054658711, 0.119340725, 0.938394845, 0.324304163, 0.0164743364, -0.328465164, 0.944372654) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.9002707, -1.1916548, -0.236666232, 0.710502267, 0.140737399, 0.689477801, -0.109337643, 0.989975989, -0.0894038752, -0.695148945, -0.0118642114, 0.71876806) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, -1.49011612E-8, 0, -1.49011612E-8, 1.00000012, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.803951204, 0.0755712986, -1.24046636, 0.732709169, 0.159068733, -0.661690772, -0.07789886, 0.985512674, 0.150655061, 0.676068902, -0.0588413887, 0.734485328) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.4, false)
		end
		CFuncs.Sound.Create("1614535100", Head, 2, 1, 5)
		Humanoid.WalkSpeed = 60
		Humanoid.Jump = true
		RootPart.Velocity = RootPart.CFrame.upVector * 120
		CFuncs.Sound.Create("822966419", Torso, 1, 0.6, 5)
		CFuncs.Sound.Create("199145433", Torso, 1, 0.9, 5)
		local hitfloor2, posfloor2 = RayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2) * CFrame.new(0, -0.2, 0)
		game:GetService("Debris"):AddItem(ref2, 5)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 3, 1, 3, 0.1, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.1, 0.01, 0.1, 2.5, 2, 2.5, 0.1, 1, ref2)
		for i = 0, 1, 0.2 do
			swait()
			dabfastman({
				CFrame.new(-0.103175297, 0.0806090236, 0.343574822, 0.893112779, -0.102749951, -0.437940747, 0.10274899, 0.99442327, -0.0237714648, 0.437940925, -0.023767367, 0.898689568) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0489639714, 1.50584114, -0.159462333, 0.917611539, -0.0212566666, 0.396909863, -0.0808075443, 0.967738926, 0.238645718, -0.389177918, -0.251057357, 0.88629055) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.47468996, 1.32399917, 0.219472021, 0.895446956, -0.22061184, -0.386659205, -0.109079421, -0.950824082, 0.289888918, -0.431597739, -0.217403531, -0.875476599) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.113010496, 0.89773041, -1.32594466, 0.553194046, -0.717549801, -0.423200577, -0.775997639, -0.628629804, 0.0515023172, -0.302991927, 0.299911916, -0.904571176) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.867811084, -1.71833193, 0.309154332, 0.948808134, -0.268522114, 0.166310176, 0.151782319, 0.849384427, 0.505478561, -0.276993394, -0.454359174, 0.84665972) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.804791272, -1.30039334, -0.143787146, 0.713350534, -0.0571845397, 0.698470473, -0.38523373, 0.800579727, 0.45898509, -0.585428119, -0.596491575, 0.549064577) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 0, -4.65661287E-10, 0, 1, 4.65661287E-10, -4.65661287E-10, 4.65661287E-10, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.927955568, 0.717632592, 1.4129522E-6, 0.786211729, 0.617957413, -3.1250529E-6, -0.617957413, 0.786211729, -3.34973447E-6, 3.85567546E-7, 4.56458656E-6, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
		end
		local hitfloor
		while hitfloor == nil do
			swait()
			dabfastman({
				CFrame.new(-0.103175297, 0.0806090236, 0.343574822, 0.893112779, -0.102749951, -0.437940747, 0.10274899, 0.99442327, -0.0237714648, 0.437940925, -0.023767367, 0.898689568) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.0489639714, 1.50584114, -0.159462333, 0.917611539, -0.0212566666, 0.396909863, -0.0808075443, 0.967738926, 0.238645718, -0.389177918, -0.251057357, 0.88629055) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.47468996, 1.32399917, 0.219472021, 0.895446956, -0.22061184, -0.386659205, -0.109079421, -0.950824082, 0.289888918, -0.431597739, -0.217403531, -0.875476599) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.113010496, 0.89773041, -1.32594466, 0.553194046, -0.717549801, -0.423200577, -0.775997639, -0.628629804, 0.0515023172, -0.302991927, 0.299911916, -0.904571176) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.867811084, -1.71833193, 0.309154332, 0.948808134, -0.268522114, 0.166310176, 0.151782319, 0.849384427, 0.505478561, -0.276993394, -0.454359174, 0.84665972) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.804791272, -1.30039334, -0.143787146, 0.713350534, -0.0571845397, 0.698470473, -0.38523373, 0.800579727, 0.45898509, -0.585428119, -0.596491575, 0.549064577) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, 0, -4.65661287E-10, 0, 1, 4.65661287E-10, -4.65661287E-10, 4.65661287E-10, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.927955568, 0.717632592, 1.4129522E-6, 0.786211729, 0.617957413, -3.1250529E-6, -0.617957413, 0.786211729, -3.34973447E-6, 3.85567546E-7, 4.56458656E-6, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
			hitfloor, posfloor = RayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 6, Character)
		end
		Humanoid.WalkSpeed = 0
		for i = 0, 1, 0.2 do
			swait()
			dabfastman({
				CFrame.new(0.680794418, -1.34196782, -1.35754502, 0.26213792, -8.39823997E-8, 0.965030432, -0.121110953, 0.992093682, 0.0328982957, -0.95740062, -0.125499636, 0.260065347) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0698575079, 1.49525535, -0.130194128, 0.472510725, 0.0857421607, -0.877144277, 0.0320668593, 0.99292469, 0.114334047, 0.880741417, -0.0821513087, 0.466418087) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.65827823, 0.392011642, -0.86671114, 0.542660236, -0.343087137, -0.766688466, -0.455404401, 0.646795273, -0.611770034, 0.705780864, 0.681136668, 0.194746718) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.60624743, 0.283210725, -0.375073671, 0.330699682, 0.306227177, -0.892671764, -0.446683615, 0.884019494, 0.137780398, 0.831331193, 0.353177875, 0.429131597) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.491029203, -1.10130107, 0.698020339, 0.937855303, 0.293870389, -0.184574857, 0.0601726063, 0.386108577, 0.920488775, 0.341770291, -0.874391437, 0.344430983) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.681176841, -0.930848837, -0.184899256, 0.95235455, 0.0446866453, 0.301702023, -0.0432672203, 0.998998702, -0.0113892872, -0.301908851, -0.00220716745, 0.953334212) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 1.49011612E-8, 0, 1.00000024, 4.47034836E-8, 1.49011612E-8, 4.47034836E-8, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.680045187, 0.450660825, -0.44566977, 0.896210074, 0.443254888, 0.0182429031, -0.40747866, 0.806221783, 0.428914607, 0.175410658, -0.3918311, 0.903160989) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.6, false)
		end
		local num2 = 0
		local num = 0
		CamShake(RootPart, 10, 1, 25)
		local hitfloor2, posfloor2 = RayCast(Hitbox.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
		local ref2 = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "Reference", Vector3.new())
		ref2.Anchored = true
		ref2.CFrame = CFrame.new(posfloor2) * CFrame.new(0, -0.2, 0)
		game:GetService("Debris"):AddItem(ref2, 5)
		CFuncs.Sound.Create("838393216", ref2, 2, 0.8, 5)
		CFuncs.Sound.Create("834070282", ref2, 2, 0.8, 5)
		CFuncs.Sound.Create("824697277", ref2, 2, 0.75, 5)
		CFuncs.Sound.Create("834070239", ref2, 2, 0.76, 5)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, math.rad(-5, 5), 0), 0.5, 0.01, 0.5, 4, 1, 4, 0.1, 1, ref2)
		Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, math.rad(-10, 10), 0), 0.5, 0.1, 0.5, 3, 2, 3, 0.1, 1, ref2)
		Effects.Sphere.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 0.5, 0.01, 0.5, 3, 0.5, 3, 0.1, 1, ref2)
		for i = 0, 1, 0.025 do
			swait()
			num = num + 5
			num2 = num2 + 1
			if num2 == 8 then
				num2 = 0
				for i = 1, 3 do
					Effects.Feather.Create("Glass", BrickColor.new("Toothpaste"), ref2.CFrame * CFrame.Angles(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), 0.5, 0.02, 0.5, 5, 0.01, 5, 0.1)
				end
				for i = 1, 3 do
					Effects.Feather.Create("Neon", BrickColor.new("Toothpaste"), ref2.CFrame * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.1, 0.02, 0.1, 3, 0.01, 3, 0.1)
				end
				CFuncs.Sound.Create("834070340", ref2, 0.7, 0.8, 5)
				CFuncs.Sound.Create("824697277", ref2, 0.7, 0.8, 5)
				MagnitudeDamage(ref2, 25, 5, 15, math.random(1, 5), "Knockdown", 0.2)
				Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 - num, 0), 0.5, 0.01, 0.5, 4, 1, 4, 0.1, 1, ref2)
				Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 - num, 0), 0.5, 0.1, 0.5, 3, 2, 3, 0.1, 1, ref2)
				Effects.Wave.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 + num, 0), 1, 0.01, 1, 6, 1, 6, 0.1, 1, ref2)
				Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 + num, 0), 1, 0.1, 1, 4, 2, 4, 0.1, 1, ref2)
				Effects.Wave.Create("Neon", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position) * CFrame.Angles(0, 0 - num, 0), 1, 0.1, 1, 7, 1, 7, 0.1, 1, ref2)
				Effects.Sphere.Create("Glass", BrickColor.new("Toothpaste"), CFrame.new(ref2.Position), 1, 0.01, 1, 5, 0.5, 5, 0.1, 1, ref2)
			end
			dabfastman({
				CFrame.new(0.680794418, -1.34196782, -1.35754502, 0.26213792, -8.39823997E-8, 0.965030432, -0.121110953, 0.992093682, 0.0328982957, -0.95740062, -0.125499636, 0.260065347) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0698575079, 1.49525535, -0.130194128, 0.472510725, 0.0857421607, -0.877144277, 0.0320668593, 0.99292469, 0.114334047, 0.880741417, -0.0821513087, 0.466418087) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.65827823, 0.392011642, -0.86671114, 0.542660236, -0.343087137, -0.766688466, -0.455404401, 0.646795273, -0.611770034, 0.705780864, 0.681136668, 0.194746718) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.60624743, 0.283210725, -0.375073671, 0.330699682, 0.306227177, -0.892671764, -0.446683615, 0.884019494, 0.137780398, 0.831331193, 0.353177875, 0.429131597) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.491029203, -1.10130107, 0.698020339, 0.937855303, 0.293870389, -0.184574857, 0.0601726063, 0.386108577, 0.920488775, 0.341770291, -0.874391437, 0.344430983) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.681176841, -0.930848837, -0.184899256, 0.95235455, 0.0446866453, 0.301702023, -0.0432672203, 0.998998702, -0.0113892872, -0.301908851, -0.00220716745, 0.953334212) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 1.49011612E-8, 0, 1.00000024, 4.47034836E-8, 1.49011612E-8, 4.47034836E-8, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.680045187, 0.450660825, -0.44566977, 0.896210074, 0.443254888, 0.0182429031, -0.40747866, 0.806221783, 0.428914607, 0.175410658, -0.3918311, 0.903160989) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.5, false)
		end
		Attack = false
	end,
	T = function(Mode)
		Attack = true
		if HotChocolate == false and Mode == "Equip" then
			Humanoid.WalkSpeed = 5
			for i = 0, 1, 0.05 do
				swait()
				dabfastman({
					CFrame.new(-0.144982129, -0.0543930531, 0.290406853, 0.8961097, -6.11343504E-30, 0.443832844, -4.64782191E-30, 1, 2.31582558E-29, -0.443832844, -2.2815189E-29, 0.8961097) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.0137862787, 1.48489678, -0.0785279572, 0.854742229, -0.103415251, 0.508646488, 0, 0.979951143, 0.19923836, -0.519052923, -0.170297444, 0.837605596) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.64116085, 0.459898472, 0.0939864814, 0.592685103, -0.799643993, -0.0964060053, 0.0778490156, 0.176007971, -0.981305659, 0.801663399, 0.574100077, 0.166568786) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-1.28194547, 0.0685342103, 0.60214293, 0.89462018, 0.0489674807, -0.444136471, 0.0608869791, 0.97134614, 0.229738161, 0.442659885, -0.232570514, 0.866004348) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.72146529, -1.97756302, -0.189664334, 0.889358401, -0.0576422885, -0.453562915, 0.0427729972, 0.998159766, -0.0429834388, 0.455205977, 0.0188274346, 0.890187204) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.764986753, -1.98597372, 0.128485292, 0.908346355, 0.037190266, -0.41656214, -0.0307920109, 0.999282122, 0.0220705532, 0.417083919, -0.00722092018, 0.908839464) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0, 0, 0, 1, 0, 0, 0, 1.00000012, -2.98023224E-8, 0, -2.98023224E-8, 0.99999994) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.465316415, 0.234848887, -0.109344482, 0.126012757, -0.989975452, -0.0637924671, 0.988414705, 0.130777851, -0.0770306289, 0.0846010447, -0.0533465594, 0.994985819) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.2, false)
			end
			Mug.Parent = Character
			CupHat.Parent = MugHandle
			CupHat.Position = Vector3.new(0, 0, 0.45)
			
			HotChocolate = true
		elseif HotChocolate == true and Mode == "Chug" then
			Humanoid.WalkSpeed = 2
			CFuncs.Sound.Create("1255349866", Head, 5, 1, 5)
			for i = 0, 1, 0.01 do
				swait()
				dabfastman({
					CFrame.new(0, -0.0543932915, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(4.83369897E-30, 1.49443936, 0.0997710377, 1, 1.47387446E-29, 1.39375397E-28, 6.11343504E-30, 0.988921463, -0.148440078, -1.40019127E-28, 0.148440078, 0.988921463) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.64117444, 0.459899426, 0.0939853564, 0.592685103, -0.799643755, -0.0964059979, 0.0778490156, 0.176008001, -0.981305659, 0.80166316, 0.574100137, 0.166568816) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-1.48844874, 0.778069854, -0.573535144, 0.483993053, -0.874866545, -0.0189584959, -0.555563033, -0.290465266, -0.779089034, 0.676092029, 0.387606323, -0.62662667) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.624835432, -1.98672044, -6.97560608E-7, 0.993490994, -0.0576418377, -0.0982501656, 0.0554959998, 0.998159766, -0.0244375691, 0.0994779989, 0.0188260116, 0.994861662) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.596176028, -1.99311066, 0.010477297, 0.978542984, 0.037199311, 0.202656999, -0.0378899984, 0.999281883, -4.71732637E-4, -0.202528998, -0.00721706357, 0.979249656) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0, 0, 0, 1, 7.4505806E-9, -1.49011612E-8, 7.4505806E-9, 1.00000012, 2.98023224E-8, -1.49011612E-8, 2.98023224E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.465318471, 0.23487708, -0.109372929, 0.126014709, -0.989975095, -0.0637930036, 0.988414645, 0.130779743, -0.077029109, 0.0845997632, -0.0533471256, 0.994985938) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.15, false)
			end
			Mug.Parent = nil
			CupHat.Parent = CupHatHandle
			CupHat.Position = Vector3.new()
			for i = 0, 1, 0.1 do
				swait()
				dabfastman({
					CFrame.new(-0.144982129, -0.0543930531, 0.290406853, 0.8961097, -6.11343504E-30, 0.443832844, -4.64782191E-30, 1, 2.31582558E-29, -0.443832844, -2.2815189E-29, 0.8961097) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.0137862787, 1.48489678, -0.0785279572, 0.854742229, -0.103415251, 0.508646488, 0, 0.979951143, 0.19923836, -0.519052923, -0.170297444, 0.837605596) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.64116085, 0.459898472, 0.0939864814, 0.592685103, -0.799643993, -0.0964060053, 0.0778490156, 0.176007971, -0.981305659, 0.801663399, 0.574100077, 0.166568786) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-1.28194547, 0.0685342103, 0.60214293, 0.89462018, 0.0489674807, -0.444136471, 0.0608869791, 0.97134614, 0.229738161, 0.442659885, -0.232570514, 0.866004348) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.72146529, -1.97756302, -0.189664334, 0.889358401, -0.0576422885, -0.453562915, 0.0427729972, 0.998159766, -0.0429834388, 0.455205977, 0.0188274346, 0.890187204) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-0.764986753, -1.98597372, 0.128485292, 0.908346355, 0.037190266, -0.41656214, -0.0307920109, 0.999282122, 0.0220705532, 0.417083919, -0.00722092018, 0.908839464) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0, 0, 0, 1, 0, 0, 0, 1.00000012, -2.98023224E-8, 0, -2.98023224E-8, 0.99999994) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.465316415, 0.234848887, -0.109344482, 0.126012757, -0.989975452, -0.0637924671, 0.988414705, 0.130777851, -0.0770306289, 0.0846010447, -0.0533465594, 0.994985819) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.3, false)
			end
			HotChocolate = false
		end
		Humanoid.WalkSpeed = 16
		Attack = false
	end
}
Mouse.Button1Down:connect(function()
	if Attack == false and Equipped == true and Combo == 1 and Sprinting == false and HotChocolate == false then
		Combo = Combo + 1
		ClickCombo["1"]()
	elseif Attack == false and Equipped == true and Combo == 2 and Sprinting == false and HotChocolate == false then
		Combo = Combo + 1
		ClickCombo["2"]()
	elseif Attack == false and Equipped == true and Combo == 3 and Sprinting == false and HotChocolate == false then
		Combo = Combo + 1
		ClickCombo["3"]()
	elseif Attack == false and Equipped == true and Combo == 4 and Sprinting == false and HotChocolate == false then
		Combo = Combo - 3
		ClickCombo["4"]()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			if Attack == false then
				swait()
			end
		end
		if Attack == false then
			Combo = 1
		end
	end))
end)
Mouse.KeyDown:connect(function(Key)
	Key = Key:lower()
	if Attack == false and Equipped == false and Key == "f" and Sprinting == false and HotChocolate == false then
		Equip.Equip()
	elseif Attack == false and Equipped == true and Key == "f" and Sprinting == false and HotChocolate == false then
		Equip.Unequip()
	elseif Attack == false and Equipped == true and Key == "e" and Sprinting == false and Charged == false and cooldownE >= coE and HotChocolate == false then
		Skills.E()
	elseif Attack == false and Equipped == true and Key == "t" and Sprinting == false and HotChocolate == false then
		Skills.T("Equip")
	elseif Attack == false and Equipped == true and Key == "t" and Sprinting == false and HotChocolate == true then
		Skills.T("Chug")
	elseif Attack == false and Equipped == true and Key == "z" and Sprinting == false and cooldown1 >= co1 and HotChocolate == false then
		Skills.Z()
	elseif Attack == false and Equipped == true and Key == "x" and Sprinting == false and cooldown2 >= co2 and HotChocolate == false then
		Skills.X()
	elseif Attack == false and Equipped == true and Key == "c" and Sprinting == false and cooldown3 >= co3 and HotChocolate == false then
		Skills.C()
	elseif Attack == false and Equipped == true and Key == "v" and Sprinting == false and cooldown4 >= co4 and HotChocolate == false then
		Skills.V()
	end
end)
Mouse.KeyUp:connect(function(Key)
end)
function updateskills()
	if cooldown1 <= co1 then
		cooldown1 = cooldown1 + 0.03333333333333333
	end
	if cooldown2 <= co2 then
		cooldown2 = cooldown2 + 0.03333333333333333
	end
	if cooldown3 <= co3 then
		cooldown3 = cooldown3 + 0.03333333333333333
	end
	if cooldown4 <= co4 then
		cooldown4 = cooldown4 + 0.03333333333333333
	end
	if cooldownE <= coE then
		cooldownE = cooldownE + 0.03333333333333333
	end
end
local num1 = 0
local num2 = 0
local Idle = 0
ArtificialHB.Event:connect(function()
	updateskills()
	NumberNabel.Text = "(" .. Charges .. ")"
	att4:TweenSize(UDim2.new(1 * (cooldown4 / co4), 0, 1, 0), "Out", "Quad", 0.5)
	att3:TweenSize(UDim2.new(1 * (cooldown3 / co3), 0, 1, 0), "Out", "Quad", 0.5)
	att1:TweenSize(UDim2.new(1 * (cooldown1 / co1), 0, 1, 0), "Out", "Quad", 0.5)
	att2:TweenSize(UDim2.new(1 * (cooldown2 / co2), 0, 1, 0), "Out", "Quad", 0.5)
	skillE:TweenSize(UDim2.new(1 * (cooldownE / coE), 0, 1, 0), "Out", "Quad", 0.5)
	if Charged == true and Equipped == true then
		num1 = num1 + 1
		if num1 == 15 then
			num1 = 0
			Glow.Enabled = true
			Wave4.Enabled = true
		end
	elseif Charged == false and Equipped == true then
		Glow.Enabled = false
		Wave4.Enabled = false
	end
	if Sprinting == true and Attack == false then
		Humanoid.WalkSpeed = 30
	elseif Sprinting == false and Attack == false then
		Humanoid.WalkSpeed = 16
	end
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("BasePart") then
			--v.Material = "SmoothPlastic"
		elseif v:IsA("Accessory") then
			--v:WaitForChild("Handle").Material = "SmoothPlastic"
		end
	end
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("Model") then
			for _, c in pairs(v:GetChildren()) do
				if c:IsA("BasePart") then
					--c.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
				end
			end
		end
	end
	for i, v in pairs(InnerModel:GetChildren()) do
		if v:IsA("BasePart") then
			v.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		end
	end
	TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
	Velocity = RootPart.Velocity.y
	Sine = Sine + Change
	local Hit, pos = RayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
	if 1 < RootPart.Velocity.y and Hit == nil then
		Anim = "Jump"
		if Attack == false and Equipped == true and HotChocolate == false then
			Change = 1
			dabfastman({
				CFrame.new(-0.0274927709, 0.21937117, -0.0510279536, 0.900237024, -1.40853004E-7, -0.435400218, -0.0843020007, 0.981076658, -0.17430383, 0.427161008, 0.193619862, 0.88320148) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0460833162, 1.51987338, -0.0952871442, 0.916015565, -0.110861942, 0.385519385, 0.00484909769, 0.964042723, 0.26570338, -0.401113451, -0.241519004, 0.883615673) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.42945409, 0.799360335, -0.411998004, 0.502704203, -0.171164155, -0.847343802, -0.858971238, -0.209173158, -0.467349172, -0.0972481668, 0.962782204, -0.252177328) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.47013378, 0.874914885, -0.410976887, 0.235080078, 0.373714209, -0.897259831, -0.896327972, -0.273699582, -0.348833531, -0.375943661, 0.886242747, 0.270629227) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.984357595, -1.76956046, 0.301810026, 0.804436922, -0.306579411, 0.508812666, 0.0343034305, 0.879076958, 0.475444019, -0.593046784, -0.365010738, 0.717678726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.907797515, -1.3705337, -0.255137146, 0.780938208, -0.122315392, 0.612514973, -0.0516595617, 0.964630306, 0.258494973, -0.622468472, -0.233510822, 0.746997774) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 0.99999994, -2.98023224E-8, 9.31322575E-9, -2.98023224E-8, 1.00000012, 1.11758709E-8, 9.31322575E-9, 1.11758709E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.43611586, 0.280921549, -0.845455408, 0.939902544, 0.15253222, -0.305478513, -0.163774729, 0.986432433, -0.0113576651, 0.299601525, 0.0607047752, 0.952131271) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		elseif Attack == false and Equipped == true and HotChocolate == true then
			Change = 1
			dabfastman({
				CFrame.new(3.47839852E-31, 0.0196196362, 0.00334085221, 1, 1.46486773E-29, 1.39384895E-28, 6.11343504E-30, 0.989017129, -0.147800997, -1.40019127E-28, 0.147801012, 0.989017129) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 1.54453588, -0.160235062, 1, 0, 0, 0, 0.974547744, 0.224180326, 0, -0.224180311, 0.974547744) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.76083958, 0.710659146, 0.111540474, 0.536122143, -0.814865828, 0.220378816, 0.212927043, -0.122084789, -0.969410896, 0.816844702, 0.566647232, 0.108054593) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.1412164, 0.25268954, -0.674227059, 0.517715871, -0.855373859, -0.0174897388, 0.154453218, 0.113550618, -0.9814533, 0.841495514, 0.505412579, 0.190902174) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.751418352, -1.81905162, 0.279249936, 0.969890773, -0.14491488, -0.195733741, 0.202510983, 0.926331162, 0.317647576, 0.135282427, -0.347721636, 0.927786827) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.623396039, -1.53911889, -0.205893815, 0.946982741, -0.0177490916, 0.320793897, -0.0691830069, 0.963784337, 0.257552981, -0.313747436, -0.266091675, 0.911459208) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000024, -1.86264515E-8, 0, -1.86264515E-8, 1.00000012, 0, 0, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.46531713, 0.234888345, -0.109387472, 0.126019284, -0.989974678, -0.0637920275, 0.988413811, 0.130784303, -0.0770311356, 0.0846018493, -0.0533454977, 0.994985819) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		elseif Attack == false and Equipped == false and HotChocolate == false then
			Change = 1
			HandleWeld.C0 = Lerp(HandleWeld.C0, CFrame.new(1.3, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
	elseif RootPart.Velocity.y < -1 and Hit == nil then
		Anim = "Fall"
		if Attack == false and Equipped == true and HotChocolate == false then
			Change = 1
			dabfastman({
				CFrame.new(-0.0274898838, 0.388155729, -0.0312597714, 0.900236785, -8.71947009E-7, -0.435400724, 0.0895989761, 0.978597581, 0.185253367, 0.426081896, -0.205783337, 0.880969644) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.0460886881, 1.51987743, -0.0952962637, 0.916015446, -0.0828983709, 0.39248395, 0.00484738313, 0.980629861, 0.195810199, -0.401113838, -0.177462637, 0.898673892) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.63392329, 0.804011881, -0.428579718, 0.528447866, -0.0524461269, -0.847344279, -0.788960814, -0.398908585, -0.467346549, -0.313502401, 0.915489793, -0.252180338) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.35854971, 0.799372673, -0.138400257, 0.297937214, 0.325811267, -0.897262871, -0.9307639, -0.109523848, -0.348831266, -0.211924851, 0.939069629, 0.270622164) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.772426426, -1.83609092, -0.376343131, 0.974063814, -0.212318122, 0.078235656, 0.207656786, 0.976129413, 0.063640818, -0.089880228, -0.0457440615, 0.994901657) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.0672518, -1.38919103, -0.453640372, 0.780939758, 0.207659841, 0.589076161, -0.0516600423, 0.961358249, -0.270410091, -0.622466564, 0.180742294, 0.761490524) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1.00000012, -2.98023224E-8, 1.86264515E-8, -2.98023224E-8, 1, 0, 1.86264515E-8, 0, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.43611097, 0.280927509, -0.845453143, 0.939902663, 0.152526826, -0.305481225, -0.163770765, 0.986433029, -0.0113626793, 0.299603701, 0.0607087016, 0.952130318) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		elseif Attack == false and Equipped == true and HotChocolate == true then
			Change = 1
			dabfastman({
				CFrame.new(1.86108764E-29, -0.078636542, 0.129483283, 1, -3.15237056E-29, 1.36561301E-28, 6.11343504E-30, 0.983260095, 0.182208017, -1.40019127E-28, -0.182208017, 0.983260095) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 1.53475773, -0.0598594248, 1, 0, 0, 0, 0.989017248, 0.147801131, 0, -0.147801131, 0.989017248) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(1.8767395, 0.739583552, 0.0959399492, 0.558409154, -0.795617104, 0.234888703, 0.263630658, -0.0982716158, -0.959605098, 0.786560953, 0.597776115, 0.154873312) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.992145002, 0.448814422, -0.705394924, 0.471656829, -0.880355537, -0.0501405001, -0.177079991, -0.0388608426, -0.983429074, 0.863818705, 0.472719908, -0.174222335) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.63266933, -1.86463571, -0.146403193, 0.993491769, -0.0626441911, -0.0951307565, 0.0554979295, 0.995562613, -0.0759951398, 0.0994692668, 0.0702209696, 0.99255991) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.725492597, -1.5021981, -0.706171095, 0.978542745, 0.0892720893, 0.185700208, -0.0378896482, 0.963860393, -0.263700247, -0.202530131, 0.251005828, 0.946561038) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0, 0, 0, 1, 0, 2.98023224E-8, 0, 1.00000012, -2.98023224E-8, 2.98023224E-8, -2.98023224E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.4653036, 0.234840721, -0.109349005, 0.12601772, -0.989975214, -0.0637866706, 0.988414228, 0.130782172, -0.0770287514, 0.0845986903, -0.0533407032, 0.994986296) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		elseif Attack == false and Equipped == false and HotChocolate == false then
			Change = 1
			HandleWeld.C0 = Lerp(HandleWeld.C0, CFrame.new(1.3, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
	elseif TorsoVelocity < 1 and Hit ~= nil then
		Anim = "Idle"
		if Attack == false and Equipped == true and HotChocolate == false then
			Change = 1
			dabfastman({
				CFrame.new(-0.0274939425, -0.145706117, -0.134886444, 0.900237024, 3.689008E-7, -0.435400307, 0.0291269999, 0.997759879, 0.0602240451, 0.434424996, -0.066897817, 0.898220241) * CFrame.new(0, 0 - 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.15483999E-6, 1.49999201, -3.96370888E-6, 0.916150928, -0.0563836023, 0.396848381, -2.90060416E-6, 0.990056276, 0.140672371, -0.400833726, -0.128878236, 0.907040715) * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine / 25)) * CFrame.Angles(0 + 0.1 * math.cos(Sine / 25), 0, 0),
				CFrame.new(1.53845167, 0.599175274, -0.407200664, 0.445906848, -0.288399786, -0.847344637, -0.884051144, 0.00624460727, -0.467348725, 0.140074551, 0.957489729, -0.25217554) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.1 * math.cos(Sine / 25), 0 - 0.1 * math.cos(Sine / 25), 0),
				CFrame.new(-1.4091543, 0.398346066, -0.823092222, 0.330762148, 0.292448342, -0.897257328, -0.937126875, -0.0103569143, -0.348835289, -0.111309089, 0.956225276, 0.270635486) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.1 * math.cos(Sine / 25), 0 - 0.1 * math.cos(Sine / 25), 0),
				CFrame.new(0.727466404, -1.95815933, -0.057563208, 0.968764424, -0.0359124467, 0.245369121, 0.0370447598, 0.999313772, 5.96046448E-7, -0.245200649, 0.00908906758, 0.969429791) * CFrame.new(0, 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 - 0.1 * math.cos(Sine / 25), 0 - 0.04 * math.cos(Sine / 25)),
				CFrame.new(-0.844141662, -1.87255275, -0.133616924, 0.858743906, 0.0739646628, 0.507038772, -0.0585709922, 0.997210383, -0.0462703332, -0.509046674, 0.0100366082, 0.860680401) * CFrame.new(0, 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 + 0.1 * math.cos(Sine / 25), 0 + 0.04 * math.cos(Sine / 25)),
				CFrame.new(0, 0, 0, 1.00000024, 2.98023224E-8, -4.47034836E-8, 2.98023224E-8, 1.00000012, 0, -4.47034836E-8, 0, 1) * CFrame.new(0 + 0.1 * math.cos(Sine / 25), 0 + 0.05 * math.cos(Sine / 25), 0) * CFrame.Angles(0 + 0.1 * math.cos(Sine / 25), 0 + 0.1 * math.cos(Sine / 25), 0),
				CFrame.new(-1.43611443, 0.280924916, -0.845453739, 0.939904571, 0.152533174, -0.305472285, -0.163774967, 0.986432493, -0.0113569796, 0.299595356, 0.0607031584, 0.952133298) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		elseif Attack == false and Equipped == true and HotChocolate == true then
			Idle = Idle + 1
			if Idle == 550 then
				Idle = 0
			end
			Change = 0.6
			if Idle <= 450 then
				dabfastman({
					CFrame.new(0, -0.0543932915, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0 - 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-9.17015519E-30, 1.50000048, -3.42227941E-29, 1, -6.11343504E-30, 1.39302681E-28, 6.11343504E-30, 1, 2.2815189E-29, -1.39230266E-28, -2.2815189E-29, 1) * CFrame.new(0, 0, -0.05 - 0.05 * math.cos(Sine / 25)) * CFrame.Angles(math.rad(-5) - 0.1 * math.cos(Sine / 25), 0, 0),
					CFrame.new(1.64117587, 0.459899724, 0.0939937383, 0.592685103, -0.799643755, -0.0964059979, 0.0778490156, 0.176008001, -0.981305659, 0.80166316, 0.574100137, 0.166568816) * CFrame.new(0, 0 + 0.05 * math.cos(Sine / 25), 0) * CFrame.Angles(0 + 0.05 * math.cos(Sine / 25), 0, 0),
					CFrame.new(-1.14336538, 0.255015373, -0.678383112, 0.500623822, -0.85537672, -0.133065686, -0.0694229752, 0.113548957, -0.991103947, 0.862876713, 0.505408108, -0.00253748544) * CFrame.new(0, 0 - 0.05 * math.cos(Sine / 25), 0) * CFrame.Angles(0 + 0.05 * math.cos(Sine / 25), 0 - 0.05 * math.cos(Sine / 25), 0),
					CFrame.new(0.624835253, -1.98672044, 1.19954348E-6, 0.993490994, -0.0576418377, -0.0982501656, 0.0554959998, 0.998159766, -0.0244375691, 0.0994779989, 0.0188260116, 0.994861662) * CFrame.new(0 + 0.01 * math.cos(Sine / 25), 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 - 0.05 * math.cos(Sine / 25), 0 + 0.01 * math.cos(Sine / 25)),
					CFrame.new(-0.596175253, -1.99311042, 0.0104810372, 0.978542984, 0.037199311, 0.202656999, -0.0378899984, 0.999281883, -4.71732637E-4, -0.202528998, -0.00721706357, 0.979249656) * CFrame.new(0 - 0.01 * math.cos(Sine / 25), 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 + 0.05 * math.cos(Sine / 25), 0 - 0.01 * math.cos(Sine / 25)),
					CFrame.new(0, 0, 0, 1, 7.4505806E-9, -1.49011612E-8, 7.4505806E-9, 1.00000012, 2.98023224E-8, -1.49011612E-8, 2.98023224E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.465317518, 0.234880388, -0.109365053, 0.126014709, -0.989975095, -0.0637930036, 0.988414645, 0.130779743, -0.077029109, 0.0845997632, -0.0533471256, 0.994985938) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.2, false)
			elseif Idle >= 450 then
				dabfastman({
					CFrame.new(0, -0.0543932915, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0 - 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(-1.61695105E-29, 1.49443984, -0.0502313524, 1, -2.14842932E-29, 1.38496054E-28, 6.11343504E-30, 0.993927002, 0.110041998, -1.40019127E-28, -0.110041998, 0.993927002) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(1.64117754, 0.45989874, 0.093983151, 0.592685103, -0.799643755, -0.0964059979, 0.0778490156, 0.176008001, -0.981305659, 0.80166316, 0.574100137, 0.166568816) * CFrame.new(0, 0 + 0.05 * math.cos(Sine / 25), 0) * CFrame.Angles(0 + 0.05 * math.cos(Sine / 25), 0, 0),
					CFrame.new(-1.50132322, 0.694287181, -0.433155239, 0.504928887, -0.859635532, -0.0779337212, -0.406801909, -0.157365054, -0.899860263, 0.761287808, 0.486069053, -0.429159492) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.624835432, -1.98672044, -6.97560608E-7, 0.993490994, -0.0576418377, -0.0982501656, 0.0554959998, 0.998159766, -0.0244375691, 0.0994779989, 0.0188260116, 0.994861662) * CFrame.new(0 + 0.01 * math.cos(Sine / 25), 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 - 0.05 * math.cos(Sine / 25), 0 + 0.01 * math.cos(Sine / 25)),
					CFrame.new(-0.596174479, -1.99311042, 0.0104847699, 0.978542984, 0.037199311, 0.202656999, -0.0378899984, 0.999281883, -4.71732637E-4, -0.202528998, -0.00721706357, 0.979249656) * CFrame.new(0 - 0.01 * math.cos(Sine / 25), 0 + 0.1 * math.cos(Sine / 25), 0) * CFrame.Angles(0, 0 + 0.05 * math.cos(Sine / 25), 0 - 0.01 * math.cos(Sine / 25)),
					CFrame.new(0, 0, 0, 1, 7.4505806E-9, -1.49011612E-8, 7.4505806E-9, 1.00000012, 2.98023224E-8, -1.49011612E-8, 2.98023224E-8, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
					CFrame.new(0.465317518, 0.234875903, -0.109357744, 0.126014709, -0.989975095, -0.0637930036, 0.988414645, 0.130779743, -0.077029109, 0.0845997632, -0.0533471256, 0.994985938) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
				}, 0.1, false)
			end
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		elseif Attack == false and Equipped == false and HotChocolate == false then
			Change = 1
			HandleWeld.C0 = Lerp(HandleWeld.C0, CFrame.new(1.3, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
	elseif TorsoVelocity > 2 and Hit ~= nil then
		Anim = "Walk"
		if Attack == false and Equipped == true and Sprinting == false and HotChocolate == false then
			Change = 2.2
			dabfastman({
				CFrame.new(-0.0570193529, -0.0866228044, -0.269750923, 0.76604414, -2.85373716E-8, -0.642788112, 0.0515330061, 0.996781111, 0.0614145286, 0.640719056, -0.0801710263, 0.763578355) * CFrame.new(0, 0 - 0.1 * math.cos(Sine / 5), 0) * CFrame.Angles(0, 0 - 0.1 * math.cos(Sine / 10), 0),
				CFrame.new(-0.0336059332, 1.49374294, -0.0410972536, 0.77413559, -0.0740856007, 0.628669798, 9.55769792E-8, 0.993127763, 0.117035031, -0.633020103, -0.0906009153, 0.768815577) * CFrame.new(0, 0, 0 - 0.005 * math.cos(Sine / 5)) * CFrame.Angles(math.rad(3) - 0.01 * math.cos(Sine / 5), 0 + 0.1 * math.cos(Sine / 10), 0),
				CFrame.new(1.40797424, 0.546426535, 0.0613539219, 0.192165062, -0.567650139, -0.800528646, -0.979104817, -0.0555967167, -0.195608571, 0.0665304661, 0.821390629, -0.566472769) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.1 * math.cos(Sine / 10), 0, 0),
				CFrame.new(-1.25865018, 0.344390363, -0.765005469, 0.37408638, -0.0229729116, -0.92710948, -0.916214108, 0.145603552, -0.373298019, 0.143566191, 0.989076316, 0.0334202349) * CFrame.new(0, 0, 0) * CFrame.Angles(0.2 - 0.1 * math.cos(Sine / 10), 0, 0),
				CFrame.new(0.745035887, -1.99999499, 0.0326879621, 0.76604414, 3.7252903E-8, 0.642788112, -2.85373716E-8, 1, -2.98023224E-8, -0.642788112, 0, 0.76604414) * CFrame.new(0.05, 0.15 + 0.25 * math.cos(Sine / 10), 0 - 0.65 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(40) * math.sin(Sine / 10), math.rad(-5), 0),
				CFrame.new(-0.675758719, -1.99999464, -0.0780076683, 0.70710665, -2.08616257E-7, 0.707107127, 3.19909304E-7, 1, -1.49011612E-8, -0.707107127, 2.4586916E-7, 0.70710665) * CFrame.new(-0.05, 0.15 + -0.15 * math.cos(Sine / 10), 0.1 + 0.65 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(-40) * math.sin(Sine / 10), math.rad(5), 0),
				CFrame.new(0, 0, 0, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0 + 0.1 * math.cos(Sine / 10), 0, 0),
				CFrame.new(-1.4337008, 0.489752144, -0.109488308, 0.940220475, 0.294532895, 0.170985073, -0.289780319, 0.955641508, -0.0526973829, -0.178921551, -9.68575478E-7, 0.983863413) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		elseif Attack == false and Equipped == true and Sprinting == false and HotChocolate == true then
			Change = 2
			dabfastman({
				CFrame.new(-3.00767935E-29, -0.105914138, -0.219429284, 1, -2.64377128E-29, 1.37636391E-28, 6.11343504E-30, 0.989340782, 0.145618975, -1.40019127E-28, -0.145618975, 0.989340782) * CFrame.new(0, 0 - 0.1 * math.cos(Sine / 5), 0) * CFrame.Angles(0, 0 + 0.05 * math.cos(Sine / 10), 0),
				CFrame.new(0, 1.49658871, 0.0391186401, 1, 0, 0, 0, 0.99622643, -0.0867936164, 0, 0.0867936164, 0.99622643) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.05 * math.cos(Sine / 10), 0),
				CFrame.new(1.62375188, 0.448580325, 0.376748979, 0.358886898, -0.924232244, -0.130365476, 0.0670671761, 0.164843842, -0.984036922, 0.930968463, 0.344414711, 0.121145934) * CFrame.new(0 - 0.05 * math.cos(Sine / 5), 0 - 0.05 * math.cos(Sine / 5), 0) * CFrame.Angles(0 + 0.05 * math.cos(Sine / 5), 0 - 0.05 * math.cos(Sine / 5), 0),
				CFrame.new(-1.01762652, 0.254960984, -0.627272189, 0.51302588, -0.856237769, -0.0605102181, -0.17419824, -0.034827251, -0.98409456, 0.840511441, 0.515406728, -0.167022362) * CFrame.new(0 - 0.05 * math.cos(Sine / 5), 0, 0) * CFrame.Angles(0 + 0.05 * math.cos(Sine / 5), 0, 0),
				CFrame.new(0.5, -1.99999905, 3.81469727E-6, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0.07, 0.1 + 0.2 * math.cos(Sine / 10), 0 - 0.6 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(40) * math.sin(Sine / 10), 0 + 0.05 * math.cos(Sine / 10), math.rad(2)),
				CFrame.new(-0.5, -1.99999905, 3.81469727E-6, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(-0.07, 0.1 - 0.2 * math.cos(Sine / 10), 0 + 0.6 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(-40) * math.sin(Sine / 10), 0 + 0.05 * math.cos(Sine / 10), math.rad(-2)),
				CFrame.new(0, 0, 0, 1.00000012, -1.49011612E-8, 1.49011612E-8, -1.49011612E-8, 1, -2.98023224E-8, 1.49011612E-8, -2.98023224E-8, 1.00000024) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.481275588, 0.329017371, -0.083250463, 0.0896562785, -0.991810918, -0.090956986, 0.985589564, 0.101503432, -0.135315716, 0.143440038, -0.0775143504, 0.986618876) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.2, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		elseif Attack == false and Equipped == true and Sprinting == true and HotChocolate == false then
			Change = 3
			dabfastman({
				CFrame.new(0.0623563975, -0.340262055, 0.00248126686, 0.867089689, -0.0608406998, -0.494422764, 0.298986882, 0.857428432, 0.418835789, 0.398449838, -0.510994077, 0.761657953) * CFrame.new(0, -0.2 - 0.2 * math.cos(Sine / 5), 0) * CFrame.Angles(0, 0 - 0.05 * math.cos(Sine / 10), 0),
				CFrame.new(0.117828026, 1.47632885, 0.0293634236, 0.860120177, 0.19259043, 0.472336829, -0.0353811234, 0.946280003, -0.32140708, -0.508862793, 0.259737015, 0.82072866) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 + 0.05 * math.cos(Sine / 10), 0),
				CFrame.new(1.71113753, 0.636361897, 0.260536194, 0.19216235, -0.910650492, -0.365772069, -0.979105711, -0.152639091, -0.134363443, 0.0665269792, 0.383949131, -0.920954525) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-0.809507251, 0.487178922, -1.02421522, 0.374081224, -0.605117321, -0.702777505, -0.916216254, -0.123831049, -0.381069273, 0.143565953, 0.786447048, -0.600741267) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(0.676813602, -1.99999321, 0.0372357965, 0.866025984, 7.59959221E-7, 0.499999255, -9.64850187E-7, 1.00000012, 1.1920929E-7, -0.499999285, -5.66244125E-7, 0.866025984) * CFrame.new(0.01, 0.15 + 0.25 * math.cos(Sine / 10), -0.1 - 0.65 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(55) * math.sin(Sine / 10), 0, 0),
				CFrame.new(-0.644591153, -1.99998295, 0.0331146717, 0.819152713, -7.4505806E-8, 0.573575437, -4.84287739E-8, 1, 1.78813934E-7, -0.573575437, -1.78813934E-7, 0.819152832) * CFrame.new(-0.01, 0.7 + -0.15 * math.cos(Sine / 10), -0.2 + 0.8 * math.sin(Sine / 10)) * CFrame.Angles(math.rad(-70) * math.sin(Sine / 10), 0, 0),
				CFrame.new(0, 0, 0, 1, -9.77888703E-9, -5.96046448E-8, -9.77888703E-9, 1, -5.12227416E-9, -5.96046448E-8, -5.12227416E-9, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
				CFrame.new(-1.34785247, 1.01227283, 0.0688567162, 0.763132215, 0.645287156, 0.035123229, -0.646080315, 0.760595798, 0.0638308674, 0.0144746602, -0.0714038312, 0.997342467) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
			}, 0.3, false)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		elseif Attack == false and Equipped == false and HotChocolate == false then
			Change = 1
			HandleWeld.C0 = Lerp(HandleWeld.C0, CFrame.new(1.3, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt1.Weld.C0 = Lerp(HandlePrt1.Weld.C0, CFrame.new(1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
			HandlePrt2.Weld.C0 = Lerp(HandlePrt2.Weld.C0, CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
		end
	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Ice" then
							if Thing[6] <= Thing[5] then
								Thing[6] = Thing[6] + 0.05
								Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 0.4, 0)
							else
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							end
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block4" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.new(0, -Thing[1].Size.Y, 0) * CFrame.fromEulerAnglesXYZ(3.14, 0, 0)
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2Fire" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							if Thing[1].Transparency >= 0.3 then
								Thing[1].BrickColor = BrickColor.new("Bright red")
							else
								Thing[1].BrickColor = BrickColor.new("Bright yellow")
							end
						elseif Thing[2] == "Cylinder" then
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder2" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.Angles(0, 0.5, 0)
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, -0.5, 0)
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							Thing[1].Size = Thing[1].Size + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[1].CFrame = Thing[1].CFrame * Thing[11] * CFrame.new(0, 0, 0.2)
							Thing[1].Rotation = Vector3.new(0, 0, 0)
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end)


end)

Section:NewButton("Server Admin", "Moderate the servers and punish..", function()
    print("Clicked")

end)

Section:NewButton("Katanarist", "ButtonInfo", function()
    print("Clicked")
local mt = {
	drandom = function(minNum,maxNum,div)
		div = div or 1
		return math.random(minNum * div,maxNum * div)/div
	end
}
script = game:GetObjects("rbxassetid://8038057972")[1]:FindFirstChildWhichIsA("Script")
local math = setmetatable(mt,{__index = math})
GlobalFunctions = {}
local targetnnn = nil
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
wait(.7)
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
tcnn=Instance.new('Part')
tcnn.CFrame=cnnnnn.Torso.CFrame*CFrame.new(0,-7.5,0)
tcnn.Anchored=true
tcnn.Transparency=1
tcnn.Size = cnnnnn.Torso.Size
tcnn.Name='Anchor'
tcnn.CanCollide=false
tcnn.Parent=workspace
task.spawn(function()
	while task.wait() do
		wait(0.2)
		tcnn.CFrame=CFrame.new(cnnnnn.Torso.CFrame.p.x,-6.5,cnnnnn.Torso.CFrame.p.z)
		tcnn.Anchored=true
	end
end)
local Player = game.Players.LocalPlayer
local Mouse,mouse,UserInputService
do
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInputEvent"
	Event.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true}
		t.Connect = function(self,f)self.Function=f end
		t.connect = t.Connect
		return t
	end
	local m = Player:GetMouse()
	local UIS = game:GetService("UserInputService")
	
	
	Mouse,mouse,UserInputService = m,m,UIS
end
local katanahat = gp(gp(gp(cnnnnn, "OdachiAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
adrelinehat = gp(gp(gp(cnnnnn.Model, "SnowCookie", "Accessory"), "Handle", "BasePart"), "Mesh", "SpecialMesh")
adrelinehat:Destroy()
local adrelinehat = gp(gp(gp(cnnnnn, "SnowCookie", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
adrelinehat.Parent = tcnn 
task.spawn(function()
	while task.wait() do
		if targetnnn ~= nil then
			GlobalFunctions.fling(targetnnn,0.8)
			targetnnn = nil
		end
	end
end)
--[[

-gh 9923864659,6114844034

]]
--BasicFunctions
local ins = Instance.new
local v3 = Vector3.new
local cf = CFrame.new
local angles = CFrame.Angles
local rad = math.rad
local huge = math.huge
local cos = math.cos
local sin = math.sin
local tan = math.tan
local abs = math.abs
local ray = Ray.new
local random = math.random
local drandom = math.drandom
local ud = UDim.new
local ud2 = UDim2.new
local c3 = Color3.new
local rgb = Color3.fromRGB
local bc = BrickColor.new
--script.Client.Disabled = false
--Services
local plrs = game:GetService("Players")
local tweens = game:GetService("TweenService")
local debrs = game:GetService("Debris")
local runservice = game:GetService("RunService")
 
--Variables
local plr = Player
local plrg = plr.PlayerGui
local char = plr.Character
local h = char.Head
local t = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local rut = char.HumanoidRootPart
local hum = char:FindFirstChildOfClass("Humanoid")
local nec = t.Neck
local rutj = rut.RootJoint
local rs = t["Right Shoulder"]
local ls = t["Left Shoulder"]
local rh = t["Right Hip"]
local lh = t["Left Hip"]

necc0,necc1=cf(0,t.Size.Y/2,0),cf(0,-h.Size.Y/2,0)
rutjc0,rutjc1=cf(0,0,0),cf(0,0,0)
rsc0,rsc1=cf(t.Size.X/2,t.Size.Y/4,0),cf(-ra.Size.X/2,ra.Size.Y/4,0)
lsc0,lsc1=cf(-t.Size.X/2,t.Size.Y/4,0),cf(la.Size.X/2,la.Size.Y/4,0)
rhc0,rhc1=cf(t.Size.X/4,-t.Size.Y/2,0),cf(0,rl.Size.Y/2,0)
lhc0,lhc1=cf(-t.Size.X/4,-t.Size.Y/2,0),cf(0,ll.Size.Y/2,0)

local takingAStep = false
local muted = false
local using = false
local wallJump = false
local wallJumpDeb = false
local lightEnabled = false

local anim = "idle"
local asset = "rbxassetid://"

local themeID = 1837107670
local themeVolume = .5
local themePitch = 1
local timePos = 0

local combo = 1

local change = 1
local sine = 0

local ws = 50
local jp = 85

local healthPool = 350
local healPercentage = 0

local ignoreList = {char}

--
local stepsounds = {
	Grass = asset.."1201103066",
	Sand = asset.."1436385526",
	Plastic = asset.."1569994049",
	Stone = asset.."507863857", --379398649
	Wood = asset.."1201103959",
	Pebble = asset.."1201103211",
	Ice = asset.."265653271",
	Glass = asset.."145180170",
	Metal = asset.."379482691"
}

local directions = {In = Enum.EasingDirection.In,
    Out = Enum.EasingDirection.Out,
    InOut = Enum.EasingDirection.InOut
}

local styles = {Linear = Enum.EasingStyle.Linear,
    Back = Enum.EasingStyle.Back,
    Bounce = Enum.EasingStyle.Bounce,
    Sine = Enum.EasingStyle.Sine,
    Quad = Enum.EasingStyle.Quad,
    Elastic = Enum.EasingStyle.Elastic,
    Quart = Enum.EasingStyle.Quart,
    Quint = Enum.EasingStyle.Quint
}

local stepped = runservice.Heartbeat

--Removing joints/Animations
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end

if hum:FindFirstChildOfClass("Animator") then
	char.Humanoid.Animator:Destroy()
end

nec.Parent = nil
rutj.Parent = nil
rs.Parent = nil
ls.Parent = nil
rh.Parent = nil
lh.Parent = nil

--Joints
local nec = ins("Motor6D",t) nec.Name = "Neck" nec.Part0 = t nec.Part1 = h
local rutj = ins("Motor6D",rut) rutj.Name = "RootJoint" rutj.Part0 = t rutj.Part1 = rut
local rs = ins("Motor6D",t) rs.Name = "Right Shoulder" rs.Part0 = t rs.Part1 = ra
local ls = ins("Motor6D",t) ls.Name = "Left Shoulder" ls.Part0 = t ls.Part1 = la
local rh = ins("Motor6D",t) rh.Name = "Right Hip" rh.Part0 = t rh.Part1 = rl
local lh = ins("Motor6D",t) lh.Name = "Left Hip" lh.Part0 = t lh.Part1 = ll

--Setting CFrames
nec.C1 = necc1
nec.C0 = necc0
rs.C1 = rsc1
rs.C0 = rsc0
ls.C1 = lsc1
ls.C0 = lsc0
rh.C1 = rhc1
rh.C0 = rhc0
lh.C1 = lhc1
lh.C0 = lhc0
rutj.C1 = rutjc1
rutj.C0 = rutjc0

--Functions1
function createWeld(p1,p2,c0,c1)
	c0 = c0 or cf(0,0,0)
	c1 = c1 or cf(0,0,0)
	local weld = ins("Motor6D",p1)
	weld.Part0 = p1
	weld.Part1 = p2
	weld.C0 = c0
	weld.C1 = c1
	return weld
end

--Adds
local healPNum = ins("NumberValue",hum)
healPNum.Name = "HealReadyPercentage"
healPNum.Value = healPercentage
local katana = script.Models.Katana
local hitbox = katana.Hitbox
local handle = katana.Handle
for i,v in pairs(katana:GetDescendants()) do
	if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
		v.Transparency = 1
	end
end
for i,v in pairs(script.Models.Syringe:GetDescendants()) do
	if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
		v.Transparency = 1
	end
end
local handleW = createWeld(ra,handle,cf(-.125,-.9,0),angles(rad(75),rad(190),rad(0)))
katana.Parent = char
katanahat.Parent  = handle
katanahat.Rotation = Vector3.new(145, 90, 0)
katanahat.Position = Vector3.new(0, 1.8, 0.2)
local lamp = script.Models.Lamp
lamp.Parent = char
local lWeld = createWeld(t,lamp.Handle,cf(-.975,-.75,-.25) * angles(rad(85),rad(85),rad(5)))

local ff = ins("ForceField",char)
ff.Visible = false

local effects = ins("Model",char)
effects.Name = "Effects"

local theme = ins("Sound",t)
theme.Volume = themeVolume
theme.SoundId = asset..themeID
theme.Pitch = themePitch
theme.TimePosition = timePos
theme.Looped = true
theme:Play()

local ui = script.UIs.KatanaristUI
ui.Parent = plrg

local shaker = script.DistShaker:Clone()

--Functions2

function remove(instance,time)
	time = time or 0
	game:GetService("Debris"):AddItem(instance,time)
end

function swait()
	game:GetService("RunService").Stepped:Wait()
end

function rayc(spos,direc,ignore,dist)
    local rai = ray(spos,direc.Unit * dist)
    local rhit,rpos,rrot = workspace:FindPartOnRayWithIgnoreList(rai,ignore,false,false)
    return rhit,rpos,rrot
end

function sound(id,vol,pitch,parent,maxdist)
	local mdist = 30 or maxdist
	local newsound = Instance.new("Sound",parent)
	newsound.Volume = vol
	newsound.SoundId = "rbxassetid://"..id
	newsound.Pitch = pitch
	newsound:Play()
	coroutine.resume(coroutine.create(function()
		wait(.1)
		remove(newsound,newsound.TimeLength/newsound.Pitch)
	end))
	return newsound
end

function placesoundpart(rcf,id,vol,pitch,maxdist)
	pcall(function()
		local mdist = 30 or maxdist
		local spart = ins("Part",effects)
		spart.Anchored = true
		spart.CanCollide = false
		spart.Locked = true
		spart.Transparency = 1
		spart.CFrame = rcf
		local ssound = sound(id,vol,pitch,spart,mdist)
		remove(spart,ssound.TimeLength/ssound.Pitch)
	end)
end

local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
    local info = TweenInfo.new(
    leinght,
    easingstyle,
    easingdirec,
    0,
    false,
    0
    )
    local lerp = tweens:Create(part,info,tablee)
    lerp:Play()
end

function removeWithFade(instance,time)
	game:GetService("Debris"):AddItem(instance,time+3.5)
	coroutine.resume(coroutine.create(function()
		wait(time)
		tlerp(instance,{Transparency = 1},3.5,styles.Linear,directions.In)
	end))
end

local Effects = {
	Ring = function(pos,color,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Effects.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
	end,
	SpinningRing = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Effects.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * rotation
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	Sphere = function(pos,color,sSize,eSize,sTrans,eTrans,time)
		local sphere = ins("Part")
		sphere.Shape = "Ball"
		sphere.Size = v3(sSize,sSize,sSize)
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		remove(sphere,time)
		tlerp(sphere,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles.Linear,directions.Out)
	end,
	SpinningBlock = function(pos,color,sSize,eSize,sTrans,eTrans,cfRotation,time)
		local part = ins("Part")
		part.Size = v3(sSize,sSize,sSize)
		part.Transparency = sTrans
		part.CFrame = pos
		part.Color = color
		part.Parent = effects
		part.Anchored = true
		part.CanCollide = false
		part.Locked = true
		part.Material = "Neon"
		remove(part,time)
		tlerp(part,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				part.CFrame = part.CFrame * cfRotation
				wait(1/30)
			until not part.Parent
		end)()
	end,
	CustomSphere = function(pos,endPos,color,sSize,eSize,sTrans,eTrans,time)
		local sphere = ins("Part")
		sphere.Size = sSize
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		
		local mesh = ins("SpecialMesh",sphere)
		mesh.MeshType = "Sphere"
		
		remove(sphere,time)
		tlerp(sphere,{Size = eSize,Transparency = eTrans,CFrame = endPos},time,styles.Linear,directions.Out)
	end,
	Wind = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Effects.Wind:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * angles(rad(0),rad(rotation),rad(0))
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	CreateCamShake = function(part,maxDist,intensivity,time)
		maxDist = maxDist or 20
		intensivity = intensivity or 1
		time = time or .1
		
		local bool = ins("BoolValue",part)
		bool.Name = "Shaking"
		bool.Value = true
		
		local MaxDist = ins("NumberValue",bool)
		MaxDist.Name = "MaxDist"
		MaxDist.Value = maxDist
		
		local Intensivity = ins("NumberValue",bool)
		Intensivity.Name = "Intensivity"
		Intensivity.Value = intensivity
		
		remove(bool,time)
	end,
	SoundEffect = function(sound,effect)
		ins(effect.."SoundEffect",sound)
	end,
	Particles = function(part,type,dis)
		local parts
		if type:lower() == "blood" then
			parts = script.Effects.BloodParticles:Clone()
			parts.Parent = part
			if dis then
				parts.Enabled = false
			else
				parts.Enabled = true
			end
		elseif type:lower() == "bloodsplash" then
			parts = script.Effects.BloodSplash:Clone()
			parts.Parent = part
			if dis then
				parts.Enabled = false
			else
				parts.Enabled = true
			end
		end
		return parts
	end
}

function createweld(part1,part2,v3c0,v3c1)
	local att1 = ins("Attachment",part1)
	local att2 = ins("Attachment",part2)
	att1.Position = v3c0
	att2.Position = v3c1
	local con = ins("BallSocketConstraint",part1)
	con.Attachment0 = att1
	con.Attachment1 = att2
	con.LimitsEnabled = true
	con.TwistLimitsEnabled = true
	con.TwistLowerAngle = 0
	con.TwistUpperAngle = 0
	con.UpperAngle = 0
	att1.Name = "dontremove"
	att2.Name = "dontremove"
	con.Name = "dontremove"
	return {att0 = att1,att1 = att2,constraint = con}
end

function createglue(parent1,parent2,name,part0,part1,c0,c1)
	local att1 = ins("Attachment")
	local att2 = ins("Attachment")
	local socket = ins("BallSocketConstraint")
	att1.Parent = parent1
	att2.Parent = parent2
	socket.Attachment0 = att1
	socket.Attachment1 = att2
	att1.Position = c0
	att2.Position = c1
	socket.Name = "dontremove"
	att1.Name = "dontremove"
	att2.Name = "dontremove"
	socket.Parent = parent2
	return att1,att2,socket
end

function createhitbox(part,parent)
	--[[pcall(function()
		local hbpart = ins("Part")
		hbpart.Name = "HitboxRagdoll"
		hbpart.Locked = true
		hbpart.Transparency = 1
		hbpart.TopSurface = "Smooth"
		hbpart.BottomSurface = "Smooth"
		hbpart.Material = "Ice"
		if part.Name ~= "Head" then
			hbpart.Size = v3(part.Size.x/1.35,part.Size.y/1.2,part.Size.z/1.35)
			hbpart.CFrame = part.CFrame
			local att1 = ins("Attachment",part)
			local att2 = ins("Attachment",hbpart)
			att1.Position = v3(0,(-part.Size.y/2) + (hbpart.Size.y/2),0)
			local con = ins("BallSocketConstraint",part)
			con.Attachment0 = att1
			con.Attachment1 = att2
			con.LimitsEnabled = true
			con.TwistLimitsEnabled = true
			con.TwistLowerAngle = 0
			con.TwistUpperAngle = 0
			con.UpperAngle = 0
		else
			hbpart.Size = v3(part.Size.x,part.Size.y/2,part.Size.z)
			hbpart.CFrame = part.CFrame
			local att1 = ins("Attachment",part)
			local att2 = ins("Attachment",hbpart)
			local con = ins("BallSocketConstraint",part)
			con.Attachment0 = att1
			con.Attachment1 = att2
			con.LimitsEnabled = true
			con.TwistLimitsEnabled = true
			con.TwistLowerAngle = 0
			con.TwistUpperAngle = 0
			con.UpperAngle = 0
		end
		hbpart:BreakJoints()
		hbpart.Parent = parent
	end)--]]
end

function createhitboxr15(part,parent)
	--[[pcall(function()
		local hbpart = ins("Part")
		hbpart.Name = "HitboxRagdoll"
		hbpart.Locked = true
		hbpart.Transparency = 1
		hbpart.TopSurface = "Smooth"
		hbpart.BottomSurface = "Smooth"
		hbpart.Material = "Ice"
		if part.Name ~= "Head" then
			hbpart.Size = v3(part.Size.x/1.5,part.Size.y/6,part.Size.z/1.5)
			hbpart.CFrame = part.CFrame
			local att1 = ins("Attachment",part)
			local att2 = ins("Attachment",hbpart)
			local con = ins("BallSocketConstraint",part)
			con.Attachment0 = att1
			con.Attachment1 = att2
			con.LimitsEnabled = true
			con.TwistLimitsEnabled = true
			con.TwistLowerAngle = 0
			con.TwistUpperAngle = 0
			con.UpperAngle = 0
		else
			hbpart.Size = v3(part.Size.x,part.Size.y/2,part.Size.z)
			hbpart.CFrame = part.CFrame
			local att1 = ins("Attachment",part)
			local att2 = ins("Attachment",hbpart)
			local con = ins("BallSocketConstraint",part)
			con.Attachment0 = att1
			con.Attachment1 = att2
			con.LimitsEnabled = true
			con.TwistLimitsEnabled = true
			con.TwistLowerAngle = 0
			con.TwistUpperAngle = 0
			con.UpperAngle = 0
		end
		hbpart:BreakJoints()
		hbpart.Parent = parent
	end)--]]
end

function paralizer6(type,who,huma,ripHead)
--[[pcall(function()
	if type == "body" then
		local torso = who:FindFirstChild("Torso")
		local righta = who:FindFirstChild("Right Arm")
		local lefta = who:FindFirstChild("Left Arm")
		local rightl = who:FindFirstChild("Right Leg")
		local leftl = who:FindFirstChild("Left Leg")
		local head = who:FindFirstChild("Head")
		local tag = ins("Glue",who) tag.Name = "deletmepls"
		if torso then
			local root = who:FindFirstChild("HumanoidRootPart")
			if root then
				root:Destroy()
			end
			huma.PlatformStand = true
			if head then
				if head:FindFirstChild("Ripped") then
					return
				end
				head:BreakJoints()
				head.Anchored = false
				createhitbox(head,torso)
				local att1,att2,sock = createglue(torso,head,"paralized",torso,leftl,v3(0,torso.Size.y/2,0),v3(0,-head.Size.y/2,0))
				att1.Orientation = v3(0, -90, 90)
				att2.Orientation = v3(0, -90, 90)
				sock.LimitsEnabled = true
				sock.TwistLimitsEnabled = true
				sock.UpperAngle = 80
				sock.TwistLowerAngle = -80
				sock.TwistUpperAngle = 80
				head.TopSurface = "Smooth"
				head.BottomSurface = "Smooth"
				head:MakeJoints()
				if ripHead then
					remove(att1)
					remove(att2)
					remove(sock)
					coroutine.wrap(function()
						for i = 1,random(15,30) do
							blood(torso.CFrame * cf(0,torso.Size.Y/2,0),torso.CFrame.UpVector,random(5,15),(random(80,130)/100) * torso.Size.Z,who)
							wait(random(25,60)/350)
						end
					end)()
				end
			end
			if leftl then
				if not leftl:FindFirstChild("Ripped") then
					leftl:BreakJoints()
					leftl.Anchored = false
					local att1,att2,sock = createglue(torso,leftl,"paralized",torso,leftl,v3(-torso.Size.x/4,-torso.Size.y/2,0),v3(0,leftl.Size.y/2,0))
					att1.Orientation = v3(-0, -90, 90)
					att2.Orientation = v3(0, -90, 90)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 35
					sock.TwistUpperAngle = -45
					createhitbox(leftl,torso)
				end
			end
			if rightl then
				if not rightl:FindFirstChild("Ripped") then
					rightl:BreakJoints()
					rightl.Anchored = false
					local att1,att2,sock = createglue(torso,rightl,"paralized",torso,rightl,v3(torso.Size.x/4,-torso.Size.y/2,0),v3(0,rightl.Size.y/2,0))
					att1.Orientation = v3(-0, -90, 90)
					att2.Orientation = v3(0, -90, 90)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 45
					sock.TwistUpperAngle = -35
					createhitbox(rightl,torso)
				end
			end
			if righta then
				righta:BreakJoints()
				righta.Anchored = false
				if not righta:FindFirstChild("Ripped") then
					local att1,att2,sock = createglue(torso,righta,"paralized",torso,righta,v3((torso.Size.x/2) + (righta.Size.x/2),torso.Size.y/4,0),v3(0,righta.Size.y/4,0))
					att1.Orientation = v3(-90, 0, 0)
					att2.Orientation = v3(0, 180, -180)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 105
					sock.TwistUpperAngle = -110
				end
				createhitbox(righta,torso)
			end
			if lefta then
				lefta:BreakJoints()
				lefta.Anchored = false
				if not lefta:FindFirstChild("Ripped") then
					local att1,att2,sock = createglue(torso,lefta,"paralized",torso,lefta,v3((-torso.Size.x/2) - (lefta.Size.x/2),torso.Size.y/4,0),v3(0,lefta.Size.y/4,0))
					att1.Orientation = v3(-90, 180, 0)
					att2.Orientation = v3(0, -180, 0)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 105
					sock.TwistUpperAngle = -90
				end
				createhitbox(lefta,torso)
			end
		else
			warn("Cant get the torso")
		end
	end
end)--]]
end

function killr6(who,ripHead)
--[[pcall(function()
	local khum = who:FindFirstChildOfClass("Humanoid")
	if khum then
		remove(who,10)
		khum.Health = 0
		khum.Name = "Dead hobo"
		who:BreakJoints()
		local khe = khum.Parent:FindFirstChild("Head")
		if khe.Size.x ~= khe.Size.z then
			khe.Size = v3(khe.Size.z,khe.Size.z,khe.Size.z)
		end
		for i,v in pairs(who:GetDescendants()) do
			if v:IsA("Accessory") or v:IsA("Hat") then
				local att1 = ins("Attachment",khe)
				local att2 = ins("Attachment",v.Handle)
				att1.Position = (v.Handle.Position-khe.Position)
				local con = ins("BallSocketConstraint",khe)
				con.Attachment0 = att1
				con.Attachment1 = att2
				con.LimitsEnabled = true
				con.TwistLimitsEnabled = true
				con.TwistLowerAngle = 0
				con.TwistUpperAngle = 0
				con.UpperAngle = 0
			end
			if v:IsA("Script") or v:IsA("LocalScript") or v.Name == "HitboxRagdoll" or v:IsA("Attachment") and v.Name ~= "dontremove" or v:IsA("BallSocketConstraint") and v.Name ~= "dontremove" then
				remove(v,0)
			end
			if v:IsA("Decal") then
			end
			if v:IsA("Part") or v:IsA("MeshPart") then
				v.Anchored = false
				v:BreakJoints()
				removeWithFade(v,5)
			end
		end
		paralizer6("body",khum.Parent,khum,ripHead)
		ins("Glue",who).Name = "am ded"
	end
end)--]]
end

function killr15(who,riphead)
--[[pcall(function()
	local khum = who:FindFirstChildOfClass("Humanoid")
	if khum then
		remove(who,10)
		local root = who:FindFirstChild("HumanoidRootPart")
		if root then
			remove(root)
		end
		local joints = {}
		for i,v in pairs(who:GetDescendants()) do
			if v:IsA("Motor6D") or v:IsA("Motor") then
				if v.Part0 and v.Part1 then
					table.insert(joints,v)
				end
			end
		end
		khum.Health = 0
		khum.Name = "Dead hobo"
		who:BreakJoints()
		local khe = khum.Parent:FindFirstChild("Head")
		if khe.Size.x ~= khe.Size.z then
			khe.Size = v3(khe.Size.z,khe.Size.z,khe.Size.z)
		end
		for i,v in pairs(who:GetDescendants()) do
			if v:IsA("Accessory") or v:IsA("Hat") then
				local att1 = ins("Attachment",khe)
				local att2 = ins("Attachment",v.Handle)
				att1.Position = (v.Handle.Position-khe.Position)
				local con = ins("BallSocketConstraint",khe)
				con.Attachment0 = att1
				con.Attachment1 = att2
				con.LimitsEnabled = true
				con.TwistLimitsEnabled = true
				con.TwistLowerAngle = 0
				con.TwistUpperAngle = 0
				con.UpperAngle = 0
			end
			if v:IsA("Script") or v:IsA("LocalScript") or v.Name == "HitboxRagdoll" or v:IsA("Attachment") and v.Name ~= "dontremove" or v:IsA("BallSocketConstraint") and v.Name ~= "dontremove" or v.Name == "HumanoidRootPart" then
				remove(v,0)
			end
			if v:IsA("Decal") then
				removeWithFade(v,5)
			end
			if v:IsA("Part") or v:IsA("MeshPart") then
				v.Anchored = false
				v:BreakJoints()
				removeWithFade(v,5)
			end
		end
		for i,v in pairs(joints) do
			if v.Name == "Neck" and not riphead then
				createglue(v.Part0,v.Part1,"paralized",v.Part0,v.Part1,v3(v.C0.x,v.C0.y,v.C0.z),v3(v.C1.x,v.C1.y,v.C1.z))
			elseif v.Name == "Neck" and riphead then
				coroutine.wrap(function()
					for i = 1,random(15,30) do
						blood(v.Part0.CFrame * cf(0,v.Part0.Size.Y/2,0),v.Part0.CFrame.UpVector,random(5,15),(drandom(.8,1.3,100)) * v.Part0.Size.Z,who)
						wait(random(25,60)/350)
					end
				end)()
			elseif v.Name ~= "Neck" then
				createglue(v.Part0,v.Part1,"paralized",v.Part0,v.Part1,v3(v.C0.x,v.C0.y,v.C0.z),v3(v.C1.x,v.C1.y,v.C1.z))
			end
			if not v.Part0.Name ~= "UpperTorso" or not v.Part1.Name ~= "UpperTorso" then
				createhitboxr15(v.Part0,v.Part0)
				removeWithFade(v.Part0,5)
			end
		end
	end
end)--]]
end

function death(who,ripHead)
	if who:FindFirstChild("UpperTorso") then
		--killr15(who,ripHead)
	elseif who:FindFirstChild("Torso") then
		--killr6(who,ripHead)
	end
end

function blood(pos,direc,forcev,scale,ignore)
	ignore = ignore or ins("Model")
	scale = scale or 1
	forcev = forcev or 25
	if not pos then
		return warn("No position set")
	end
	local p = ins("Part")
	p.Size = v3(.35,.35,.35) * scale
	p.CanCollide = true
	p.Transparency = 1
	p.Material = "Neon"
	p.Shape = "Ball"
	p.CFrame = pos
	p.Parent = effects
	p:BreakJoints()
	
	table.insert(ignoreList,p)
	
	local bps = Effects.Particles(p,"blood",false)
	bps.Size = NumberSequence.new(.2 * scale)
	bps:Emit(7)
	
	local force = ins("BodyVelocity",p)
	force.MaxForce = v3(huge,huge,huge)
	force.Velocity = (direc + v3(drandom(-.75,.75,100),drandom(-.75,.75,100),drandom(-.75,.75,100))) * forcev
	
	remove(force,.15)
	
	local raySides = {
		v3(0,100,0),
		v3(0,-100,0),
		v3(0,0,100),
		v3(0,0,-100),
		v3(100,0,0),
		v3(-100,0,0),
		v3(100,100,0),
		v3(-100,100,0),
		v3(100,-100,0),
		v3(-100,-100,0),
		v3(0,100,100),
		v3(0,100,-100),
		v3(0,-100,100),
		v3(0,-100,-100),
		v3(100,100,100),
		v3(100,-100,100),
		v3(100,100,-100),
		v3(100,-100,-100),
		v3(-100,100,100),
		v3(-100,-100,100),
		v3(-100,100,-100),
		v3(-100,-100,-100),
		v3(100,100,-100),
		v3(-100,-100,100),
		v3(-100,100,-100),
		v3(100,-100,100)
	}
	local deb = false
	p.Touched:Connect(function(hit)
		if hit:IsDescendantOf(char) or hit:IsDescendantOf(ignore) or deb then return end
		deb = true
		bps.Enabled = false
		p.CanCollide = false
		p.Anchored = true
		local pPos = p.Position
		remove(p,2.5)
		
		local decSize = 3 * scale
		local reg = Region3.new(pPos - v3(decSize/2,decSize/2,decSize/2),pPos + v3(decSize/2,decSize/2,decSize/2))
		local foundParts = workspace:FindPartsInRegion3WithWhiteList(reg,ignoreList,100)
		
		local breakAfter = false
		
		for i,v in pairs(foundParts) do
			if v.Name == "BloodPuddle_v2" then
				local add = random(10,25)/100
				v.Size = v.Size + v3(add,0,add) * scale
				local pars = Effects.Particles(v,"blood",true)
				pars.LockedToPart = false
				pars.Size = NumberSequence.new(.2 * scale)
				pars.Speed = NumberRange.new(5)
				pars.Acceleration = v3(0,-10,0) * scale
				pars.SpreadAngle = Vector2.new(50,50) * scale
				pars.Lifetime = NumberRange.new(.2,.5)
				pars:Emit(3)
				breakAfter = true
			end
		end
		
		if breakAfter then
			return
		end
		
		for i,v in pairs(raySides) do
			local hitt,ppos,nId = rayc(pPos,(pPos + v) - pPos,ignoreList,5 * scale)
			if hitt then
				
				local decSize = 3 * scale
				local reg = Region3.new(pPos - v3(decSize/2,decSize/2,decSize/2),pPos + v3(decSize/2,decSize/2,decSize/2))
				local foundParts = workspace:FindPartsInRegion3WithWhiteList(reg,ignoreList,100)
				
				local breakAfter = false
				
				for i,v in pairs(foundParts) do
					if v.Name == "BloodPuddle_v2" then
						local add = random(10,25)/100
						v.Size = v.Size + v3(add,0,add) * scale
						local pars = Effects.Particles(v,"blood",true)
						pars.LockedToPart = false
						pars.Size = NumberSequence.new(.2 * scale)
						pars.Speed = NumberRange.new(5 * scale)
						pars.Acceleration = v3(0,-10,0) * scale
						pars.SpreadAngle = Vector2.new(50,50) * scale
						pars.Lifetime = NumberRange.new(.2,.5)
						pars:Emit(3)
						breakAfter = true
					end
				end
				
				if breakAfter then
					return
				end
				
				local size = random(75,125)/100
				local puddle = ins("Part")
				puddle.CanCollide = false
				puddle.Anchored = true
				puddle.Material = "SmoothPlastic"
				puddle.Color = bc("Maroon").Color
				puddle.Size = v3(size,.05,size) * scale
				puddle.CFrame = cf(ppos,ppos+nId) * angles(rad(-90),rad(0),rad(0))
				puddle.Name = "BloodPuddle_v2"
				puddle.Parent = effects
				
				if not hitt.Anchored then
					puddle.Anchored = false
					local we = ins("WeldConstraint",puddle)
					we.Part0 = hitt
					we.Part1 = puddle
				end
				
				ins("CylinderMesh",puddle)
				
				sound(685857471,.025 * scale,drandom(.9,1.1,100),puddle,.01)
				
				local pars = Effects.Particles(puddle,"blood",true)
				pars.LockedToPart = false
				pars.Size = NumberSequence.new(.2 * scale)
				pars.Speed = NumberRange.new(5 * scale)
				pars.Acceleration = v3(0,-10,0) * scale
				pars.SpreadAngle = Vector2.new(50,50) * scale
				pars.Lifetime = NumberRange.new(.2,.5)
				pars:Emit(20)
				
				coroutine.wrap(function()
					wait(random(450,900)/100)
					remove(puddle,2)
					tlerp(puddle,{Transparency = 1},2,styles.Quad,directions.In)
				end)()
				
				break
			end
		end
	end)
end

function damage(humanoid,Damage,knockback,knockbackStartPoint,knockbackTime,knockDelay,damageSound,ripHead)
	Damage = Damage or random(5,15)
	knockback = knockback or 15
	knockbackStartPoint = knockbackStartPoint or v3(0,0,0)
	knockbackTime = knockbackTime or .15
	knockDelay = knockDelay or .2
	damageSound = damageSound or sound(851453784,1.5,drandom(.9,1.1,100),nil,1)
	
	if humanoid and humanoid.Parent ~= char.Model and not humanoid:FindFirstChild("Dbounce'd") and humanoid.Health > .01 then
		Damage = math.floor(Damage * (1 + humanoid.MaxHealth/500))
		local part = humanoid.Parent:FindFirstChildOfClass("Part") or humanoid.Parent:FindFirstChildOfClass("MeshPart")
		local deb = ins("BoolValue",humanoid)
		deb.Name = "Dbounce'd"
		remove(deb,knockDelay)
		if part then
			damageSound.Parent = part
			targetnnn = part
			---GlobalFunctions.fling(part,0.8)
			--local knock = ins("BodyVelocity",part)
			--knock.MaxForce = v3(huge,huge,huge)
			--knock.Velocity = -cf(part.Position,knockbackStartPoint).LookVector * knockback
			--remove(knock,knockbackTime)
			for i = 1,random(1,4) do
				--blood(part.CFrame * cf(drandom(-1,1,10),drandom(-1,1,10),drandom(-1,1,10)),hitbox.CFrame.LookVector,random(10,20),drandom(.8,1.2,100),humanoid.Parent)
			end
		end
		if humanoid.MaxHealth > 10000000 then
			sound(1753674936,5,1,t,5)
			--death(humanoid.Parent,ripHead)
		end
		--humanoid.Health = humanoid.Health - Damage
		if humanoid.Health < .01 then
			--death(humanoid.Parent,ripHead)
			if part then
				--placesoundpart(part,2801263,15,drandom(.9,1.1,100),1)
			end
		end
	end--]]
end

function magDamage(pos,partSize,size,Damage,knockback,knockbackTime,knockDelay,damageSound,ripHead)
	
	pcall(function()
		local reg
		local knockPoint
		if typeof(pos) == "Vector3" then
			reg = Region3.new(pos - v3(size/2,size/2,size/2),pos + v3(size/2,size/2,size/2))
			knockPoint = pos
		elseif typeof(pos) == "Instance" then
			knockPoint = pos.Position
			if partSize then
				reg = Region3.new(pos.Position - pos.Size/2,pos.Position + pos.Size/2)
				local hb = ins("Part",effects)
				hb.Anchored = true
				hb.CanCollide = false
				hb.Size = reg.Size
				hb.CFrame = reg.CFrame
				remove(hb,5)
			else
				reg = Region3.new(pos.Position - v3(size/2,size/2,size/2),pos.Position + v3(size/2,size/2,size/2))
			end
		end
		if reg then
			for i,v in pairs(workspace:FindPartsInRegion3WithIgnoreList(reg,{char},250)) do
				local humm = v.Parent:FindFirstChildOfClass("Humanoid")
				if humm then
					damage(humm,Damage,knockback,knockPoint,knockbackTime,knockDelay,damageSound,ripHead)
				end
			end
		end
	end)--]]
end

function swing1()
	using = true
	local oldWS = ws
	local oldJP = jp
	jp = 50
	local alpha = .4
	local add = -.0165
	for i = 0,1,.075 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(-40),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,-.15) * angles(rad(0),rad(-40),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.05,-.4) * angles(rad(95),rad(90),rad(0)) * angles(rad(25),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.15,.2) * angles(rad(15),rad(35),rad(5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,-.075) * angles(rad(-10),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,-.075,-.125) * angles(rad(10),rad(10),rad(-2.5)),alpha)
		handleW.C1 = handleW.C1:Lerp(angles(rad(80),rad(0),rad(0)),alpha)
		alpha = alpha + add
		swait()
	end
	alpha = .35
	add = .075
	for i = 0,1,.095 do
		for i,v in pairs(katana:GetChildren()) do
			if v.Name == "BladeMain" then
				magDamage(v,false,.5,random(25,50),random(15,30),.05,.3,nil,true)
			end
		end
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(50),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,.25) * angles(rad(0),rad(50),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,.05,.15) * angles(rad(95),rad(90),rad(0)) * angles(rad(-105),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.05,-.1) * angles(rad(35),rad(-25),rad(-15)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,-.05,-.1) * angles(rad(10),rad(-10),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(-15),rad(5),rad(-2.5)),alpha)
		handleW.C1 = handleW.C1:Lerp(angles(rad(120),rad(0),rad(0)),alpha)
		alpha = alpha + add
		if alpha >.775 then
			add = -math.abs(add)
		end
		swait()
	end
	ws = oldWS
	jp = oldJP
	using = false
end

function swing2()
	using = true
	local oldWS = ws
	local oldJP = jp
	jp = 50
	local alpha = .4
	local add = -.0175
	for i = 0,1,.075 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-7.5),rad(30),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,-.15) * angles(rad(-5),rad(30),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,.35,.25) * angles(rad(190),rad(0),rad(20)) * angles(rad(0),rad(40),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.15,.2) * angles(rad(5),rad(-5),rad(-2.5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,-.075) * angles(rad(-7.5),rad(-10),rad(8.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,-.075,-.125) * angles(rad(7.5),rad(10),rad(-2.5)),alpha)
		handleW.C1 = handleW.C1:Lerp(angles(rad(80),rad(0),rad(0)),alpha)
		alpha = alpha + add
		swait()
	end
	alpha = .5
	add = .095
	for i = 0,1,.115 do
		for i,v in pairs(katana:GetChildren()) do
			if v.Name == "BladeMain" then
				magDamage(v,false,.5,random(40,65),random(15,30),.05,.3,nil,false)
			end
		end
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(3.5),rad(5),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,.25) * angles(rad(20),rad(-5),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(-.25,-.25,-.3) * angles(rad(40),rad(0),rad(-15)) * angles(rad(0),rad(10),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.15,.2) * angles(rad(35),rad(-15),rad(-10)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,-.125) * angles(rad(7.5),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,-.075,-.125) * angles(rad(10),rad(10),rad(-2.5)),alpha)
		handleW.C1 = handleW.C1:Lerp(angles(rad(135),rad(0),rad(0)),alpha)
		alpha = alpha + add
		if alpha >.85 then
			add = -math.abs(add)
		end
		swait()
	end
	ws = oldWS
	jp = oldJP
	using = false
end

function heal()
	using = true
	local alpha = .35
	local add = -.015
	for i = 0,1,.05 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-25),rad(50),rad(2.5)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.1,-.05,.065) * angles(rad(-10),rad(35),rad(25)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(5),rad(-2.5)),alpha)
		alpha = alpha + add
		swait()
	end
	local s = script.Models.Syringe:Clone()
	s.Transparency = 1
	s.Parent = la
	adrelinehat.Parent = s
	local w = createWeld(la,s,cf(.1,-.95,0),angles(rad(0),rad(90),rad(180)))
	local alpha = .45
	local add = -.03
	for i = 0,1,.075 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-25),rad(10),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.15,.1,-.35) * angles(rad(65),rad(0),rad(25)) * cf(0,0,0) * angles(rad(0),rad(50),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(5),rad(-2.5)),alpha)
		alpha = alpha + add
		swait()
	end
	local alpha = .5
	local add = -.04
	sound(851453784,.075,drandom(1.25,1.65,100),la,.25)
	for i = 0,1,.1 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-20),rad(-10),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.25,-.05,-.75) * angles(rad(45),rad(0),rad(70)) * cf(0,0,0) * angles(rad(0),rad(60),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(5),rad(-2.5)),alpha)
		alpha = alpha + add
		swait()
	end
	local healSpeed = 1
	for i = 1,120,healSpeed do
		hum.Health = hum.Health + healSpeed
		swait()
	end
	if ws == 70 then
		ws = 50
		hum.WalkSpeed = ws
	else
		ws = ws + 20
		hum.WalkSpeed = ws
	end
	
	healPercentage = 0
	local alpha = .5
	local add = -.04
	for i = 0,1,.1 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-20),rad(5),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.1,-.05,-.5) * angles(rad(65),rad(0),rad(20)) * cf(0,0,0) * angles(rad(0),rad(50),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(5),rad(-2.5)),alpha)
		alpha = alpha + add
		swait()
	end
	
	s.CanCollide = true
	adrelinehat.Parent = tcnn
	s:BreakJoints()
	removeWithFade(s,3.5)
	using = false
end

--[[
	local alpha = .35
	local add = -.025
	for i = 0,1,.025 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		alpha = alpha + add
		swait()
	end
function base()
	using = true
	local oldWS = ws
	local oldJP = jp
	ws = 0
	jp = 0
	
	ws = oldWS
	jp = oldJP
	using = false
end
--]]

hum.Died:Connect(function()
	killr6(char,false)
end)

local comboAttacks = {swing1,swing2}

mouse.KeyDown:Connect(function(key)
	if not using then
		if key == "space" and wallJump and not wallJumpDeb then
			sound(1547211023,1.25,drandom(.8,1.1,100),t,.05)
			sound(260411131,1,drandom(1.1,1.3,100),t,.05)
			wallJumpDeb = true
			local vel = ins("BodyVelocity",rut)
			vel.MaxForce = v3(huge,huge,huge)
			vel.Velocity = (-rut.CFrame.LookVector * 45) + v3(0,125,0)
			remove(vel,.025)
			local hi,po,ni = rayc(rut.Position,rut.CFrame.LookVector,{char},3)
			if hi then
				for i = 1,random(4,8) do
					local siz = drandom(7,17,5,10)
					Effects.Ring(cf(po,po + ni) * angles(rad(random(-15,15)),rad(random(-15,15)),rad(random(-15,15))),bc("Institutional white").Color,v3(2,2,.75),v3(siz,siz,.35),drandom(.35,.65,100),1,drandom(.15,.75,100))
				end
			end
			wait(.5)
			wallJumpDeb = false
		end
		if key == "h" and healPercentage == 1 then
			heal()
		end
	end
	if key == "f" then
		lightEnabled = not lightEnabled
	end
	if key == "m" then
		muted = not muted
	end
end)

mouse.Button1Down:Connect(function()
	if not using then
		comboAttacks[combo]()
		combo = combo +1
		if combo > #comboAttacks then
			combo = 1
		end
	end
end)

hum.MaxHealth = healthPool
hum.Health = healthPool

stepped:Connect(function()
	healPercentage = healPercentage + .00075
	if healPercentage >1 then
		healPercentage = 1
	end
	healPNum.Value = healPercentage
	if theme.Parent ~= t then
		remove(theme)
		theme = ins("Sound",t)
		theme.Volume = themeVolume
		theme.SoundId = asset..themeID
		theme.Pitch = themePitch
		theme.TimePosition = timePos
		theme.Looped = true
		theme:Play()
	end
	
	theme:Resume()
	if muted then
		theme.Volume = 0
	else
		theme.Volume = themeVolume
	end
	theme.SoundId = asset..themeID
	theme.Pitch = themePitch
	
	timePos = theme.TimePosition
	
	sine = sine + change
	
	local verVel = rut.Velocity.y
	local horVel = (rut.Velocity * v3(1,0,1)).Magnitude

	local Ccf=rut.CFrame
	
	local dir = hum.MoveDirection
	
	if dir == v3(0,0,0) then
		dir = rut.Velocity/10
	end

	local Walktest1 = dir * Ccf.LookVector
	local Walktest2 = dir * Ccf.RightVector

	local rotfb = Walktest1.X+Walktest1.Z
	local rotrl = Walktest2.X+Walktest2.Z
	
	if rotfb >1 then
		rotfb = 1
	elseif rotfb <-1 then
		rotfb = -1
	end
	
	if rotrl >1 then
		rotrl = 1
	elseif rotrl <-1 then
		rotrl = -1
	end
	
	hum.MaxHealth = healthPool
	
	hum.WalkSpeed = ws
	hum.JumpPower = jp
	
	--[[for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if not v.PlayerGui:FindFirstChild(shaker.Name) then
			local shak = shaker:Clone()
			shak.Parent = v.PlayerGui
			shak.Disabled = false
		end
	end--]]
	
	if lightEnabled then
		for i,v in pairs(lamp:GetDescendants()) do
			if v:IsA("SurfaceLight") then
				v.Enabled = true
			end
			if string.find(v.Name:lower(),"light") and v:IsA("Part") then
				v.Color = bc("White").Color
			end
		end
	else
		for i,v in pairs(lamp:GetDescendants()) do
			if v:IsA("SurfaceLight") then
				v.Enabled = false
			end
			if string.find(v.Name:lower(),"light") and v:IsA("Part") then
				v.Color = bc("Really black").Color
			end
		end
	end
	
	local hit,pos,nId = rayc(rut.Position + v3(0,-rut.Size.y/2,0),v3(rut.Position.x,-10000,rut.Position.z),{char},3)
	local wHit = rayc(rut.Position,rut.CFrame.LookVector,{char},2)
	
	if wHit then
		wallJump = true
	else
		wallJump = false
	end
	
	if anim == "idle" and hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/25) * rad(5),-sin(sine/100) * rad(7.5),-cos(sine/50) * rad(3.5)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(sine/25)/15,sin(sine/50)/15) * angles(sin(sine/25) * rad(3.5),sin(sine/75) * rad(2.5),cos(sine/50) * rad(3.5)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,sin(sine/25)/15,0) * angles(sin(sine/25) * rad(2.5),sin(sine/75) * rad(5),cos(sine/50) * rad(3.5)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,sin(sine/25)/15,0) * angles(cos(sine/25) * rad(3.5),-sin(sine/75) * rad(5),cos(sine/50) * rad(3.5)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,sin(sine/25)/15,0) * angles((sin(sine/25) * rad(6)) + (sin(sine/75) * rad(2.5)),rad(0),cos(sine/50) * rad(4)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,sin(sine/25)/15,0) * angles((sin(sine/25) * rad(6)) - (sin(sine/75) * rad(2.5)),rad(0),cos(sine/50) * rad(4)),.1)
	elseif anim == "fall" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "jump" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "walk" and hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/1.25) * rad(1.5),sin(sine/2.5) * rad(2.5),rad(0)) * angles(-rotfb/5,rotrl/2,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(sine/1.25)/7.5,0) * angles(sin(sine/1.25) * rad(2),sin(sine/2.5) * rad(5),rad(0)) * angles(-rotfb/2.5,0,-rotrl/4.5),.2)
		if not using then
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(-cos(sine/1.25) * rad(7.5),-sin(sine/2.5) * rad(5),rad(0)),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * cf(0,abs(rotfb/2.25),0) * angles(cos(sine/2.5) * rad(10),sin(sine/2.5) * rad(5),rad(0)) * angles(rotfb + (rotrl/2),0,rotrl/1.75) * angles(rad(0),rad(25),rad(0)),.2)
		else
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		end
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,cos(sine/2.5)/2.5,-cos(sine/2.5)/2) * angles(sin(sine/2.5) * rad(85) * rotfb,rad(0),sin(sine/2.5) * rad(65) * rotrl),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,-cos(sine/2.5)/2.5,cos(sine/2.5)/2) * angles(-sin(sine/2.5) * rad(85) * rotfb,rad(0),-sin(sine/2.5) * rad(65) * rotrl),.2)
	end
	if not using then
		handleW.C1 = handleW.C1:Lerp(angles(rad(75),rad(190),rad(0)),.25)
	end
	if horVel > 5 and verVel >-10 and verVel <10 then
		anim = "walk"
		change = .75
		if not using then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.1,-.2,.25) * angles(rad(-10),rad(-55),rad(0)) * angles(rad(0),rad(0),rad(15)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(.125,.1,0) * angles(rad(0),rad(0),rad(-3.5)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		end
	elseif verVel >10 then
		anim = "jump"
		change = 1
		if not using then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(15),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.1,-.1,.25) * angles(rad(5),rad(-15),rad(0)) * angles(rad(0),rad(0),rad(7.5)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(145),rad(0),rad(-8)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(-3.5)),.2)
		end
		elseif verVel <-10 then
		anim = "fall"
		change = 1
		if not using then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.1,-.15,.25) * angles(rad(15),rad(-10),rad(0)) * angles(rad(0),rad(0),rad(15)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(-.45,-.44,0) * angles(rad(6),rad(0),rad(-97.5)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(-3.5)),.2)
		end
	elseif horVel < 5 and verVel >-10 and verVel <10 then
		anim = "idle"
		change = 1
		if not using then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(3.5),rad(15),rad(3.5)),.1)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(7.5),rad(15),rad(-3.5)),.1)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.15,-.25,.35) * angles(rad(-25),rad(-45),rad(0)) * angles(rad(0),rad(0),rad(-25)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.125,-.075) * angles(rad(12.5),rad(-10),rad(-7.5)),.1)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,-.1) * angles(rad(-10),rad(-7.5),rad(-5)),.1)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,-.15) * angles(rad(10),rad(20),rad(-2.5)),.1)
		end
	end
end)
-- i'm tired of life and i want to end it...
end)

Section:NewButton("Eyo Zen", "ButtonInfo", function()
    print("Clicked")
--require(4395650693)()
script = game:GetObjects("rbxassetid://6085241337")[1]
local s = script:FindFirstChildOfClass("Script"):Clone()
s.Parent = game:GetService("Players").LocalPlayer.PlayerGui
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/0n3Du5SM'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
local cnnnnn = game.Players.LocalPlayer.Character
local targetnnn = nil
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
wait(0.111111156)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do

		if targetnnn ~= nil then
			print("Fling")

			--print(targetnnn) print(targetnnn.Parent)
			othertarget = targetnnn:FindFirstChild("Torso") or targetnnn:FindFirstChild("UpperTorso")
			if not othertarget then return end
			print(othertarget)
			
			GlobalFunctions.fling(othertarget,0.5)
			wait(0.1)
			targetnnn = nil
			
		end


	end
end)


--[[

-gh 20011897,10406930154,4132848799
--]]
local hathead = gp(gp(cnnnnn.Model, "Space Cop", "Accessory"), "Handle", "BasePart")
hathead.Mesh:Destroy()
local hathead = gp(gp(gp(cnnnnn, "Space Cop", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local hatheadn = gp(gp(cnnnnn, "Space Cop", "Accessory"), "Handle", "BasePart")
local hatheadnn = gp(gp(cnnnnn.Model, "Space Cop", "Accessory"), "Handle", "BasePart")
hathead.Rotation = Vector3.new()
hathead.Position = Vector3.new()
local hattop = gp(gp(gp(cnnnnn, "Small Magic Hat", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hattop.Rotation = Vector3.new(0, 0, 42)
hattop.Position = Vector3.new(-1, 1.5, 0)
local hateye = gp(gp(gp(cnnnnn, "MeshPartAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local hateyen = gp(gp(cnnnnn.Model, "MeshPartAccessory", "Accessory"), "Handle", "BasePart")
hateye.Rotation = Vector3.new()
hateye.Position = Vector3.new(0, 0, -1)


-------------------------------------------------------
--[[ Name : Eyozen, the flosser ]]--
-------------------------------------------------------

--[[ "Haha, I'm a funny guy, but once you anger me..." ]]--
--[[ "There's no coming back =)" ]]--

wait(1.3)
local plr = game.Players.LocalPlayer
print('Local User is '..plr.Name)
local char = plr.Character
mouse = plr:GetMouse()
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
       --  hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
        -- hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = plr,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			--h.Health = h.Health - Damage
			if h then targetnnn = h.Parent end
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			if h then targetnnn = h.Parent end
			--h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		--[[if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)--]]
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char and dude ~= char.Model then
		--local bgf = IT("BodyGyro", dude.Head)
		--bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		--local val = IT("BoolValue", dude)
		--val.Name = "IsHit"
		targetnnn = dude
		--[[local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()--]]
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
--local SONG = 177031949
local SONG = 0
local SONG2 = 1130685064
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 10
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
local naeeym2 = IT("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 75
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = IT("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,1,1)
tecks2.TextStrokeColor3 = Color3.fromRGB(177, 167, 255)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
local top = Instance.new("Shirt")
top.ShirtTemplate = "rbxassetid://338740550"
top.Parent = char
top.Name = "Cloth"
local bottom = Instance.new("Pants")
bottom.PantsTemplate = "rbxassetid://338750779"
bottom.Parent = char
bottom.Name = "Cloth"
----------------------------------------------------------------------------------
--[[
		Thanks for using Build-To-Lua by jarredbcv.
]]--

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	--[[for _, c in pairs(char:GetChildren()) do
		if c.ClassName == "Part" and c.Name ~= "Detail" then
			--c.Material = "Fabric"
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			if c ~= hed then
				c.Color = Color3.new(1,1,1)
			else
				c.Color = Color3.new(1,1,1)
			end
		elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" then
			c:remove()
		elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then
			c:remove()
		end
	end--]]

Eyo = New("Model",char,"Eyo",{})
Eye = New("Part",Eyo,"Eye",{BrickColor = BrickColor.new("Institutional white"),Shape = Enum.PartType.Ball,Size = Vector3.new(1.96000075, 1.96000075, 1.96000075),CFrame = CFrame.new(-137.175568, 1.33095813, -17.0833168, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Pupil = New("Part",Eyo,"Pupil",{BrickColor = BrickColor.new("Black"),Shape = Enum.PartType.Ball,Size = Vector3.new(0.37000075, 0.37000075, 0.37000075),CFrame = CFrame.new(-137.235779, 1.42530513, -18.0334377, 1.00000072, -7.15256022e-07, 3.57628181e-07, -7.15256022e-07, 1.00000036, 2.01165761e-07, 3.57628181e-07, 2.01165761e-07, 1.00000215),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
--mot = New("Motor",Pupil,"mot",{Part0 = Pupil,Part1 = Eye,C0 = CFrame.new(0, 0, 0, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),C1 = CFrame.new(-0.0602111816, 0.0943470001, -0.950120926, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),})
TopHat2 = New("Part",Eyo,"TopHat2",{BrickColor = BrickColor.new("Really black"),Shape = Enum.PartType.Cylinder,Size = Vector3.new(0.0500000007, 1, 1),CFrame = CFrame.new(-137.740799, 2.24810791, -17.0272255, 0.458347857, 0.877660632, -0.140108809, -0.888243496, 0.446898967, -0.106327571, -0.0307050757, 0.173186749, 0.984412611),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
--mot = New("Motor",TopHat2,"mot",{Part0 = TopHat2,Part1 = Eye,C0 = CFrame.new(0, 0, 0, 0.458347201, -0.88824302, -0.0307050198, 0.877660394, 0.446899265, 0.173186243, -0.140109047, -0.106327735, 0.98441118),C1 = CFrame.new(-0.565231323, 0.917149663, 0.0560913086, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),})
TopHat1 = New("Part",Eyo,"TopHat1",{BrickColor = BrickColor.new("Really black"),Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.54000056, 1.80000043, 0.780000567),CFrame = CFrame.new(-138.100586, 2.94428444, -17.0250435, 0.457500041, 0.889210463, 3.57628181e-07, -0.88921082, 0.45749861, 2.01165761e-07, -1.52640816e-08, 4.10039718e-07, 1.00000215),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
--mot = New("Motor",TopHat1,"mot",{Part0 = TopHat1,Part1 = Eye,C0 = CFrame.new(0, 0, 0, 0.457499385, -0.889210343, -5.08804376e-09, 0.889210224, 0.457498908, 1.36679802e-07, 1.1920929e-07, 6.70552254e-08, 1.00000072),C1 = CFrame.new(-0.925018311, 1.61332572, 0.0582733154, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),})
OuterPupil = New("Part",Eyo,"OuterPupil",{BrickColor = BrickColor.new("Alder"),Material = Enum.Material.Neon,Shape = Enum.PartType.Ball,Size = Vector3.new(1.0000006, 1.0000006, 1.0000006),CFrame = CFrame.new(-137.20755, 1.40179217, -17.6748943, 1.00000072, -7.15256022e-07, 3.57628181e-07, -7.15256022e-07, 1.00000036, 2.01165761e-07, 3.57628181e-07, 2.01165761e-07, 1.00000215),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.fromRGB(185,183,183),})
--mot = New("Motor",OuterPupil,"mot",{Part0 = OuterPupil,Part1 = Eye,C0 = CFrame.new(0, 0, 0, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),C1 = CFrame.new(-0.0319824219, 0.0708340406, -0.59157753, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),})
TopHat3 = New("Part",Eyo,"TopHat3",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.779999912, 0.5, 0.769999981),CFrame = CFrame.new(-138.460098, 3.63034701, -17.0150394, -0.258819818, -0.455481321, 0.851792634, -5.44427401e-08, 0.881841302, 0.471547186, -0.965928435, 0.122045919, -0.228237376),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",TopHat3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
--mot = New("Motor",TopHat3,"mot",{Part0 = TopHat3,Part1 = Eye,C0 = CFrame.new(0, 0, 0, -0.258819461, -4.83165614e-08, -0.965926886, -0.455480665, 0.881840825, 0.122045726, 0.851792514, 0.471547544, -0.228237316),C1 = CFrame.new(-1.28453064, 2.29938841, 0.068277359, 1.00000024, -2.38418579e-07, 1.1920929e-07, -2.38418579e-07, 1.00000012, 6.70552254e-08, 1.1920929e-07, 6.70552254e-08, 1.00000072),})
for i, v in pairs(Eyo:GetChildren()) do
	if v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
tcnn=Instance.new('Part')
tcnn.CFrame=tors.CFrame*CFrame.new(0,-7.5,0)
tcnn.Anchored=true
tcnn.Transparency=1
tcnn.Size = tors.Size
tcnn.Name='Anchor'
tcnn.CanCollide=false
tcnn.Parent=workspace
task.spawn(function()
	while task.wait() do
		wait(0.2)
		tcnn.CFrame=CFrame.new(tors.CFrame.p.x,-6.5,tors.CFrame.p.z)
		tcnn.Anchored=true
	end
end)



cnnnnn["Head"]["att1_Head"].Parent = hatheadnn
for i, v in pairs(cnnnnn:GetDescendants()) do

	if v.Name == "AccessoryWeld" and v.Parent.Parent.Parent ~= cnnnnn.Model and v.Parent.Parent.Name ~= "Space Cop" and v.Parent.Parent.Name ~= "Small Magic Hat" and v.Parent.Parent.Name ~= "MeshPartAccessory" and v.Part1 == cnnnnn.Head then
		v.Part1 = tcnn
	end
end
hattop.Parent = hatheadnn
hateye.Parent = hatheadnn
hathead.Parent = Eye
local NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local HW = NewInstance('Weld',char,{Part0=tors, Part1=Eye, C0 = CF(0,4,0) * angles(0,0,0)})
--[[for i,v in pairs(char:children()) do
    if v:IsA("Hat") then
        v:Destroy()
    end
end
for i,v in pairs(char:children()) do
    if v:IsA("Accessory") then
        v:Destroy()
    end
end--]]
--hed.Transparency = 1
--hed.face:Remove()
-------------------------------------------------------
--End Customization--
-------------------------------------------------------

local BODY = {}
--[[for _, c in pairs(char:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= root and c ~= tors and c ~= hed and c ~= ra and c ~= la and c ~= rl and c ~= ll then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end--]]
function antideath()
	--[[char.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= root then
				
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:remove()
				PART.Parent = PARENT
				hum = IT("Humanoid",char)
				char.Archivable = false
			end
		end
	end--]]
end

--[[hum.Died:connect(function()
	antideath()
godmode = coroutine.wrap(function()
for i,v in pairs(char:GetChildren()) do
if v:IsA("BasePart") and v ~= root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", char)
ff.Visible = false
end)--]]

-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
local Sitt = false
function SittyBoi()
	attack = true
	Sitt = true
	SONG = 2479451853
	hum.WalkSpeed = 0
	repeat
		swait()
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(20), Rad(0), Rad(-40)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(20), Rad(0), Rad(-40)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(-40), Rad(0), Rad(30)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(-45), Rad(0), Rad(30)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(20), Rad(0), Rad(-40)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(20), Rad(0), Rad(-40)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(40), Rad(0), Rad(43)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(35), Rad(0), Rad(40)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(-40)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(-20)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
		for i = 0, 1.4, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0.1, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1+0.1*Cos(sine/20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(30), Rad(0), Rad(43)), 0.12)
			LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, -.1* Player_Size) * angles(Rad(25), Rad(0), Rad(40)), 0.12)
			HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
		end
	until Sitt == false
	--SONG = 177031949
	SONG = 0
	attack = false
	hum.WalkSpeed = 16
end
local takeonme = false
function TakeOnMe()
	attack = true
	hum.WalkSpeed = 5
	takeonme = true
	SONG = 2428645613
	repeat
	for i = 1, 15 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.4+((15-i)/50)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, 0.05* Player_Size, -.9* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(20)), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(20)), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
	end
	for i = 1, 15 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.4+((15-i)/50)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, 0.05* Player_Size, -.9* Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-20)), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-20)), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
	end
	until takeonme == false
	SONG = 0
	attack = false
	hum.WalkSpeed = 16
end
function Taunt1()
	attack = true
	hum.WalkSpeed = 0
	for i = 0, 9, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(15), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(0), Rad(78), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(15)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-78), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-15)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-9), Rad(0), Rad(155 + 25 * Sin(sine / 2.5))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 10
end
function Taunt2()
	attack = true
	hum.WalkSpeed = 0
	--Cso("221057812", hed, 10, 1.1)
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.5 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.6 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(-25 + 2.5 * Sin(sine / 20)), Rad(-55 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, .2 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * CF(0, 0, 2) * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.15)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1.2 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1.2 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(35), Rad(-25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(-55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 4 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0 - 255.45 * i), Rad(0), Rad(0)), 0.15)
	end
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.5 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.6 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(-25 + 2.5 * Sin(sine / 20)), Rad(-55 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 1.8, 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 10
end
function Astigmatism()
	attack = true
	hum.WalkSpeed = 0
	local Ring1 = Instance.new("Part", char)
	Ring1.Anchored = true
	Ring1.BrickColor = maincolor
	Ring1.CanCollide = false
	Ring1.FormFactor = 3
	Ring1.Name = "Ring"
	Ring1.Material = "Neon"
	Ring1.Size = Vector3.new(1, 0.05, 1)
	Ring1.Transparency = 1
	Ring1.TopSurface = 0
	Ring1.BottomSurface = 0
	local Ring1Mesh = Instance.new("SpecialMesh", Ring1)
	Ring1Mesh.MeshType = "Brick"
	Ring1Mesh.Name = "SizeMesh"
	Ring1Mesh.Scale = Vector3.new(0, 1, 0)
	local InnerRing1 = Ring1:Clone()
	InnerRing1.Parent = char
	InnerRing1.Transparency = 0
	InnerRing1.BrickColor = BrickColor.new("New Yeller")
	InnerRing1.Size = Vector3.new(1, 1, 1)
	local InnerRing1Mesh = InnerRing1.SizeMesh
	InnerRing1Mesh.Scale = Vector3.new(0, 0, 0)
	InnerRing1Mesh.MeshType = "Sphere"
	Ring1:Destroy()
	for i = 0, 6, 0.1 do
		swait()
		--orb.CFrame = Pupil.CFrame
		Aura(7, 0.12, "Add", Pupil.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0, "Sphere")
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * CF(0, 0, 1) * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(165 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(-165 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 3 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	InnerRing1.Transparency = 1
	InnerRing1.CFrame = Pupil.CFrame + root.CFrame.lookVector * 5
	Cso("294188875", char, 2.3, 1)
	local a = IT("Part", char)
	a.Name = "Direction"
	a.Anchored = true
	a.BrickColor = BrickC("Pastel violet")
	a.Material = "SmoothPlastic"
	a.Transparency = 0
	a.Shape = "Cylinder"
	a.CanCollide = false
	local a2 = IT("Part", char)
	a2.Name = "Direction"
	a2.Anchored = true
	a2.BrickColor = maincolor
	a2.Color = maincolor.Color
	a2.Material = "Neon"
	a2.Transparency = 0.7
	a2.Shape = "Cylinder"
	a2.CanCollide = false
	local ba = IT("Part", char)
	ba.Name = "HitDirect"
	ba.Anchored = true
	ba.BrickColor = maincolor
	ba.Material = "Neon"
	ba.Transparency = 1
	ba.CanCollide = false
	local ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
	local ignore = char
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	a2.BottomSurface = 10
	a2.TopSurface = 10
	local distance = (InnerRing1.CFrame.p - position).magnitude
	a.Size = Vector3.new(distance, 1, 1)
	a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	a2.Size = Vector3.new(distance, 1, 1)
	a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
	a.CFrame = a.CFrame * angles(0, Rad(90), 0)
	a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
	game:GetService("Debris"):AddItem(a, 20)
	game:GetService("Debris"):AddItem(a2, 20)
	game:GetService("Debris"):AddItem(ba, 20)
	local msh = Instance.new("SpecialMesh", a)
	msh.MeshType = "Brick"
	msh.Scale = Vector3.new(1, 5, 5)
	local msh2 = Instance.new("SpecialMesh", a2)
	msh2.MeshType = "Brick"
	msh2.Scale = Vector3.new(1, 7, 7)
	for i = 0, 10, 0.1 do
		swait()
		CameraEnshaking(1, 5)
		a2.Color = maincolor.Color
		--root.CFrame = FaceMouse()[1]
		InnerRing1.CFrame = Pupil.CFrame + root.CFrame.lookVector * 4
		ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
		hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		distance = (InnerRing1.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
		a.CFrame = a.CFrame * angles(0, Rad(90), 0)
		a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
		msh.Scale = msh.Scale - Vector3.new(0, 0.05, 0.05)
		msh2.Scale = msh2.Scale - Vector3.new(0, 0.03, 0.03)
		Aura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0, "Sphere")
		for i, v in pairs(FindNearestHead(ba.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
				Eviscerate(v)
			end
		end
	end
	a:Destroy()
	a2:Destroy()
	ba:Destroy()
	InnerRing1:Destroy()
	attack = false
	hum.WalkSpeed = 10
	hum.CameraOffset = Vector3.new(0,0,0)
end
function EyeThrow()
	attack = true
	hum.WalkSpeed = 3.01
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.7 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(215 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
    local Head01 = Eye:Clone()
	Head01.Parent = char
	Head01.Transparency = 1
	--Eye.Transparency = 1
	hathead.Parent = Head01
    local weldHead01 = IT("Weld")
    weldHead01.Parent = Head01
	weldHead01.Part0 = ra
    weldHead01.Part1 = Head01
	weldHead01.C1 = CF(0, 0, 1.2) * angles(Rad(90), Rad(0), Rad(0))
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(-20)), 0.2)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(20)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(145 + 2.5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(25), Rad(0), Rad(-15)), 0.2)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(20), Rad(0)), 0.1)
	end
	local A = IT("Attachment",Head01)
	A.Position = Vector3.new(-0, 0.2, 0.136)
	local B = IT("Attachment",Head01)
	B.Position = Vector3.new(-0, -0.95, -0.982)
	local Trail = IT("Trail",Head01)
	Trail.Attachment0 = B
	Trail.Attachment1 = A
	Trail.Lifetime = 0.6
	Trail.Transparency = NumberSequence.new(0.5, 1)
	Trail.Texture = "http://www.roblox.com/asset/?id=1472703539"
	Trail.Enabled = true
	weldHead01:Destroy()
        Head01.CanCollide = true
        local bodyVelocity2 = Create("BodyVelocity")({
          velocity = (mouse.Hit.p - Head01.CFrame.p).unit * 165,
          P = 5000,
          maxForce = Vector3.new(8000, 8000, 8000),
          Parent = Head01
        })
       game:GetService("Debris"):AddItem(bodyVelocity2, 0.05)
		Head01.Touched:connect(function(hit)
			if(not char:IsAncestorOf(hit))then
				local hum = (hit and hit.Parent and hit.Parent:FindFirstChildOfClass'Humanoid')
				local hedder = (hit and hit.Parent and hit.Parent:FindFirstChild'Head')
				if(hum and hedder and hum.Health > 0)then
				Eviscerate(hit.Parent)
			Cso("491296320", hit.Parent.Torso, 10, 1)
			end
		end
	end)
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(40)), 0.2)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(-40)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-134), Rad(0), Rad(145 + 2.5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(-15)), 0.1)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(-40), Rad(0)), 0.2)
	end
	for i = 0, 6, 0.1 do
		swait()
		--Eye.Transparency = Eye.Transparency - 0.05
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(40)), 0.2)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(-40)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-134), Rad(0), Rad(145 + 2.5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(-15)), 0.2)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(-40), Rad(0)), 0.1)
	end
	coroutine.resume(coroutine.create(function() 
		for i = 0, 1.8, 0.05 do
			swait()
			--Head01.Transparency = i
		end
		if hathead.Parent == Head01 then hathead.Parent = Eye end
		Head01:Destroy()
	end))
	--Head01:Destory()
	attack = false
	Trail.Enabled = false
	hum.WalkSpeed = 10
end
function Call_Upon_The_Eyes()
	attack = true
	hum.WalkSpeed = 0
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(145), Rad(0), Rad(15 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 3.5 + 0.2 * Cos(sine / 20), 0) * angles(Rad(90), Rad(0), Rad(0)), 0.1)
	end
	Magic(5, "Add", mouse.Hit * CFrame.new(0, -2.9, 0), Vector3.new(0, 0, 0), 1, maincolor, "Sphere")
	Magic(10, "Add", mouse.Hit * CFrame.new(0, -2.9, 0), Vector3.new(0, 0, 0), 2, maincolor, "Sphere")
	Magic(1, "Add", mouse.Hit, Vector3.new(1, 100000, 1), 0.5, maincolor, "Sphere")
	Magic(1, "Add", mouse.Hit, Vector3.new(1, 1, 1), 0.75, maincolor, "Sphere")
	CameraEnshaking(4, 25)
	for i, v in pairs(FindNearestHead(mouse.Hit.p, 14.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.4 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(45), Rad(0), Rad(15 + 2.5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.3 + 0.06 * Sin(sine / 20)* Player_Size, .6* Player_Size) * angles(Rad(-35), Rad(25 + 2.5 * Sin(sine / 20)), Rad(55 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 3 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0 - 255.45 * i), Rad(0), Rad(0)), 0.15)
	end
	attack = false
	hum.WalkSpeed = 10
end
function Eyeyeyeyeyeyey_Slammo()
	attack = true
	hum.WalkSpeed = 0
	local Blobby = IT("Part", char)
	Blobby.Name = "Blob"
	Blobby.CanCollide = false
	Blobby.BrickColor = BrickC("Really black")
	Blobby.Transparency = 0
	Blobby.Material = "Plastic"
	Blobby.Size = Vector3.new(1, 1, 2)
	Blobby.TopSurface = Enum.SurfaceType.Smooth
	Blobby.BottomSurface = Enum.SurfaceType.Smooth

	local Weld = IT("Weld", Blobby)
	Weld.Part0 = hed
	Weld.Part1 = Blobby
	Weld.C1 = CF(0, -17.6, 1.4)
	Weld.C0 = angles(Rad(0),0,0)

	local M2 = IT("SpecialMesh")
	M2.Parent = Blobby
	M2.MeshId = "http://www.roblox.com/asset/?id=1185246"
	M2.TextureId = "http://www.roblox.com/asset/?id=28301750"
	M2.Scale = Vector3.new(45.65, 45.65, 45.65)
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.2)
		neck.C0 = clerp(neck.C0, necko * CF(0, 0, 1) * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(165 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(-165 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	Magic(1, "Add", root.CFrame * CF(0, -1.9, -20), Vector3.new(1, 1, 1), 0.75, maincolor, "Sphere")
	Magic(5, "Add", root.CFrame * CF(0, -1.9, -20), Vector3.new(0, 0, 0), 1, maincolor, "Sphere")
	Magic(10, "Add", root.CFrame * CF(0, -1.9, -20), Vector3.new(0, 0, 0), 2, maincolor, "Sphere")
	for i, v in pairs(FindNearestHead(root.CFrame.p, 25.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	CameraEnshaking(4, 25)
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(90 + 2 * Cos(sine / 12)), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko * CF(0, 0, 1) * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1.3 - 0.1 * Cos(sine / 20)* Player_Size, -.2* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1.3 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-2 + 2 * Cos(sine / 12)), Rad(-74), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(165 + 2.5 * Sin(sine / 20))), 0.12)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-35), Rad(0), Rad(-165 + 2.5 * Sin(sine / 20))), 0.12)
		HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	Blobby:Destroy()
	attack = false
	hum.WalkSpeed = 10
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
local VALUE1 = false
mouse.KeyDown:connect(function(key)
	if (VALUE1 == false and attack == false) or Sitt == true then
		if key == "p" then
			if Sitt == false then
				SittyBoi()
			elseif Sitt == true then
				Sitt = false
			end
		end
	end
	if (VALUE1 == false and attack == false) or takeonme == true then
		if key == "l" then
			if takeonme == false then
				TakeOnMe()
			elseif takeonme == true then
				takeonme = false
			end
		end
	end
	if attack == false then
		if key == 't' then
			Taunt1()
		elseif key == 'y' then
			Taunt2()
		elseif key == 'z' then
			Astigmatism()
		elseif key == 'x' then
			EyeThrow()
		elseif key == 'c' then
			Call_Upon_The_Eyes()
		elseif key == 'v' then
			Eyeyeyeyeyeyey_Slammo()
		end
	end
end)


 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	antideath()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0.05 * Cos(sine / 20), 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1+0.05 * Cos(sine / 20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1+0.05 * Cos(sine / 20), -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(-4)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(35 + 5 * Cos(sine / 20))), 0.12)
				LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.5 + 0.06 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-35 - 5 * Cos(sine / 20))), 0.12)
				HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20)), Rad(0+1*Cos(sine/20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(3 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(6 - 2.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -0.82 - 0.52 * Cos(sine / 7) / 2.1, 0.6 * Cos(sine / 7) / 2)  * angles(Rad(-15 - 5 * Cos(sine / 7)) - rl.RotVelocity.Y / 90 + -Sin(sine / 7) / 2.2, Rad(90 - 3 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1, -0.82 + 0.52 * Cos(sine / 7) / 2.1, -0.6 * Cos(sine / 7) / 2) * angles(Rad(-15 + 5 * Cos(sine / 7)) + ll.RotVelocity.Y / 90 + Sin(sine / 7) / 2.2, Rad(-90 - 3 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0 - 0.5 * Cos(sine / 7)* Player_Size) * angles(Rad(65 * Cos(sine / 7)), Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 100), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0 + 0.5 * Cos(sine / 7)* Player_Size) * angles(Rad(-65 * Cos(sine / 7)), Rad(10 * Cos(sine / 7)) ,	Rad(0) + la.RotVelocity.Y / 100), 0.1)
				HW.C0 = clerp(HW.C0, CF(0, 2 + 0.2 * Cos(sine / 20), 0) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.925 - 0.5 * Cos(sine / 7) / 2, 0.7 * Cos(sine / 7) / 2) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1, -0.925 + 0.5 * Cos(sine / 7) / 2, -0.7 * Cos(sine / 7) / 2) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.34 * Cos(sine / 7)) * angles(Rad(110)  * Cos(sine / 7) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), -0.34 * Cos(sine / 7)) * angles(Rad(-110)  * Cos(sine / 7) , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	--[[for _, c in pairs(char:GetChildren()) do
		if c.ClassName == "Part" and c.Name ~= "Detail" then
			--c.Material = "Fabric"
			if c:FindFirstChildOfClass("ParticleEmitter") then
				--c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			if c ~= hed then
				c.Color = Color3.new(1,1,1)
			else
				c.Color = Color3.new(1,1,1)
			end
		elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" then
			--c:remove()
		elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then
			--c:remove()
		end
	end
	for _, c in pairs(char:GetChildren()) do
		if c:IsA("BasePart") then
			for _, e in pairs(c:GetChildren()) do
				if e:IsA("ParticleEmitter") or e:IsA("BodyPosition") or e:IsA("BodyGyro") then
					--e:remove()
					--hum:Destroy()
					--hum = IT("Humanoid",char)
				end
			end
		end
	end--]]
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 5
	Music:Resume()
	if Music.Parent ~= tors then
		Music = Instance.new("Sound",tors)
	end
	antideath()
	antideath()
	antideath()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
end)

Section:NewButton("Thor", "God Of Thunder", function()
    print("Clicked")
------------------------------------------------------------------------
-- Made by Cronizete --
------------------------------------------------------------------------
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/0n3Du5SM'),true))()
wait(6.1)
local cnnnnn = game.Players.LocalPlayer.Character
local targetrr = nil
local targetnnn = nil
local chooseee = false
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do

		if targetnnn ~= nil then
			print("Fling")

			--print(targetnnn) print(targetnnn.Parent)
			othertarget = targetnnn:FindFirstChild("Torso") or targetnnn:FindFirstChild("UpperTorso")
			if not othertarget then return end
			print(othertarget)

			GlobalFunctions.fling(othertarget,0.5)
			wait(0.1)
			targetnnn = nil

		end


	end
end)




a = false
--[[

-gh 6114870953,6114875330,6114844034,6114849049,63690008
--]]
wait()
hat = gp(gp(cnnnnn.Model, "CaramelBear", "Accessory"), "Handle", "BasePart")
hat.Mesh:Destroy()
hat = gp(gp(cnnnnn.Model, "FrostedBear", "Accessory"), "Handle", "BasePart")
hat.Mesh:Destroy()
hat = gp(gp(cnnnnn.Model, "SnowCookie", "Accessory"), "Handle", "BasePart")
hat.Mesh:Destroy()
hat = gp(gp(cnnnnn.Model, "Pal Hair", "Accessory"), "Handle", "BasePart")
hat.Mesh:Destroy()
hat = nil
local hat1 = gp(gp(gp(cnnnnn, "CaramelBear", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hat1.Rotation = Vector3.new(0, 90, 0)
hat1.Position = Vector3.new(0, 0, 0.4)
local hat2 = gp(gp(gp(cnnnnn, "FrostedBear", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hat2.Rotation = Vector3.new(0, 90, 0)
hat2.Position = Vector3.new(0, 0, -0.6)
local hat3 = gp(gp(gp(cnnnnn, "SnowCookie", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hat3.Rotation = Vector3.new(0, 90, 0)
hat3.Position = Vector3.new(0, 0, -1)
local hat4 = gp(gp(gp(cnnnnn, "Pal Hair", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hat4.Rotation = Vector3.new(0, 90, 0)
hat4.Position = Vector3.new(0, 0, 1.2)
wait()
--]]

local Player,Mouse,mouse,UserInputService = game:FindFirstChildOfClass("Players").LocalPlayer,game:FindFirstChildOfClass("Players").LocalPlayer:GetMouse(),game:FindFirstChildOfClass("Players").LocalPlayer:GetMouse(),game:GetService("UserInputService")
local run = game:GetService("RunService")
local hb = Instance.new("BindableEvent", script)
hb.Name = "ArtificialHB"
local frame = 1/60
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
hb:Fire()
run.Heartbeat:Connect(function(s, p)
	tf += s
	if tf >= frame then
		if allowframeloss then
			hb:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				hb:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(j)
	if j == 0 or j == nil then
		for i = 1, 2 do
			hb.Event:wait()
		end
	else
		for i = 1, j do
			hb.Event:wait()
		end
	end
end
Swait = swait

------------------------------------------------------------------------
-- Things --
------------------------------------------------------------------------

plr = game:FindFirstChildOfClass("Players").LocalPlayer
char = plr.Character
lleg,rleg,larm,rarm,hed = char["Left Leg"],char["Right Leg"],char["Left Arm"],char["Right Arm"],char["Head"]
rutprt,torso = char.HumanoidRootPart,char.Torso
otheranims,swimming,hum,stopanim,cooldown = false,false,char:FindFirstChildOfClass'Humanoid',false,false
TweenService = game:GetService("TweenService")
stopanim2 = false -- larm
stopanim3 = false -- head

hammer = Instance.new('Part', workspace)
hammer.Name = "Hammer"
hammer.CanCollide = true
hammer.Transparency = 1
hammer.Position = char.Head.Position
hammer.Size = Vector3.new(1.71, 1.31, 3.2)
--hammer.Locked = true
mesh = Instance.new('SpecialMesh', hammer)
--mesh.MeshId = "rbxassetid://12592754"
--mesh.TextureId = "rbxassetid://12592745"
--mesh.Scale = Vector3.new(1.05, 1.05, 1.05)
Swait()
hat1.Parent = hammer
Swait()
hat2.Parent = hammer
Swait()
hat3.Parent = hammer
Swait()
hat4.Parent = hammer
Swait()
fx = Instance.new('Part', char)
fx.Anchored = false
fx.CanCollide = false
fx.Transparency = 1
fx.Size = Vector3.new(1.77, 0.85, 1.05)
weld = Instance.new('Weld', fx)
weld.Part0 = fx
weld.Part1 = hammer
weld.C0 = CFrame.new(0, 0, -1.2)

func = hammer.Touched:connect(function(hit)
	if not hit.Parent:FindFirstChildOfClass'Humanoid' then
		wait(1)
		hammer.Anchored = true
		func:disconnect()
	end
end)

function gettorso(a)
	return a:FindFirstChild'Torso' or a:FindFirstChild'UpperTorso' or a:FindFirstChild'LowerTorso' or a:FindFirstChild'HumanoidRootPart'
end

------------------------------------------------------------------------
-- Animate Stuff --
------------------------------------------------------------------------
char.Animate.Disabled=true
local fldb={['w']=false,['a']=false,['s']=false,['d']=false}
local RunSpeed=30

local WlkSpeed=16
local SwimSpeed=14
local SwimDashSpeed=28
local anim = "Idling"
local lastanim = "Idling"
local val = 0
local syne = 0
local num = 0
local runtime = 0
local pseudohead=hed:Clone()
for i,x in pairs(pseudohead:GetChildren()) do if not x.ClassName:find('Mesh') then x:Destroy() end end
pseudohead.Name='PseudoHead'
pseudohead.Parent=char.Head
local pseudoweld=Instance.new('Weld',torso)
pseudoweld.Part0=hed
pseudoweld.Name='PseudoHedWld'
pseudoweld.Part1=pseudohead
hed.Transparency=1

coroutine.wrap(function() for i,x in pairs(hed:GetChildren()) do if x:IsA('Sound') then x:Destroy() end end end)()

function Lerp(a, b, i)
	local com1 = {a.X, a.Y, a.Z, a:toEulerAnglesXYZ()}
	local com2 = {b.X, b.Y, b.Z, b:toEulerAnglesXYZ()}
	local calx = com1[1] + (com2[1] - com1[1]) * i
	local caly = com1[2] + (com2[2] - com1[2]) * i
	local calz = com1[3] + (com2[3] - com1[3]) * i
	local cala = com1[4] + (com2[4] - com1[4]) * i
	local calb = com1[5] + (com2[5] - com1[5]) * i
	local calc = com1[6] + (com2[6] - com1[6]) * i
	return CFrame.new(calx, caly, calz) * CFrame.Angles(cala, calb, calc)
end

function TwnSingleNumber(s,f,m)
	local wot=s+(f-s)*m
	return wot
end

function TwnVector3(q,w,e)
	local begin={q.x,q.y,q.z}
	local ending={w.x,w.y,w.z}
	local bgx=begin[1]+(ending[1]-begin[1])*e
	local bgy=begin[2]+(ending[2]-begin[2])*e
	local bgz=begin[3]+(ending[3]-begin[3])*e
	return Vector3.new(bgx,bgy,bgz)
end

newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
	wld = Instance.new("Weld", wp1)
	wld.Part0 = wp0
	wld.Part1 = wp1
	wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end

local angles = CFrame.Angles
function clerp(a, b, t)
	return a:lerp(b, t)
end

newWeld(torso, larm, -1.5, 0.5, 0)
newWeld(torso, rarm, 1.5, 0.5, 0)
newWeld(torso, lleg, -.5, -2, 0)
newWeld(torso, rleg, .5, -2, 0)
newWeld(torso, hed, 0, 1.5, 0)
local rutwald=Instance.new('Weld',rutprt)
rutwald.Part0=rutprt
rutwald.Part1=torso
rutprt.Weld.C1=CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),0)
larm.Weld.C1 = CFrame.new(0, 0.5, 0)*CFrame.Angles(math.rad(0),0,0)
rarm.Weld.C1 = CFrame.new(0, 0.5, 0)*CFrame.Angles(math.rad(0),0,0)
rleg.Weld.C1=CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),0,0)
lleg.Weld.C1=CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),0,0)

------------------------------------------------------------------------
-- idk --
------------------------------------------------------------------------

wind = Instance.new('Sound', hammer)
wind.SoundId = "rbxassetid://866649671"
wind.PlaybackSpeed = 1.5
wind.Volume = 1
wind.Looped = true

grab = Instance.new('Sound', rarm)
grab.SoundId = "rbxassetid://1296135936"
grab.Volume = 1
grab.Looped = false

drop = Instance.new('Sound', hammer)
drop.SoundId = "rbxassetid://873196972"
drop.Volume = 1
drop.Looped = false

ghit = Instance.new('Sound', hammer)
ghit.SoundId = "rbxassetid://873196789"
ghit.Volume = 5
ghit.Looped = false

gyro = Instance.new('BodyGyro', hammer)
gyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
gyro.CFrame = CFrame.Angles(math.rad(90), 0, 0)

holding = false

fakearm = rarm:Clone()
fakearm.Name = "fakearm"
fakearm:ClearAllChildren''
fakearm.Parent = char
fakearm.Transparency = 1
fakearm.CanCollide = false
weld = Instance.new('Weld', fakearm)
weld.Part0 = fakearm
weld.Part1 = rarm
weld.C0 = CFrame.new(0, 0, 1)

------------------------------------------------------------------------
-- Lightning --
------------------------------------------------------------------------

Part0 = Instance.new("Part")
ParticleEmitter1 = Instance.new("ParticleEmitter")
Part0.Name = "lightning"
Part0.Parent = nil
Part0.Transparency = 1
Part0.FormFactor = Enum.FormFactor.Symmetric
Part0.Size = Vector3.new(0.820000052, 1.76999962, 2)
Part0.CFrame = CFrame.new(26.3400002, 0.884999812, 44.9500122, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part0.Position = Vector3.new(26.3400002, 0.884999812, 44.9500122)
ParticleEmitter1.Name = "Lightning"
ParticleEmitter1.Parent = Part0
ParticleEmitter1.Rotation = NumberRange.new(0, 360)
ParticleEmitter1.Size = NumberSequence.new(1.0429447889328,3.3742332458496,0,3.3435583114624,0,3.3742332458496,0,3.6503071784973,0.030674934387207,3.7730062007904,0,3.8036811351776,0,3.8343560695648,0,3)
ParticleEmitter1.Color = ColorSequence.new(Color3.new(0.27451, 0.607843, 1),Color3.new(1, 1, 1))
ParticleEmitter1.LightEmission = 1
ParticleEmitter1.Texture = "http://www.roblox.com/asset/?id=243098098"
ParticleEmitter1.Lifetime = NumberRange.new(1, 1)
ParticleEmitter1.Rate = 12312311808
ParticleEmitter1.Speed = NumberRange.new(0, 0)
ParticleEmitter1.Enabled = true
ParticleEmitter1.Color = ColorSequence.new(Color3.new(0.27451, 0.607843, 1),Color3.new(1, 1, 1))

function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans)
	local magz = (Part0 - Part1).magnitude
	local curpos = Part0
	local trz = {-Offset,Offset}
	for i=1,Times do
		local li = Instance.new("Part", torso)
		li.Name = "Lightning"
		li.TopSurface =0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = Trans or 0.4
		li.BrickColor = BrickColor.new(Color)
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(Thickness,Thickness,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet

		if Times == i then
			local magz2 = (curpos - Part1).magnitude
			li.Size = Vector3.new(Thickness,Thickness,magz2)
			li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
		end

		curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
		game.Debris:AddItem(li,.1)
	end
end

BodyParts = {} 
Bounding = {}
--table.insert(BodyParts, fx)

for _, v in pairs(BodyParts) do
	local temp = {X=nil, Y=nil, Z=nil}
	temp.X = v.Size.X/2 * 10
	temp.Y = v.Size.Y/2 * 10
	temp.Z = v.Size.Z/2 * 10
	Bounding[v.Name] = temp
end

spawn(function()
	while wait(math.random(1,7)/10) do
		if #BodyParts ~= 0 and #Bounding ~= 0 then
			local Body1 = BodyParts[math.random(#BodyParts)]
			local Body2 = BodyParts[math.random(#BodyParts)]
			local Pos1 = Vector3.new(
				math.random(-Bounding[Body1.Name].X, Bounding[Body1.Name].X)/10,
				math.random(-Bounding[Body1.Name].Y, Bounding[Body1.Name].Y)/10,
				math.random(-Bounding[Body1.Name].Z, Bounding[Body1.Name].Z)/10
			)
			local Pos2 = Vector3.new(
				math.random(-Bounding[Body2.Name].X, Bounding[Body2.Name].X)/10,
				math.random(-Bounding[Body2.Name].Y, Bounding[Body2.Name].Y)/10,
				math.random(-Bounding[Body2.Name].Z, Bounding[Body2.Name].Z)/10
			)
			local SPos1 = Body1.Position + Pos1
			local SPos2 = Body2.Position + Pos2
			Lightning(SPos1, SPos2, 4, 3, "Cyan", .3, .56)
		end
	end
end)

------------------------------------------------------------------------
-- Keys --
------------------------------------------------------------------------

using = false

function weldhammer()
	hammer.Anchored = false
	hammer.CanCollide = false
	grab:Play()
	weld = Instance.new('Weld', hammer)
	weld.Part0 = rarm
	weld.Part1 = hammer
	weld.C0 = CFrame.new(0, -0.6, -0.7) * CFrame.Angles(math.rad(0), math.rad(180), math.rad(90))
end

function gethammer()
	if (fakearm.Position - hammer.Position).magnitude >= 15 then
		stopanim = true
		using = true
		hammer.CanCollide = false
		hammer.Anchored = true
		wind:Play()

		--		a = hammer.Touched:connect(function(hit)
		--			if hit.Parent:FindFirstChildOfClass'Humanoid' and hit.Parent.Name ~= plr.Name then
		--				ghit:Play()
		--				if hit.Parent:FindFirstChildOfClass'Humanoid'.MaxHealth <= 100 and hit.Parent:FindFirstChild'HumanoidRootPart' then
		--					hit.Parent:FindFirstChildOfClass'Humanoid':TakeDamage(hit.Parent:FindFirstChildOfClass'Humanoid'.MaxHealth/2/2/2)
		--				elseif not hit.Parent:FindFirstChildOfClass'Humanoid'.MaxHealth <= 100 then
		--					hit.Parent:BreakJoints''
		--				elseif hit:IsA'Part' or hit:IsA'MeshPart' or hit:IsA'BasePart' or hit:IsA'UnionOperation' then
		--					hit.Anchored = false
		--					bv = Instance.new('BodyVelocity', hit)
		--					bv.MaxForce = Vector3.new(2e9, 2e9, 2e9)
		--					bv.Velocity = -hit.CFrame.lookVector * 50
		--					game:service'Debris':AddItem(bv, 0.2)
		--				end
		--			end
		--		end)

		for i = 0,4 do
			swait()
			rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(140)), .1)
		end
		repeat wait()
			hammer.CFrame = clerp(hammer.CFrame, fakearm.CFrame * CFrame.new(0, -0.6, 0) * CFrame.Angles(0, math.rad(180), math.rad(90)), .1) 
			if (fakearm.Position - hammer.Position).magnitude >= 3 then
				wind.Volume = 3
			else
				wind.Volume = (fakearm.Position - hammer.Position).magnitude
			end
		until (fakearm.Position - hammer.Position).magnitude <= .7

		if a then a:disconnect() end
		hammer.Anchored = false
		hammer.CanCollide = false
		weldhammer()
		wind:Stop()
		wait(.3)
		stopanim = false
		using = false
	end
end

function drophammer()
	a = hammer.Touched:connect(function(hit)
		if not hit.Parent:FindFirstChildOfClass'Humanoid' then
			drop:Play()
			wait(1)
			hammer.Anchored = true
			a:disconnect()
		end
	end)

	hammer.Anchored = false
	for _, a in pairs(hammer:children'') do
		if a:IsA'Weld' then
			a:Destroy''
		end
	end
	hammer.CanCollide = true
end

function attacktargets()
	if #targets >= 1 and holding then
		using = true
		hum.WalkSpeed = 0
		hum.JumpPower = 0

		for i = 1,75 do
			swait()
			larm.Weld.C0 = clerp(larm.Weld.C0, larm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(math.rad(91), math.rad(-6), math.rad(-19)), 0.1)
			rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(-math.rad(-165), math.rad(0), math.rad(0)), 0.1)
		end
		hum.WalkSpeed = 16
		hum.JumpPower = 50
		hammer.Anchored = true
		for _, a in pairs(hammer:children'') do
			if a:IsA'Weld' then
				a:Destroy''
			end
		end
		hammer.CanCollide = false
		holding = false
		for _, a in pairs(targets) do
			ttorso = gettorso(a)
			if a ~= nil and gettorso(a) and a:FindFirstChildOfClass'Humanoid' then
				repeat wait() a:FindFirstChildOfClass'Humanoid'.WalkSpeed = 5 hammer.CFrame = clerp(hammer.CFrame, ttorso.CFrame * CFrame.Angles(0, math.rad(ttorso.CFrame.lookVector.Y), 0), 0.1) until (hammer.Position - ttorso.Position).magnitude <= 6 
				--a:BreakJoints'' 
				--ghit:Play()
				GlobalFunctions.fling(a,1)
				targetnnn = a ghit:Play()
			end
		end
		for _, a in pairs(rotate) do
			if a ~= nil then
				a:Destroy''
			end
		end
		targets = {}
		rotate = {}
		hammer.CanCollide = false



		stopanim = true
		hammer.CanCollide = false
		hammer.Anchored = true
		wind:Play()

		for i = 0,4 do
			wait()
			rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(140)), .1)
		end
		repeat wait()
			hammer.CFrame = clerp(hammer.CFrame, fakearm.CFrame * CFrame.new(0, -0.6, 0) * CFrame.Angles(0, math.rad(180), math.rad(90)), .13) 
			if (fakearm.Position - hammer.Position).magnitude >= 3 then
				wind.Volume = 3
			else
				wind.Volume = (fakearm.Position - hammer.Position).magnitude
			end
		until (fakearm.Position - hammer.Position).magnitude <= .7

		hammer.Anchored = false
		hammer.CanCollide = false
		weldhammer()
		wind:Stop()
		holding = true
		wait(.3)
		stopanim = false
		using = false
	end
end

function bgrab()
	for _, a in pairs(workspace:children'') do
		if a:FindFirstChildOfClass'Humanoid' and gettorso(a) and a.Name ~= plr.Name then
			ttorso = gettorso(a)
			if (ttorso.Position - rutprt.Position).magnitude <= 3 then
				using = true
				target2 = a
				stopanim2 = true
				target:FindFirstChildOfClass'Humanoid'.WalkSpeed = 0
				target:FindFirstChildOfClass'Humanoid'.JumpPower = 0
				hum.WalkSpeed = 0
				hum.JumpPower = 0
				for i = 0,25 do
					swait()
					larm.Weld.C0 = clerp(larm.Weld.C0, CFrame.new(-1.5,.525,0) * CFrame.Angles(math.rad(100), math.rad(20), math.rad(20)), 0.1)
				end
				weld = Instance.new('Weld', rutprt)
				weld.Part0 = rutprt
				weld.Part1 = ttorso
				weld.C0 = CFrame.new(-0.5, 0, -1.2)

				wait(.1)


				ttorso.Anchored = true
				b = Instance.new('Part', char)
				b.Anchored = true
				b.CanCollide = false
				b.Transparency = 1
				b.CFrame = hed.CFrame
				b.Position = hed.Position + Vector3.new(0, 50, 0) + hed.CFrame.lookVector * 500

				d = Instance.new('Part', char)
				d.Anchored = true
				d.CanCollide = false
				d.Transparency = 1
				d.CFrame = hed.CFrame
				d.Position = hed.Position - Vector3.new(0, 5.6, 0) + hed.CFrame.lookVector * -45

				wait(.5)
				for i = 1,75 do
					swait()
					rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(-math.rad(-165), math.rad(0), math.rad(0)), 0.1)
				end
				drophammer()
				wind:Play()

				repeat wait() 
					hammer.Anchored = true
					hammer.CFrame = clerp(hammer.CFrame, b.CFrame, 0.1) 
					wind.Volume = (hammer.Position - d.Position).magnitude
				until (hammer.Position - b.Position).magnitude <= 5

				repeat wait()
					hammer.Anchored = true 
					hammer.CFrame = clerp(hammer.CFrame, d.CFrame, 0.1) 
					wind.Volume = (hammer.Position - d.Position).magnitude
				until (hammer.Position - d.Position).magnitude <= 45

				--target2:BreakJoints''
				GlobalFunctions.fling(a,1)
				targetnnn = a
				ghit:Play()
				wind:Stop()
				wait(.1)
				stopanim2 = false
				hum.WalkSpeed = 16
				hum.JumpPower = 50
				b:Destroy''
				d:Destroy''
				hammer.Anchored = false
				weldhammer()
				grab:Play()
				using = false
			end
		end
	end
end

function shield()
	using = true
	hum.WalkSpeed = 0
	hum.JumpPower = 0
	for i = 1,75 do
		swait()
		larm.Weld.C0 = clerp(larm.Weld.C0, larm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(math.rad(91), math.rad(-6), math.rad(-19)), 0.1)
		rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(-math.rad(-165), math.rad(0), math.rad(0)), 0.1)
	end
	hum.WalkSpeed = 16
	hum.JumpPower = 50
	drophammer()
	hammer.Anchored = true
	hammer.CanCollide = true
	using = false
end

function stopshield()
	gethammer()
end

--function transform()
--	stopanim = true
--	stopanim3 = true
--	hum.WalkSpeed = 0
--	hum.JumpPower = 0
--	for i = 0,7 do
--		wait()
--		hammer.Weld.C0 = clerp(hammer.Weld.C0, CFrame.new(0, -2.5, -0.7) * CFrame.Angles(math.rad(-85), math.rad(180), math.rad(90)), 0.1)
--		rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(-math.rad(-179), math.rad(0), math.rad(15)), 0.1)
--		hed.Weld.C0 = clerp(hed.Weld.C0, hed.Weld.C0 * CFrame.new(0,0,0.2)*CFrame.Angles(math.rad(40), math.rad(0), math.rad(0)), 0.1)
--	end	
--	a = Instance.new('Part', char)
--	a.Name = "hello"
--	a.Size = Vector3.new(0.2, 0.2, 0.2)
--	a.Anchored = true
--	a.CanCollide = false
--	a.Position = hammer.Position + Vector3.new(0, 75, 0)	
--	
--	wait(3)
--	table.insert(BodyParts, fx)
--	wait(4)
--	
--	spawn(function()
--		for i = 0,45 do
--			swait()
--			hammer.Weld.C0 = clerp(hammer.Weld.C0, CFrame.new(0, -0.6, -0.7) * CFrame.Angles(math.rad(0), math.rad(180), math.rad(90)), 0.07)
--		end
--	end)
--	
--	hum.WalkSpeed = 16
--	hum.JumpPower = 50
--	stopanim = false
--	stopanim3 = false
--end

------------------------------------------------------------------------
-- Target --
------------------------------------------------------------------------	

bg = Instance.new('BillboardGui', plr.PlayerGui)
bg.Size = UDim2.new(15, 0, 15, 0)
bg.AlwaysOnTop = true
il = Instance.new('ImageLabel', bg)
il.Image = "rbxassetid://142406345"
il.BackgroundTransparency = 1
il.Size = UDim2.new(1, 0, 1, 0)
il.ImageColor3 = Color3.new(0,0,0)

home = false
down = false
barrier = false
targets = {}
rotate = {}

mouse.KeyDown:connect(function(k)
	key = k:lower()
	if key == "g" and not barrier and not using then
		attacktargets()
	end

	if key == "e" and not cooldown and not barrier and not using then
		cooldown = true
		if not holding and (fakearm.Position - hammer.Position).magnitude >= 15 then
			holding = true
			gethammer()
		elseif holding then
			holding = false
			drophammer()
		end
		wait(.3)
		cooldown = false
	end

	if key == "q" and not cooldown and holding and not barrier and not using then
		cooldown = true
		using = true
		hum.WalkSpeed = 0
		hum.JumpPower = 0
		for i = 1,75 do
			swait()
			larm.Weld.C0 = clerp(larm.Weld.C0, larm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(math.rad(91), math.rad(-6), math.rad(-19)), 0.1)
			rarm.Weld.C0 = clerp(rarm.Weld.C0, rarm.Weld.C0 * CFrame.new(0,0,0)*CFrame.Angles(-math.rad(-165), math.rad(0), math.rad(0)), 0.1)
		end
		hum.WalkSpeed = 16
		hum.JumpPower = 50
		holding = false
		drophammer()
		targetrr = nil
		chooseee = false
		if mouse.Target then
			if gettorso(mouse.Target.Parent) then
			targetrr = gettorso(mouse.Target.Parent)
				targetrr = targetrr.CFrame * CFrame.Angles(0, math.rad(targetrr.CFrame.lookVector.Y), 0)
			end
		elseif not mouse.Target then
			targetrr = nil
		end
		if targetrr ~= nil then
		for i = 1,25 do
			swait()
			hammer.CFrame = clerp(hammer.CFrame, targetrr, 0.1)
			end
		end
		wait(.5)
		cooldown = false
		using = false
		targetrr = nil
		chooseee = false
	end

	if key == "f" and holding and not cooldown and not barrier and not using then
		cooldown = true
		bgrab()
		wait(.2)
		cooldown = false
	end

	if key == "v" and holding and not using then
		if not barrier then
			shield()
			barrier = true
		else
			barrier = false
			stopshield()
		end
	end
end)

mouse.Button1Down:connect(function()
	if home and holding then
		clone = bg:clone()
		clone.Parent = plr.PlayerGui
		clone.ImageLabel.ImageColor3 = Color3.new(255,255,255)
		clone.Name = "hi"
		if gettorso(mouse.Target.Parent) then
			clone.Adornee = gettorso(mouse.Target.Parent)
			table.insert(targets, mouse.Target.Parent)
			table.insert(rotate, clone)
		elseif not gettorso(mouse.Target.Parent) then
			clone:Destroy''
		end
	end
end)

spawn(function()
	while wait() do

		il.Rotation = il.Rotation + 5
		if holding and mouse.Target and mouse.Target.Parent and gettorso(mouse.Target.Parent) and mouse.Target.Parent:FindFirstChildOfClass'Humanoid' and mouse.Target.Parent:FindFirstChildOfClass'Humanoid'.Health ~= 0 then
			target = mouse.Target.Parent

			home = true
			il.ImageTransparency = 0
			bg.Adornee = gettorso(target)
		elseif not mouse.Target then
			il.ImageTransparency = 1
			home = false
		elseif not mouse.Target.Parent then
			il.ImageTransparency = 1
			home = false
		elseif not mouse.Target.Parent:FindFirstChildOfClass'Humanoid' then
			il.ImageTransparency = 1
			home = false
		end

	end
end)

spawn(function()
	while wait() do
		for _, a in pairs(rotate) do
			if a ~= nil then
				a.ImageLabel.Rotation = a.ImageLabel.Rotation + 5
			elseif targets <= 0 then
				a:Destroy''
			end
		end
	end
end)

------------------------------------------------------------------------
-- Manual Pickup --
------------------------------------------------------------------------	

hammer.Touched:connect(function(hit)
	if not holding and not using and hammer.Anchored and hit.Parent.Name == plr.Name then
		holding = true
		hammer.Anchored = false
		hammer.CanCollide = false
		weldhammer()
	end
end)

------------------------------------------------------------------------
-- Important functions --
------------------------------------------------------------------------

died = false



spawn(function()
	while wait() do
		if holding and hammer:FindFirstChildOfClass'Weld' then
			hammer.Anchored = false
		end
	end
end)

x = 0
spawn(function()
	while wait() do
		if barrier then
			x = x + 0.6
			hammer.CFrame = rutprt.CFrame * CFrame.Angles(0,0.1-x,0) * CFrame.new(25,0,0)

			for _, a in pairs(workspace:children'') do
				ttorso = gettorso(a)
				if a:FindFirstChildOfClass'Humanoid' and a:FindFirstChildOfClass'Humanoid'.Health ~= 0 and a.Name ~= plr.Name and gettorso(a) and (ttorso.Position - hammer.Position).magnitude <= 15 then
					--a:BreakJoints''
					--ghit:Play()
					GlobalFunctions.fling(a,1)
					targetnnn = a ghit:Play()
				elseif a:FindFirstChildOfClass'Humanoid' and not gettorso(a) then
					--a:BreakJoints''
					GlobalFunctions.fling(a,1)
					targetnnn = a
				end
			end

			for _, a in pairs(workspace:children'') do
				ttorso = gettorso(a)
				if a:FindFirstChildOfClass'Humanoid' and a:FindFirstChildOfClass'Humanoid'.Health ~= 0 and a.Name ~= plr.Name and gettorso(a) and (ttorso.Position - rutprt.Position).magnitude <= 10 then
					--a:BreakJoints''
					--ghit:Play()
					GlobalFunctions.fling(a,1)
					targetnnn = a ghit:Play()
				elseif a:FindFirstChildOfClass'Humanoid' and not a:FindFirstChild'HumanoidRootPart' then
					--a:BreakJoints''
					GlobalFunctions.fling(a,1)
					targetnnn = a
				end
			end

			if x == 1 then
				x = 0.1
			end
		end
	end
end)

------------------------------------------------------------------------
-- Animations --
------------------------------------------------------------------------

while true do
	swait()

	if holding then
		gyro.Parent = nil
	elseif not holding then
		gyro.Parent = hammer
		gyro.Name = "hamma"
	end

	ypcall(function()
		if anim~=lastanim then
			runtime=0
		end
		lastanim=anim
		hum.CameraOffset=(rutprt.CFrame:toObjectSpace(hed.CFrame)).p+Vector3.new(0,-1.25,0)
		syne=syne+.95
		if not otheranims and not swimming then
			if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 1 and not hum.Jump then-- and torso.Velocity.y<5 and torso.Velocity.y>-5
				anim="Idling"
			elseif hum.FloorMaterial ~= Enum.Material.Air and (rutprt.Velocity*Vector3.new(1, 0, 1)).magnitude > 1 and (rutprt.Velocity*Vector3.new(1, 0, 1)).magnitude < RunSpeed-10 and not hum.Jump then-- and torso.Velocity.y<5 and torso.Velocity.y>-5
				anim="Walking"
			elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude > RunSpeed-10 and not hum.Jump then-- and torso.Velocity.y<5 and torso.Velocity.y>-5
				anim="Sprinting"
			elseif torso.Velocity.y < -1 then
				anim='Falling'
			end
		end

		if anim=="Idling" and hum.WalkSpeed ~= 0 then
			idlesineinc=35

			if not stopanim then
				rarm.Weld.C0=clerp(rarm.Weld.C0,CFrame.new(1.5,.55+math.cos(syne/idlesineinc)/25,0)*CFrame.Angles(math.rad(1),math.rad(0),math.rad(6)),.1)
			end

			if not stopanim2 then
				larm.Weld.C0=clerp(larm.Weld.C0,CFrame.new(-1.5,.55+math.cos(syne/idlesineinc)/25,0)*CFrame.Angles(math.rad(0),0,math.rad(-6)),.1)
			end

			if not stopanim3 then
				hed.Weld.C0=clerp(hed.Weld.C0,CFrame.new(0,1.5+math.cos(syne/idlesineinc)/50,0)*CFrame.Angles(math.cos(syne/idlesineinc)/40,0,0),.1)
			end

			lleg.Weld.C0=clerp(lleg.Weld.C0,CFrame.new(-.55,-1.9-math.cos(syne/idlesineinc)/20,(math.cos(syne/idlesineinc)/35))*CFrame.Angles(-(math.cos(syne/idlesineinc)/35),0,math.rad(-2.5)),.1)
			rleg.Weld.C0=clerp(rleg.Weld.C0,CFrame.new(.55,-1.9-math.cos(syne/idlesineinc)/20,(math.cos(syne/idlesineinc)/35))*CFrame.Angles(-(math.cos(syne/idlesineinc)/35),0,math.rad(2.5)),.1)
			rutprt.Weld.C0=clerp(rutprt.Weld.C0,CFrame.new(0,-.1+math.cos(syne/idlesineinc)/20,0)*CFrame.Angles(math.cos(syne/idlesineinc)/35+math.rad(0),math.rad(0),math.rad(0)),.1)
		end

		if anim=="Walking" and hum.WalkSpeed ~= 0 then
			if not stopanim then
				rarm.Weld.C0=clerp(rarm.Weld.C0,CFrame.new(1.5,.525+math.cos(syne/15)/25,0)*CFrame.Angles(math.cos(syne/6)/1.25,math.rad(5),-(math.cos(syne/6.75)/15)+math.rad(3)),.1)
			end

			if not stopanim2 then
				larm.Weld.C0=clerp(larm.Weld.C0,CFrame.new(-1.5,.525+math.cos(syne/15)/25,0)*CFrame.Angles(-(math.cos(syne/6)/1.25),0,-(math.cos(syne/6.75)/15)-math.rad(3)),.1)
			end

			if not stopanim3 then
				hed.Weld.C0=clerp(hed.Weld.C0,CFrame.new(0,1.5+math.cos(syne/20)/50,0)*CFrame.Angles(-math.cos(syne/3)/20,0,0),.1)
			end

			lleg.Weld.C0=clerp(lleg.Weld.C0,CFrame.new(-.55,-1.9-math.cos(syne/6)/10,-(math.cos(syne/6)/1.125))*CFrame.Angles(math.cos(syne/6)/1.125,0,math.rad(-2.5)),.1)
			rleg.Weld.C0=clerp(rleg.Weld.C0,CFrame.new(.55,-1.9-math.cos(syne/6)/10,math.cos(syne/6)/1.125)*CFrame.Angles(-(math.cos(syne/6)/1.125),0,math.rad(2.5)),.1)
			rutprt.Weld.C0=clerp(rutprt.Weld.C0,CFrame.new(0,-.1+math.cos(syne/3.375)/20,math.cos(syne/3)/5)*CFrame.Angles(math.cos(syne/3)/20+math.rad(-3.5),math.cos(syne/6)/10,-math.cos(syne/6)/30+math.sin(rutprt.RotVelocity.y/2)/7.5),.1)
		end

		if hum.WalkSpeed == 0 then
			if not stopanim then
				rarm.Weld.C0=clerp(rarm.Weld.C0,CFrame.new(1.5,.55+math.cos(syne/idlesineinc)/25,0)*CFrame.Angles(math.rad(1),math.rad(0),math.rad(6)),.1)
			end

			if not stopanim2 then
				larm.Weld.C0=clerp(larm.Weld.C0,CFrame.new(-1.5,.55+math.cos(syne/idlesineinc)/25,0)*CFrame.Angles(math.rad(0),0,math.rad(-6)),.1)
			end

			if not stopanim3 then
				hed.Weld.C0=clerp(hed.Weld.C0,CFrame.new(0,1.5+math.cos(syne/idlesineinc)/50,0)*CFrame.Angles(math.cos(syne/idlesineinc)/40,0,0),.1)
			end

			lleg.Weld.C0=clerp(lleg.Weld.C0,CFrame.new(-.55,-1.9-math.cos(syne/idlesineinc)/20,(math.cos(syne/idlesineinc)/35))*CFrame.Angles(-(math.cos(syne/idlesineinc)/35),0,math.rad(-2.5)),.1)
			rleg.Weld.C0=clerp(rleg.Weld.C0,CFrame.new(.55,-1.9-math.cos(syne/idlesineinc)/20,(math.cos(syne/idlesineinc)/35))*CFrame.Angles(-(math.cos(syne/idlesineinc)/35),0,math.rad(2.5)),.1)
			rutprt.Weld.C0=clerp(rutprt.Weld.C0,CFrame.new(0,-.1+math.cos(syne/idlesineinc)/20,0)*CFrame.Angles(math.cos(syne/idlesineinc)/35+math.rad(0),math.rad(0),math.rad(0)),.1)
		end

		if 1 < rutprt.Velocity.y and hum.FloorMaterial == Enum.Material.Air and hum.JumpPower ~= 0 then
			hed.Weld.C0=clerp(hed.Weld.C0,CFrame.new(0,1.5,-.3)*CFrame.Angles(math.rad(-40),0,0),.065)
			rarm.Weld.C0=clerp(rarm.Weld.C0,CFrame.new(1.5,.525,0)*CFrame.Angles(math.rad(10),0,math.rad(70)),.1)
			larm.Weld.C0=clerp(larm.Weld.C0,CFrame.new(-1.5,.525,0)*CFrame.Angles(math.rad(10),0,math.rad(-70)),.1)
			lleg.Weld.C0=clerp(lleg.Weld.C0,CFrame.new(-.55,-1.2,0)*CFrame.Angles(math.rad(-14),0,math.rad(-2.5)),.1)
			rleg.Weld.C0=clerp(rleg.Weld.C0,CFrame.new(.55,-1.9,0)*CFrame.Angles(math.rad(0),0,math.rad(2.5)),.1)
			rutprt.Weld.C0=clerp(rutprt.Weld.C0,CFrame.new(0,-.1+math.cos(syne/20)/20,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.1)
		elseif -1 > rutprt.Velocity.y and hum.FloorMaterial == Enum.Material.Air then
			hed.Weld.C0=clerp(hed.Weld.C0,CFrame.new(0,1.5,-.3)*CFrame.Angles(math.rad(-40),0,0),.065)	
			rarm.Weld.C0=clerp(rarm.Weld.C0,CFrame.new(1.5,.525,0)*CFrame.Angles(math.rad(10),0,math.rad(70)),.06)
			larm.Weld.C0=clerp(larm.Weld.C0,CFrame.new(-1.5,.525,0)*CFrame.Angles(math.rad(10),0,math.rad(-70)),.06)
			lleg.Weld.C0=clerp(lleg.Weld.C0,CFrame.new(-.55,-1.2,0)*CFrame.Angles(math.rad(-14),0,math.rad(-2.5)),.06)
			rleg.Weld.C0=clerp(rleg.Weld.C0,CFrame.new(.55,-1.9,0)*CFrame.Angles(math.rad(0),0,math.rad(2.5)),.06)
			rutprt.Weld.C0=clerp(rutprt.Weld.C0,CFrame.new(0,-.1+math.cos(syne/20)/20,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.06)
		end
	end)
end
end)

Section:NewButton("Pro Knife", "JoJo referance", function()
    print("Clicked")
local Player = game:service'Players'.localPlayer
--Player = game:GetService("Players"):GetPlayerFromCharacter(script.Parent)
game.Players:Chat("-gh 7170680556")
wait(0.8)
script = game:GetObjects("rbxassetid://6569617509")[1].ProKnife
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))() --mw reanimate 36

wait(.1)

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
	local loudnesses={}
	script.Parent = Player.Character
	local CoAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInputEvent"
	Event.Parent = Player.Character
	local Func = {}
	
	local me = game:service'Players'.localPlayer;
	local mouse = me:GetMouse();
	local UIS = game:service'UserInputService'
	local ch = workspace:WaitForChild(me.Name);
	
	

	local sounds = {}

	function Func:InvokeServer(inst,play)
	
		if(inst and typeof(inst) == 'Instance' and inst:IsA'Sound')then
			loudnesses[inst]=play	
		end
	end
	
	function regSound(o)
		if(o:IsA'Sound')then

			local lastLoudness = o.PlaybackLoudness
			Func:InvokeServer(o,lastLoudness)
			table.insert(sounds,{o,lastLoudness})
			--ClientProp:InvokeServer(o,o.PlaybackLoudness)
		end
	end

	function Func:InvokeClient(inst,prop)
		if(inst == 'RegSound')then
			regSound(prop)
			for i = 1, #sounds do
				if(sounds[i][1] == prop)then 
					return sounds[i][2]
				end 
			end 
		else
			return inst[prop]
		end
	end

	for _,v in next, workspace:GetDescendants() do regSound(v) end
	workspace.DescendantAdded:connect(regSound)
	me.Character.DescendantAdded:connect(regSound)

	game:service'RunService'.RenderStepped:connect(function()
		
		for i = 1, #sounds do
			local tab = sounds[i]
			local object,last=unpack(tab)
			if(object.PlaybackLoudness ~= last)then
				sounds[i][2]=object.PlaybackLoudness
				Func:InvokeServer(object,sounds[i][2])
			end
		end
	end)
	
local m = me:GetMouse();
local Mouse = me:GetMouse();
local UsIS = game:service'UserInputService'
	

	
	
	function GetClientProperty(inst,prop)
		if(prop == 'PlaybackLoudness' and loudnesses[inst])then 
			return loudnesses[inst] 
		elseif(prop == 'PlaybackLoudness')then
			return Func:InvokeClient('RegSound',inst)
		end
		return Func:InvokeClient(inst,prop)
	end


-----------------------------
--Player = game:GetService("Players").powertommm
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Character)
sick.Parent = Torso
sick.Name = "comander_cool"
sick:resume()
sick.Looped = true
sick.Volume = 1
sick.SoundId = "rbxassetid://5558568853"
sick.Pitch = 1
LastId = "rbxassetid://5558568853"
thetime = 0
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
it = Instance.new
mde = "1"
Animation_Speed = 3
local FORCERESET = false
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local HOODC0 = CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0))
local SHOTGUNC0 = CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local s = 0
local c = 1
local anchrd = false
local RUN = game:service'RunService'
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local AntiBanish = true
local Amde = "box"
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local NICE = false
local VALUE3 = false
--ROBLOXIDLEANIMATION.Parent = Humanoid

local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local kay = false
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
local SKILLFONT = "Arcade"
--//=================================\\
--\\=================================//

local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local Plrs = S.Players
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function shakes(power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Shaker:Clone()
	var.Parent = v.Character
	local pw = var.Shakeval
	local lgth = var.MultLength
	pw.Value = power
	lgth.Value = length
	var.Disabled = false
	game:GetService("Debris"):AddItem(var, length+4)
	end
end

local INFACES = {54225558,4218765670,43840015,2305445434,62715613,328783891,297839245,121800545,66766963,7918803}

ff = Instance.new("ForceField",Character)
ff.Visible = false

function localshakes(power,length)
local var = script.Shaker:Clone()
var.Parent = Player.Character
local pw = var.Shakeval
local lgth = var.MultLength
pw.Value = power
lgth.Value = length
var.Disabled = false
game:GetService("Debris"):AddItem(var, length+4)
end

face = 297839245

local MATTER = {"Plastic","Wood","Slate","Concrete","CorrodedMetal","DiamondPlate","Foil","Grass","Ice","Marble","Granite","Brick","Pebble","Sand","Fabric","SmoothPlastic","Metal","WoodPlanks","Cobblestone","Air","Water","Rock","Glacier","Snow","Sandstone","Mud","Basalt","Ground","CrackedLava","Neon","Glass","Asphalt","LeafyGrass","Salt","Limestone","Pavement","ForceField"}

local PlayerSize = 1
local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)

local AUDIOS = {"rbxassetid://844654533","rbxassetid://1439600000","rbxassetid://2256088590","rbxassetid://3154204326"}

if Player.Character:FindFirstChild("Animate") then
	local an = Humanoid:GetPlayingAnimationTracks()
	for i = 1, #an do
		an[i]:Stop()
	end
	Humanoid.Animator:Destroy()
	Player.Character:FindFirstChild("Animate"):Destroy()
	ANIMATOR:Destroy()
	ANIMATE:Destroy()
end
local fakerot = 0

local CHATS = {"It burns.","It's gone.","Something...Is missing.","Why is this happening?","I've been poisoned.","I Feel sick."}
local mde = "normal"
local FONTS = {"Fantasy","Highway","SciFi"}




--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
--DO NOT TOUCH THIS
if Character:FindFirstChild("Adds")then wait(.2) script.Disabled = true script:Destroy() error("You Shouldn't Have Added A Banisher Gun To My Script") end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Rwait(num)
if num == 0 or num == nil then
RUN.Stepped:wait()
else
for i=0,num do
RUN.Stepped:wait()
end
end
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
local S = IT("Sound",script)
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateSound2(ID, PARENT, VOLUME, PITCH, TIMEPOS, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.TimePosition = TIMEPOS
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end
function ApplyDamage(Humanoid,Damage)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health < 2000 then
		if Humanoid.Health - Damage > 0 then
			Humanoid.Health = Humanoid.Health - Damage
		else
			Humanoid.Parent:BreakJoints()
		end
	else
		Humanoid.Parent:BreakJoints()
	end
end

function Fancy_spawntrail(LOC,AIMTO,OUCH)
	WACKYEFFECT2({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1.1,1.1,1.1), Transparency = 0, Transparency2 = 1, CFrame = CF(LOC), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	for i = 1, 1 do
		local POS1 = CF(LOC,AIMTO)*CF(0,0,-45).p
		local AIMPOS = CF(LOC,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)))*CF(0,0,MRANDOM(5,75)/10).p
		local HIT,POS = CastProperRay(LOC,AIMPOS,1000,Character)
		local DISTANCE = (POS - LOC).Magnitude
		if HIT then
			local HUM = nil
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent:FindFirstChildOfClass("Humanoid")
			elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent.Parent:FindFirstChildOfClass("Humanoid")
			end
			if HUM then
			Kill3(HIT.Parent)
			end
		end
		
		WACKYEFFECT2({Time = 20, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		WACKYEFFECT2({Time = 20, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.7,0.7,DISTANCE), Transparency = 0.6, Transparency2 = 1, CFrame = CF(LOC,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
end


function Fancy_spawntrail3(LOC,AIMTO,OUCH)
	WACKYEFFECT2({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1.1,1.1,1.1), Transparency = 0, Transparency2 = 1, CFrame = CF(LOC), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	for i = 1, 1 do
		local POS1 = CF(LOC,AIMTO)*CF(0,0,-45).p
		local AIMPOS = CF(LOC,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(-0,0)), RAD(MRANDOM(-0,0)), RAD(MRANDOM(-0,0)))*CF(0,0,MRANDOM(5,75)/10).p
		local HIT,POS = CastProperRay(LOC,AIMPOS,1000,Character)
		local DISTANCE = (POS - LOC).Magnitude
		if HIT then
			local HUM = nil
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent:FindFirstChildOfClass("Humanoid")
			elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent.Parent:FindFirstChildOfClass("Humanoid")
			end
			if HUM then
		Kill2(HUM)
			BEAN(HUM)
			end
		end
		WACKYEFFECT2({Time = 20, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		WACKYEFFECT2({Time = 20, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.7,0.7,DISTANCE), Transparency = 0.6, Transparency2 = 1, CFrame = CF(LOC,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
end


function Fancy_spawntrail2(LOC,AIMTO,OUCH)
	WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(0.3,0.3,0.3), Transparency = 0, Transparency2 = 1, CFrame = CF(LOC), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	for i = 1, 1 do
		local POS1 = CF(LOC,AIMTO)*CF(0,0,-45).p
		local AIMPOS = CF(LOC,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,15)), RAD(MRANDOM(0,15)))*CF(0,0,MRANDOM(5,75)/10).p
		local HIT,POS = CastProperRay(LOC,AIMPOS,1000,Character)
		local DISTANCE = (POS - LOC).Magnitude
		WACKYEFFECT2({Time = 20, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(0.3,0.3,0.3), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT2({Time = 20, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.1,0.1,DISTANCE), Transparency = 0.6, Transparency2 = 1, CFrame = CF(LOC,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, BrickColor.Random(), "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Ball")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(1,DIST,1)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency
		end
		TRAIL:remove()
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function WACKYEFFECT3(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT) 
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Hat" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "173774068", "", SIZE, VT(0,0,0))
		elseif TYPE == "Arm" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2828256740", "", SIZE, VT(0,0,0))
		elseif TYPE == "torso" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "48112070", "", SIZE, VT(0,0,0))
		elseif TYPE == "Head" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "539723444", "", SIZE, VT(0,0,0))
		elseif TYPE == "Mask" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4548197626", "", SIZE, VT(0,0,0))
		elseif TYPE == "Spike" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2720161649", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end


--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT4(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local MIDDLESIZE = (Table.Size2 or VT(0.5,0.5,0.5))
	local ENDSIZE = (Table.Size3 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT) 
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Hat" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "173774068", "", SIZE, VT(0,0,0))
		elseif TYPE == "Arm" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2828256740", "", SIZE, VT(0,0,0))
		elseif TYPE == "torso" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "48112070", "", SIZE, VT(0,0,0))
		elseif TYPE == "Head" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "539723444", "", SIZE, VT(0,0,0))
		elseif TYPE == "Mask" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4548197626", "", SIZE, VT(0,0,0))
		elseif TYPE == "Spike" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2720161649", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE + MIDDLESIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end
local glitch = false
function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,20,0,10)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = (FONTS[MRANDOM(1,#FONTS)])
	Hehe.TextSize = 30
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
				wait()
				if mde == "normal" then
				Hehe.TextColor3 = Color3.fromRGB(255,255,255)
					Hehe.TextStrokeColor3 = C3(0,0,0)
			Hehe.Position = UDim2.new(math.random(-0,0),math.random(-0,0),.1,math.random(-0,0))	
					Hehe.Rotation = 5*COS(SINE/10)
	Hehe.Font = "Highway"
			elseif mde == "Posing" then
	Hehe.Font = (FONTS[MRANDOM(1,#FONTS)])
			Hehe.Position = UDim2.new(math.random(-.3,.3),math.random(-3,3),.1,math.random(-3,3))	
			Hehe.Rotation = math.random(-1,1)
				end			
				end
	end))
	for i = 1,string.len(text),1 do
		wait()
		Hehe.Text = string.sub(text,1,i)
	end
	wait(3)--Re[math.random(1, 93)]
	for i = 0, 5, .035 do
		wait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end




--ParticleEmitter({Speed = 0.5, Drag = 0, Size1 = 0.2, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.7, Parent = Dangle, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})
function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			
		end))
	end
end

function FBanish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			
		end))
	end
end

function Kill2(Foe)
	local TARGET = Mouse.Target
	if Foe then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
				local FOE = Mouse.Target.Parent
				ATTACK = true
				Rooted = true
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(-2,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color=Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(2,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color=Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color=Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,-2,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color=Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,-2,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color=Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 100, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,1,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-5,5),MRANDOM(-5,5),MRANDOM(-5,5)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Plastic", 	Color= Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				FOE.Parent = nil
			end
	end
end

function Kill3(Foe)
	local TARGET = Mouse.Target
	if Foe then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
				local FOE = Mouse.Target.Parent
				ATTACK = true
				Rooted = true
        WACKYEFFECT({Time = 35, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(-2,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color=Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 35, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(2,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color=Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 35, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,0,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color=Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 35, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,-2,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color=Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 35, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,-2,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color=Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

        WACKYEFFECT({Time = 35, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = ROOT.CFrame*CF(0,1,0), MoveToPos = ROOT.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9)).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", 	Color= Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				FOE.Parent = nil
			end
	end
end


workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					instance:ClearAllChildren()

				end))
			end
		end
	end
end)
function StatLabel(CFRAME, TEXT, COLOR)
	local STATPART = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Really black", "Effect", VT())
	STATPART.CFrame = CF(CFRAME.p,CFRAME.p+VT(MRANDOM(-5,5),MRANDOM(0,5),MRANDOM(-5,5)))
	local BODYGYRO = IT("BodyGyro", STATPART)
	game:GetService("Debris"):AddItem(STATPART ,5)
	local BILLBOARDGUI = Instance.new("BillboardGui", STATPART)
	BILLBOARDGUI.Adornee = STATPART
	BILLBOARDGUI.Size = UD2(2.5, 0, 2.5 ,0)
	BILLBOARDGUI.StudsOffset = VT(-2, 2, 0)
	BILLBOARDGUI.AlwaysOnTop = false
	local TEXTLABEL = Instance.new("TextLabel", BILLBOARDGUI)
	TEXTLABEL.BackgroundTransparency = 1
	TEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)
	TEXTLABEL.Text = TEXT
	TEXTLABEL.Font = SKILLFONT
	TEXTLABEL.FontSize="Size42"
	TEXTLABEL.TextColor3 = COLOR
	TEXTLABEL.TextStrokeTransparency = 0
	TEXTLABEL.TextScaled = true
	TEXTLABEL.TextWrapped = true
	coroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)
		for i = 1, 10 do
			Swait()
			STATPART.CFrame = STATPART.CFrame * CF(0,0,-0.2)
			TEXTLABEL.TextTransparency = TEXTLABEL.TextTransparency + (1/10)
			TEXTLABEL.TextStrokeTransparency = TEXTLABEL.TextTransparency
		end
		THEPART.Parent = nil
	end),STATPART, TEXTLABEL)
end
function ApplyDamage2(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		--Humanoid.Health = Humanoid.Health - Damage
	end
end

function ApplyAoE3(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
						--CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function ApplyAoE4(POSITION,RANGE,MINDMG,MAXDMG,FLING,PARTICLE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if PARTICLE == true then
						if HUM.Health < 10 then
						KillChildren3(TORSO.Parent)
						end
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end



function ApplyAoE5(POSITION,RANGE,MINDMG,MAXDMG,FLING,RAGDOLL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if RAGDOLL == true then
						if HUM.Health < 30 then
						Ragdoll(TORSO.Parent,false,false)
						end
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function ApplyAoE6(POSITION,RANGE,MINDMG,MAXDMG,FLING,DKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if DKILL == true then
						if HUM.Health < 30 then
						--HUM.Health = 50
						end
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function ApplyAoE7(POSITION,RANGE,MINDMG,MAXDMG,FLING,RAGDOLL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
			
						if RAGDOLL == true then
							if HUM.Health > 0 then
						CreateSound(4988625180,TORSO,5,1,false)
						--Ragdoll(TORSO.Parent,false,false)
							end
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end


function ApplyAoE8(POSITION,RANGE,MINDMG,MAXDMG,FLING,RAGDOLL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
			
						if RAGDOLL == true then
							if HUM.Health > 0 then
WACKYEFFECT2({Time = 10, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0, CFrame = TORSO.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
								--HUM.Parent:Destroy()
							end
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage2(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									--bv.Parent = c
									--Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function ApplyDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		--Humanoid.Health = Humanoid.Health - Damage
		StatLabel(TorsoPart.CFrame * CF(0, 0 + (TorsoPart.Size.z - 1), 0), Damage, C3(0, 0, 0))
	end
end
local Blk = CreatePart(0,LeftArm,"Neon",1,1,BrickColor.Random(),"aa",VT(0.005,0.005,0.005),false)
local BW = CreateWeldOrSnapOrMotor("Weld",LeftArm,LeftArm,Blk,CF(0,-2,0),CF(0,0,0))



--[[
top=it("Shirt",Character)
top.Name = "Shirt"
bottom=it("Pants",Character)
bottom.Name = "Pants"

if Player.Name ~= "Commandcodes1234" then
for i,x in pairs(Character:GetDescendants()) do if x:IsA("Shirt") or x:IsA("Pants") then x:Destroy() end end

top=it("Shirt",Character)
top.Name = "Shirt"
bottom=it("Pants",Character)
bottom.Name = "Pants"
Character.Shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=0"
Character.Pants.PantsTemplate = "http://www.roblox.com/asset/?id=0"
end
]]


--[[coroutine.resume(coroutine.create(function()
	while wait() do
		end
end))--]]

coroutine.resume(coroutine.create(function()
	while wait() do
		if sick.SoundId == "rbxassetid://2371543268" then
	knife1.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))
	knife2.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))			
		else
	knife1.Color = Color3.fromRGB(0,0,0)
	knife2.Color = Color3.fromRGB(0,0,0)
	
		end
		end
end))



--[[
local hd = script.Headz
hd.Parent = Character
hd.CFrame = Head.CFrame
weldBetween(Head,hd)
local BUCKETWELD = CreateWeldOrSnapOrMotor("Weld", Head, Head, hd, CF(0, 0, 0), CF(0, 0, 0))
BUCKETWELD.C0 = BUCKETWELD.C0 * ANGLES(RAD(-0), RAD(0), RAD(0))


]]
--[[
coroutine.resume(coroutine.create(function()
	while wait() do

	end
end))

]]











local FHead = script.FHead
FHead.Parent = nil
FHead.CFrame = Head.CFrame
weldBetween(Head,FHead)
local GRABWELD2 = CreateWeldOrSnapOrMotor("Weld", Head, Head, FHead, CF(0, 0, 0), CF(0, 0, 0))
GRABWELD2.C0 = GRABWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(0))









local ATTACK2 = false


coroutine.resume(coroutine.create(function()
	while wait() do
for _,c in pairs(Character:GetDescendants()) do
if c.ClassName == "CharacterMesh" then
c:Remove()
end
end
Static.Volume = sick.Volume - 0.6
	end
end))
--glitch
local coolvalue = false
Static = Instance.new("Sound",Torso)
Static.Looped = true
Static.Volume = sick.Volume
Static.SoundId = "rbxassetid://223103466"
Static:Play()
Static:Pause()
--[[  coroutine.resume(coroutine.create(function()
	while wait() do
		if VALUE1 == false and math.random(1,45) == 1 then
			coroutine.resume(coroutine.create(function()
						VALUE1 = true
						for i=1,35 do
						glitch = true
						Static:Resume()
							Swait()
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DatamdelMesh')then
							Rneon.Color = Color3.fromRGB(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255))		
						end
					end		
						end
					VALUE1 = false
					Static:Pause()
					glitch = false
				face = 297839245
							Torso.Material = "Plastic"
							RightArm.Material = "Plastic"
							LeftArm.Material = "Plastic"
							LeftLeg.Material = "Plastic"
							RightLeg.Material = "Plastic"
				Head.Material = "Plastic"
					Rneon.Color = Color3.fromRGB(0,255,0)
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DatamdelMesh')then
							v.Offset = VT(0,0,0)
						end
					end	
			
					end))	
				end	
	end
	end))
--]]


local epic2 = Color3.fromRGB(0,0,0)

function Warp()
		if mde == "Posing" then
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 100, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 100, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
    local HITFLOOR,HITPOS = Raycast(Mouse.Hit.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 100, Character)
    if HITFLOOR then
        HITPOS = HITPOS + VT(0,1,0)
        local POS = RootPart.Position
		        RootPart.CFrame = CF(HITPOS,CF(POS,HITPOS)*CF(0,0,-100000).p)
		if mde == "Posing" then
		CreateSound(2554208392,Torso,10,1,false)
		else
		CreateSound(3848791288,Torso,3,5,false)
		end
		localshakes(0.1,1)
	end
end



local BEANED = {}



local BEANED = {}

function BEAN(skid)	
if skid then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "Arcade"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.fromRGB(0,0,0)
	tecks2.TextStrokeColor3 = Color3.fromRGB(0,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
--CreateSound("395664538", skid, 5, 1, false)
local Players = game:GetService("Players")
local die = Players:FindFirstChild(skid.Name)
--die:Kick()
	if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
	end
		if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
		end
			if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
			end
				if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
				end
					if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
					end
						if Players:FindFirstChild(skid.Name) then
	die:Kick("You were never allowed here in the first place.")
						end
						table.insert(BEANED,skid.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--skid:Remove()
end
end 


local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			--player:Kick() --Ban Reason Change between the '' to change the reason!
		end
	end
end


local RArm = script.RightArm
RArm.Parent = Character
RArm.CFrame = RightArm.CFrame
weldBetween(RightArm,RArm)
local RARMWELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RArm, CF(0, 0, 0), CF(0, 0, 0))
RARMWELD.C0 = RARMWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(0))
knife1 = RArm.Knife1

knife2 = RArm.Knife2

local attnnn = gp(gp(gp(cnnnnn, "White SS", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local handlennn = gp(gp(cnnnnn.Model, "White SS", "Accessory"), "Handle", "BasePart")
attnnn.Parent = knife2
attnnn.Rotation = Vector3.new(45, 0, -0)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if ATTACK == true  then
			GlobalFunctions.fling(handlennn, 0.01)	
		end
	end
end)

knife1.Parent = nil
function template()
	ATTACK = true
	Rooted = true
	for i=0, 0.1, 0.01 / Animation_Speed do
		Swait()
		
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
frozen = false
knifeSpeed = 150
function Throw()
	ATTACK = true
	Rooted = true
	knife1.Parent = RArm
	attnnn.Parent = knife1
	knife2.Parent = nil

	for i=0, 0.1, 0.005 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-40)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(40)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(20), RAD(30))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		if mde == "normal" then
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		else
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)	
		end		
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end

local knife = Instance.new("Part", Character)
knife.Size = Vector3.new(0.6, 0.8, 2.4)
knife.CanCollide = false
knife.Anchored = false
knife:BreakJoints()
knife.CFrame = RightArm.CFrame * CFrame.new(0, -1, 0)
knife.CFrame = CFrame.new(knife.Position, mouse.Hit.p) * CFrame.new(math.random(-10, 10)/100, math.random(-10, 10)/100, math.random(-10, 10)/100)
coroutine.resume(coroutine.create(function()
		for i = 1, 200 do
			Swait()
		if sick.SoundId == "rbxassetid://2371543268" then
	knife.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))
		else
	knife.Color = Color3.fromRGB(0,0,0)	
		end
			end
			
	end))
	attnnn.Parent = knife
local knifeMesh = Instance.new("SpecialMesh", knife)
knifeMesh.MeshId = "rbxassetid://202083123"
	local vel = Instance.new("BodyVelocity", knife)
vel.Velocity = knife.CFrame.lookVector * knifeSpeed
knife.Touched:connect(function(part)
if part.Parent ~= nil then
local TheHit = part.Parent:FindFirstChild("Humanoid")
			if TheHit and TheHit ~= Humanoid and TheHit ~= Character.Model and TheHit ~= Character and TheHit ~= Character.Model.Humanoid then
				attnnn.Parent = handlennn
repeat wait() until not frozen
if TheHit.Health <60 then
Ragdoll(TheHit.Parent,false,false)
elseif TheHit.Health < 101 then
--TheHit:TakeDamage(30, 40)
elseif TheHit.Health > 101 then
WACKYEFFECT2({Time = 100, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TheHit.Parent.Torso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)) or TheHit.Parent.UpperTorso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--TheHit.Parent:Destroy()
end
end
end
end)
coroutine.wrap(function()
vel.Velocity = knife.CFrame.lookVector * knifeSpeed
if (knife.Position - RootPart.Position).magnitude > 500 then
			attnnn.Parent = handlennn
end
	end)
	--attnnn.Parent = handlennn
	knife1.Parent = nil
CreateSound(1306070008,Torso,5,1,false)
	for i=0, 0.1, 0.01 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		if mde == "normal" then
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		else
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)	
		end		
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end
	if mde == "Posing" then
		knife1.Parent = RArm
		attnnn.Parent = knife1
	for i=0, 0.1, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-40)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(40)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end

local knife3 = Instance.new("Part", Character)
knife3.Size = Vector3.new(0.6, 0.8, 2.4)
knife3.CanCollide = false
knife3.Anchored = false
knife3:BreakJoints()
knife3.CFrame = RightArm.CFrame * CFrame.new(0, -1, 0)
knife3.CFrame = CFrame.new(knife3.Position, mouse.Hit.p) * CFrame.new(math.random(-10, 10)/100, math.random(-10, 10)/100, math.random(-10, 10)/100)
coroutine.resume(coroutine.create(function()
		for i = 1, 200 do
			Swait()
		if sick.SoundId == "rbxassetid://2371543268" then
	knife3.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))
		else
	knife3.Color = Color3.fromRGB(0,0,0)	
		end
			end
			
		end))
		attnnn.Parent = knife3
local knife3Mesh = Instance.new("SpecialMesh", knife3)
knife3Mesh.MeshId = "rbxassetid://202083123"
	local vel = Instance.new("BodyVelocity", knife3)
vel.Velocity = knife3.CFrame.lookVector * knifeSpeed
knife3.Touched:connect(function(part)
if part.Parent ~= nil then
local TheHit = part.Parent:FindFirstChild("Humanoid")
				if TheHit and TheHit ~= Humanoid and TheHit ~= Character.Model and TheHit ~= Character and TheHit ~= Character.Model.Humanoid  then
					attnnn.Parent = handlennn
repeat wait() until not frozen
if TheHit.Health <60 then
Ragdoll(TheHit.Parent,false,false)

elseif TheHit.Health < 101 then
--TheHit:TakeDamage(30, 40)
elseif TheHit.Health > 101 then
WACKYEFFECT2({Time = 100, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TheHit.Parent.Torso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)) or TheHit.Parent.UpperTorso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--TheHit.Parent:Destroy()
end
end
end
end)
coroutine.wrap(function()
vel.Velocity = knife.CFrame.lookVector * knifeSpeed
if (knife.Position - RootPart.Position).magnitude > 500 then
				attnnn.Parent = handlennn
end
		end)
		--attnnn.Parent = handlennn
knife1.Parent = nil
CreateSound(1306070008,Torso,5,1,false)
	for i=0, 0.1, 0.01 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
		end
		knife1.Parent = RArm
		attnnn.Parent = knife1
	for i=0, 0.1, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-40)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(40)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end

local knife2 = Instance.new("Part", Character)
knife2.Size = Vector3.new(0.6, 0.8, 2.4)
knife2.CanCollide = false
knife2.Anchored = false
knife2:BreakJoints()
knife2.CFrame = RightArm.CFrame * CFrame.new(0, -1, 0)
knife2.CFrame = CFrame.new(knife2.Position, mouse.Hit.p) * CFrame.new(math.random(-10, 10)/100, math.random(-10, 10)/100, math.random(-10, 10)/100)
coroutine.resume(coroutine.create(function()
		for i = 1, 200 do
			Swait()
		if sick.SoundId == "rbxassetid://2371543268" then
	knife2.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))
		else
	knife2.Color = Color3.fromRGB(0,0,0)	
		end
			end
			
		end))
		attnnn.Parent = knife2
local knife2Mesh = Instance.new("SpecialMesh", knife2)
knife2Mesh.MeshId = "rbxassetid://202083123"
	local vel = Instance.new("BodyVelocity", knife2)
vel.Velocity = knife2.CFrame.lookVector * knifeSpeed
knife2.Touched:connect(function(part)
if part.Parent ~= nil then
local TheHit = part.Parent:FindFirstChild("Humanoid")
				if TheHit and TheHit ~= Humanoid and TheHit ~= Character.Model and TheHit ~= Character and TheHit ~= Character.Model.Humanoid  then
					attnnn.Parent = handlennn
repeat wait() until not frozen
if TheHit.Health <60 then
Ragdoll(TheHit.Parent,false,false)

elseif TheHit.Health < 101 then
--TheHit:TakeDamage(30, 40)
elseif TheHit.Health > 101 then
WACKYEFFECT2({Time = 100, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TheHit.Parent.Torso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)) or TheHit.Parent.UpperTorso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--TheHit.Parent:Destroy()
end
end
end
end)
coroutine.wrap(function()
vel.Velocity = knife.CFrame.lookVector * knifeSpeed
if (knife.Position - RootPart.Position).magnitude > 500 then
				attnnn.Parent = handlennn
end
		end)
		--attnnn.Parent = handlennn
knife1.Parent = nil
CreateSound(1306070008,Torso,5,1,false)
	for i=0, 0.1, 0.01 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
		end
		knife1.Parent = RArm
		attnnn.Parent = knife1
if mde == "Posing" then
	Swait(20)
	knife3:Destroy()	
			knife2:Destroy()
			attnnn.Parent = handlennn
end
	end
	if mde == "Posing" then
		knife1.Parent = RArm
		attnnn.Parent = knife1
		knife2.Parent = nil
	else
		knife2.Parent = RArm
		attnnn.Parent = knife2
		knife1.Parent = nil
	end
	ATTACK = false
	Rooted = false
	Swait(20)
	knife:Destroy()	
	
end

local soda = 0

function wainbowthrow()
	ATTACK = true
	Rooted = true
	knife1.Parent = RArm
	attnnn.Parent = knife1
	knife2.Parent = nil

	for i=0, 0.1, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-40)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(40)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end

local knife = Instance.new("Part", Character)
knife.Size = Vector3.new(0.6, 0.8, 2.4)
knife.CanCollide = false
knife.Anchored = false
knife:BreakJoints()
knife.CFrame = RightArm.CFrame * CFrame.new(0, -1, 0)
knife.CFrame = CFrame.new(knife.Position, mouse.Hit.p) * CFrame.new(math.random(-10, 10)/100, math.random(-10, 10)/100, math.random(-10, 10)/100)
coroutine.resume(coroutine.create(function()
		for i = 1, 200 do
			Swait()
		if sick.SoundId == "rbxassetid://2371543268" then
	knife.Color = Color3.fromRGB(128 + 128 * SIN(SINE / 16), 128 + 128 * SIN(SINE / 32), 128 + 128 * SIN(SINE / 64))
		else
	knife.Color = Color3.fromRGB(0,0,0)	
		end
			end
			
	end))
	attnnn.Parent = knife
local knifeMesh = Instance.new("SpecialMesh", knife)
knifeMesh.MeshId = "rbxassetid://202083123"
	local vel = Instance.new("BodyVelocity", knife)
vel.Velocity = knife.CFrame.lookVector * knifeSpeed
knife.Touched:connect(function(part)
if part.Parent ~= nil then
local TheHit = part.Parent:FindFirstChild("Humanoid")
			if TheHit and TheHit ~= Humanoid and TheHit ~= Character.Model and TheHit ~= Character and TheHit ~= Character.Model.Humanoid  then
repeat wait() until not frozen
if TheHit.Health > 0 then
WACKYEFFECT2({Time = 10, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TheHit.Parent.Torso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)) or TheHit.Parent.UpperTorso.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--TheHit.Parent:Destroy()
end
end
end
	end)
	
	soda = 0
	--attnnn.Parent = handlennn
	knife1.Parent = nil
CreateSound(1306070008,Torso,5,1,false)
	for i=0, 0.1, 0.05 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(20), RAD(30))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end
	Swait(20)
	attnnn.Parent = handlennn
	knife:Destroy()
	knife2.Parent = RArm
	attnnn.Parent = knife2
		knife1.Parent = nil

knife:Destroy()
	ATTACK = false
	Rooted = false
end


local EyeSizes={
	NumberSequenceKeypoint.new(0,1,0),
	NumberSequenceKeypoint.new(1,0,0)
}
local EyeTrans={
	NumberSequenceKeypoint.new(0,0.8,0),
	NumberSequenceKeypoint.new(1,1,0)
}



local PE=Instance.new("ParticleEmitter",nil)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BrickColor.Random().Color)
PE.Size=NumberSequence.new(EyeSizes)
PE.Transparency=NumberSequence.new(EyeTrans)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=1351966707"
PE.ZOffset = -0
PE.Name = "PE"
PE.Enabled = false

coroutine.resume(coroutine.create(function()
	while wait() do
PE.Color = ColorSequence.new(epic2)
	end
end))

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end
function KillChildren2(v)
	--v:BreakJoints()
	
end
function KillChildren(v)
	--v:BreakJoints()
	
end

function KillChildren3(v)
	--v:BreakJoints()
	
end

local WHITELIST = {"Jack_Hase","Godcat567","Powertommm"}
function SmiteAoE(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model then
			local LISTED = false
			for LIST = 1, #WHITELIST do
				if WHITELIST[LIST] ~= nil then
					if CHILD.Name == WHITELIST[LIST] then
						LISTED = true
					end
				end
			end
			if LISTED == false then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE+TORSO.Size.Magnitude then
							KillChildren(CHILD)
						end
					end
				end
			end
		end
	end
end




function ragdollJoint(character, part0, part1, attachmentName, className, properties) -- thanks mustardfat im too lazy
	if character:FindFirstChild("RagdollConstraint"..part1.Name) == nil then
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("MeshPart") and (v.MeshId == 'http://www.roblox.com/asset/?id=553602991' or v.MeshId == 'http://www.roblox.com/asset/?id=553602977' or v.MeshId == 'http://www.roblox.com/asset/?id=553602987') then
			v.Size = Vector3.new(1,1,1)
		end
	end
	if part1:FindFirstChildOfClass('Motor6D') then
		part1:FindFirstChildOfClass('Motor6D'):Remove()
	end
	if attachmentName ~= "NeckAttachment" then
		attachmentName = attachmentName.."RigAttachment"
	end
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name
	if character:FindFirstChildOfClass('Humanoid').Health > 0 then
	local collidepart = Instance.new('Part',part1)
	collidepart.Size = part1.Size/2
	if string.find(string.lower(part1.Name),"upper") then
		if string.find(string.lower(part1.Name),"leg") then
			collidepart.Size = part1.Size/3
		else
			collidepart.Size = part1.Size/2.5
		end
	end
	collidepart.CanCollide = true
	collidepart.Name = "RagdollJoint"
	collidepart.Anchored = false
	collidepart.Transparency = 1
	collidepart.CFrame = part1.CFrame
	collidepart:BreakJoints()
	local attachment0 = Instance.new('Attachment',part1)
	local attachment1 = Instance.new('Attachment',collidepart)
	if attachment0 and attachment1 then
		local constraint = Instance.new("HingeConstraint")
		constraint.Attachment0 = attachment0
		constraint.Attachment1 = attachment1
		constraint.LimitsEnabled = true
		constraint.UpperAngle = 0
		constraint.LowerAngle = 0
		constraint.Parent = character
	end
	if string.find(string.lower(part1.Name),"upper") then
		if string.find(string.lower(part1.Name),"leg") then
			attachment0.Position = Vector3.new(0,0.01,0)
		else
			attachment0.Position = Vector3.new(0,0.25,0)
		end
	else
		attachment0.Position = Vector3.new(0,-0.1,0)
	end
	end
	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end
	constraint.Parent = character
	return constraint
	end
end

local V3 = {N=Vector3.new,FNI=Vector3.FromnormalId,A=Vector3.FromAxis}

function getAttachment0(character,attachmentName)
	for _,child in next,character:children() do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment
		end
	end
end

function recurse(root,callback,i)
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)
		
		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end
	
	return i
end

local Stunned = {}

function GetTorso(Character)
	return Character:FindFirstChild'Torso' or Character:FindFirstChild'UpperTorso'
end

function FakeWeld(p0,p1)
	local attachment0 = Instance.new('Attachment',p0)
	local attachment1 = Instance.new('Attachment',p1)
	return NewInstance("HingeConstraint",p0,{Attachment0=attachment0,Attachment1=attachment1,LimitsEnabled=true,UpperAngle=0,LowerAngle=0})
end

function Ragdoll(who,half,snapped)
	
end


function KickA()
	local TARGET = Mouse.Target
	if TARGET ~= nil then
	local HITFLOOR, HITPOS = Raycast(RightLeg.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 2 , Character)
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			local TORSO = TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")		
				local FOE = Mouse.Target.Parent
				ATTACK = true
				Rooted = true
	FOE.Parent = nil
WACKYEFFECT2({Time = 100, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TORSO.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

				BEAN(FOE)
				ATTACK = false
				Rooted = false
			end
		end
	end
function KillB()
	local TARGET = Mouse.Target
	if TARGET ~= nil then
	local HITFLOOR, HITPOS = Raycast(RightLeg.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 2 , Character)
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			local TORSO = TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			
			local FOE = Mouse.Target.Parent
				ATTACK = true
			Rooted = true
	FOE.Parent = nil
WACKYEFFECT2({Time = 100, EffectType = "Sphere", Size = VT(20,20,20), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = TORSO.CFrame*CF(0,0,0)*CFrame.Angles(math.rad(0),math.rad(math.random(-360,360)),math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(150,0,150), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

				ATTACK = false
				Rooted = false
			end
		end
end






hitbox = RArm.Hitbox
function Stab()
	ATTACK = true
	Rooted = false
knife1.Parent = nil
	knife2.Parent = RArm
	attnnn.Parent = knife2

	for i=0, 0.1, 0.01 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-50)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(50)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
CreateSound(1306070008,hitbox,5,1,false)
knife1.Parent = RArm
	local xa = hitbox
	attnnn.Parent = knife1
	knife2.Parent = nil
	for i=0, 0.1, 0.02 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(80)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end
ApplyAoE7(xa.Position,4,50,100,0,true)
	ATTACK = false
	Rooted = false
	knife2.Parent = RArm
	attnnn.Parent = knife2
	knife1.Parent = nil
end



function Rapidstab()
	ATTACK = true
	Rooted = false
knife1.Parent = nil
	knife2.Parent = RArm
	attnnn.Parent = knife2
	if mde == "Posing" then
	RightLeg.Transparency = 0
	LeftArm.Transparency = 0
	RightArm.Transparency = 0
	LeftLeg.Transparency = 0
	Head.Transparency = 0
	Torso.Transparency = 0
		FHead.Parent = Character
	end
	for i=0, 0.1, 0.03 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-50)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(50)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(10))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end
CreateSound(1306070008,hitbox,5,1,false)
	knife1.Parent = RArm
	attnnn.Parent = knife1
local xa = hitbox
	knife2.Parent = nil
	
	for i=0, 0.1, 0.03 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(80)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	end
		if coolvalue == true then
		ApplyAoE7(xa.Position,4,50,100,0,true)
		elseif coolvalue == false then
		ApplyAoE8(xa.Position,4,50,100,0,true)
		end
	knife1.Parent = RArm
	attnnn.Parent = knife1
	knife2.Parent = nil
	ATTACK = false
	Rooted = false
end


function wainbowstab()
	ATTACK = true
	Rooted = false
knife1.Parent = nil
	knife2.Parent = RArm
	attnnn.Parent = knife2
for i = 1, 10 do
Swait()
	for i=0, 0.1, 1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(-50)), 3 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(50)), 3 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(10))* RIGHTSHOULDERC0, 3 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 3 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 3 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 3 / Animation_Speed)
	end
	    WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
CreateSound(1306070008,hitbox,5,3,false)
		knife1.Parent = RArm
		attnnn.Parent = knife1
local xa = hitbox
	knife2.Parent = nil
	for i=0, 0.1, 1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(0), RAD(0), RAD(80)), 3 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-80)), 3 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(80))* RIGHTSHOULDERC0, 3 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 3 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(-5), RAD(5)) * ANGLES(RAD(0), RAD(90), RAD(0)), 3 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(0), RAD(5), RAD(-5)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 3 / Animation_Speed)
	end
	    WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		if coolvalue == true then
		ApplyAoE7(xa.Position,4,50,100,0,true)
		elseif coolvalue == false then
		ApplyAoE8(xa.Position,4,50,100,0,true)
		end
		knife1.Parent = RArm
		attnnn.Parent = knife1
		knife2.Parent = nil
end
knife1.Parent = nil
	knife2.Parent = RArm
	attnnn.Parent = knife2
	ATTACK = false
	Rooted = false
end


function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Color3.new(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BrickColor.new("Pearl"), "Effect", Vector3.new(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, Vector3.new(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", Vector3.new(SIZE.X,SIZE.X,0.1), Vector3.new(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", Vector3.new(SIZE.X/10,0,SIZE.X/10), Vector3.new(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", Vector3.new(SIZE.X/10,0,SIZE.X/10), Vector3.new(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, Vector3.new(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, Vector3.new(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, Vector3.new(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end



function Lightning(Part0, Part1, Times, Offset, Color, Timer, sSize, eSize, Trans, Boomer, sBoomer, slow, stime)
  local magz = (Part0 - Part1).magnitude
  local curpos = Part0
  local trz = {
    -Offset,
    Offset
  }
  for i = 1, Times do
    local li = Instance.new("Part", Effects)
    li.Name = "Lightning"
    li.TopSurface = 0
    li.Material = "Neon"
    li.BottomSurface = 0
    li.Anchored = true
    li.Locked = true
    li.Transparency = 0
    li.BrickColor = Color
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(0.1, 0.1, magz / Times)
    local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
    local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
    if Times == i then
      local magz2 = (curpos - Part1).magnitude
      li.Size = Vector3.new(0.1, 0.1, magz2)
      li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
    else
      li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
    end
    curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
    li:Destroy()
	Effect({Time = Timer, EffectType = "Box", Size = Vector3.new(sSize,sSize,li.Size.Z), Size2 = Vector3.new(eSize,eSize,li.Size.Z), Transparency = Trans, Transparency2 = 1, CFrame = li.CFrame, MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = li.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = Boomer, Boomerang = 0, SizeBoomerang = sBoomer})
  	if slow == true then
	swait(stime)
	end
  end
end

--[[
--refit by godcat
local Regen = {}
delay(1,function()
	local Descendants = Character:GetDescendants()
	
	for i = 1,#Descendants do
		local E = Descendants[i]
		if E:IsA("BasePart") and not E:IsDescendantOf(Effects) then
			E.CustomPhysicalProperties = PhysicalProperties.new(Enum.Material.Wood)
			table.insert(Regen,{E,E.Parent,E.Color,E.Size,E.Material})
		end
		if E:IsA("JointInstance") then
			table.insert(Regen,{E,E.Parent,nil,nil,nil})
		end
	end
end)

for e = 1, #Regen do
	if Regen[e] ~= nil then
		local STUFF = Regen[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= Body.RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function Refit()
	for i = 1,#Regen do
		local E = Regen[i]
		local PART = E[1]
		local PARENT = E[2]
		local COLOR = E[3]
		local SIZE = E[4]
		local MATERIAL = E[5]
		
		if PART:IsA("BasePart") and PART.Parent ~= PARENT then
			PART.Color = COLOR
			PART.Size = SIZE
			PART.Material = MATERIAL
		end
		if PART.Parent ~= PARENT then
			Humanoid.Parent = nil
			PART.Parent = PARENT
			Humanoid.Parent = Character
		end
	end
	Humanoid.Parent = Character
end

local BODY = {}

for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function Refit2()
	Character.Parent = workspace
	Effects.Parent = Character
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			--local SIZE = STUFF[6]
			local NAME = STUFF[7]
			if PART.ClassName == "Part" and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Transparency = TRANSPARENCY
				PART.Name = NAME
			end
			if PART.Parent ~= PARENT then
				if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
					Humanoid:remove()
				end
				PART.Parent = PARENT
				if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
					Humanoid = IT("Humanoid",Character)
				end
			end
		end
	end
end


Humanoid.Died:Connect(Refit)
Humanoid.HealthChanged:Connect(function()
	if Humanoid.Health <= 1 then
		Humanoid.Health = math.huge
		Refit()
	end
end)--]]

local partus = Color3.fromRGB(250,0,250)



wait(0.2)
	if Head:FindFirstChild("face") then
LastFace = Head.face.Texture
	end
lastColor = Head.Color
lastpitch = 1
local ATTACK1 = false
local ATTACK2 = false
function Pose()
	ATTACK = true
	Rooted = true
	if mde == "normal" then
		mde = "Posing"
		knifeSpeed = 200
		frozen = false
		knife1.Parent = RArm
		attnnn.Parent = knife1
		knife2.Parent = nil
		FHead.Parent = Character
	Head.Color = Color3.fromRGB(0,0,0)
	thetime = sick.TimePosition
		ATTACK1 = true
	sick.Pitch = 1
	if Head:FindFirstChild("face") then
	Head.face.Texture = "rbxassetid://0"
	end
	sick.SoundId = "rbxassetid://5070716413"
	sick.TimePosition = 0
	elseif mde == "Posing" then
		mde = "infinite"
	if Head:FindFirstChild("face") then
Head.face.Texture = LastFace
		end
	ATTACK2 = true
		frozen = false
		knife2.Parent = RArm
		attnnn.Parent = knife2
		knife1.Parent = nil
		knifeSpeed = 250
	Head.Color = lastColor
	sick.Pitch = 1

FHead.Parent = nil
		sick.TimePosition = 0
		ATTACK1 = false
		sick.SoundId = "rbxassetid://2371543268"
	elseif mde == "infinite" then
		mde = "normal"

	ATTACK2 = false
		frozen = false
		knife2.Parent = RArm
		attnnn.Parent = knife2
		knife1.Parent = nil
		knifeSpeed = 150
	sick.Pitch = lastpitch

		sick.TimePosition = thetime
	sick.SoundId = LastId
	end
	Rooted = false
	ATTACK = false
end


function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end
function KeyDown(Key)
	KEYHOLD = true
	if Key == "q" and ATTACK == false  then
	Warp()
	end
	if Key == "f" and ATTACK == false then
		if mde == "infinite" then
		wainbowthrow()
		else
	Throw()
	end
end
	if Key == "g" and ATTACK == false then
	Pose()
	end
	if Key == "c" and ATTACK == false  then
		if mde == "Posing" then
	Rapidstab()
		elseif mde == "infinite" then
	wainbowstab()
	else
	Stab()
	end
end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

if Character:FindFirstChildOfClass("Humanoid") == nil then
	Humanoid = Instance.new("Humanoid",Character)
end

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end

	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then

			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
	    end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then


			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(20))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
				if mde == "normal" then
				Speed = 25
				Humanoid.JumpPower = 50
				local pl = GetClientProperty(sick,'PlaybackLoudness')
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0+0.1*COS(SINE/13)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0-2 *SIN(SINE/13)), RAD(0), RAD(20)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+0.05*SIN(SINE/13), -0.2) * ANGLES(RAD(60+5*SIN(SINE/13)), RAD(0), RAD(-20))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5+0.05*SIN(SINE/13), 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-0.1*COS(SINE/13), 0) * ANGLES(RAD(0), RAD(-5), RAD(2)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-0.1*COS(SINE/13) , 0) * ANGLES(RAD(0), RAD(5), RAD(-2)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
				elseif mde == "Posing" then
				Speed = 100
				Humanoid.JumpPower = 100

				local pl = GetClientProperty(sick,'PlaybackLoudness')	
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , -0.05) * ANGLES(RAD(10), RAD(12), RAD(230)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(50)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.3, 0.3, -0.8) * ANGLES(RAD(150), RAD(-10), RAD(-50))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.5, 0, -0.5) * ANGLES(RAD(70), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-15), RAD(-3), RAD(2)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(-15), RAD(3), RAD(-2)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
			elseif mde == "infinite" then
				Speed = 100
				Humanoid.JumpPower = 100
				local pl = GetClientProperty(sick,'PlaybackLoudness')
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0+0.3*COS(SINE/2)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0-25 *SIN(SINE/2)), RAD(0), RAD(20)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+0.2*SIN(SINE/2), -0.2) * ANGLES(RAD(60+25*SIN(SINE/2)), RAD(0), RAD(-20))* RIGHTSHOULDERC0, 1 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5+0.2*SIN(SINE/2), 0.8) * ANGLES(RAD(-20), RAD(0), RAD(30)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-0.3*COS(SINE/2), 0) * ANGLES(RAD(0), RAD(-5), RAD(2)) * ANGLES(RAD(0), RAD(90), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-0.3*COS(SINE/2) , 0) * ANGLES(RAD(0), RAD(5), RAD(-2)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 1 / Animation_Speed)
	
		end		
		end	
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
				local Testwalk1 = Humanoid.MoveDirection*Torso.CFrame.LookVector
	            local Testwalk2 = Humanoid.MoveDirection*Torso.CFrame.RightVector
	            LOOKVEC = Testwalk1.X+Testwalk1.Z
			    RIGHTVEC = Testwalk2.X+Testwalk2.Z
			VALUE3 = false
			if mde == "normal" then
				Speed = 25
			local value1 = 3
			local value2 = 6
			local value3 = 90
			local value4 = 40
			local value5 = 20
				Humanoid.JumpPower = 50

			local pl = GetClientProperty(sick,'PlaybackLoudness')
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0 , -0.185 + 0.055 * COS(SINE / value1) + -SIN(SINE / value1) / 8) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value5), RAD((-RIGHTVEC - -RIGHTVEC/5  * COS(SINE / value1))*value5) , RAD(0)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*-value5), RAD(0), RAD((RIGHTVEC - -RIGHTVEC/5  * COS(SINE /value1))*-value5)), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1+ 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((-RIGHTVEC + RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(90),RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(-90),RAD(0)), 0.35 / Animation_Speed)				
			elseif mde == "Posing" then
			local value1 = 1
			local value2 = 2
			local value3 = 150
			local value4 = 80
			local value5 = 30
				Speed = 100
				Humanoid.JumpPower = 100
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0 , -0.185 + 0.055 * COS(SINE / value1) + -SIN(SINE / value1) / 8) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value5), RAD((-RIGHTVEC - -RIGHTVEC/5  * COS(SINE / value1))*value5) , RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*-value5), RAD(0), RAD((RIGHTVEC - -RIGHTVEC/5  * COS(SINE /value1))*-value5)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5))* RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1+ 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((-RIGHTVEC + RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(90),RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(-90),RAD(0)), 0.5 / Animation_Speed)				
	       WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=epic2, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			elseif mde == "infinite" then
			local value1 = 1
			local value2 = 2
			local value3 = 150
			local value4 = 80
			local value5 = 30
				Speed = 100
				Humanoid.JumpPower = 100
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0 , -0.185 + 0.055 * COS(SINE / value1) + -SIN(SINE / value1) / 8) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value5), RAD((-RIGHTVEC - -RIGHTVEC/5  * COS(SINE / value1))*value5) , RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*-value5), RAD(0), RAD((RIGHTVEC - -RIGHTVEC/5  * COS(SINE /value1))*-value5)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5))* RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE /value2)), RAD(0), RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE /value2))*value5)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1+ 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((-LOOKVEC  + LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((-RIGHTVEC + RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(90),RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * SIN(SINE / value2), 0)* ANGLES(RAD((LOOKVEC  - LOOKVEC/5  * COS(SINE / value1))*value3* COS(SINE / value2)),RAD(0),RAD((RIGHTVEC - RIGHTVEC/5  * COS(SINE / value2))*value4*COS(SINE/value2)))*ANGLES(RAD(0),RAD(-90),RAD(0)), 0.5 / Animation_Speed)				
	       WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
        WACKYEFFECT({Time = 10, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color=knife1.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			end	
		end
	end
Player.Chatted:connect(function(message)
if message:sub(1,5) == "play/" and ATTACK1 == false and ATTACK2 == false then
sick.SoundId = "rbxassetid://"..message:sub(6)
LastId = "rbxassetid://"..message:sub(6)
elseif message:sub(1,6) == "pitch/"and ATTACK1 == false  then
			sick.PlaybackSpeed = message:sub(7)
lastpitch = message:sub(7)
elseif message:sub(1,4) == "vol/" and ATTACK1 == false then
sick.Volume = message:sub(5) 
elseif message:sub(1,5) == "skip/" and ATTACK1 == false then
sick.TimePosition = message:sub(6)
elseif message:sub(1,4) == "t/on" and ATTACK1 == false then
coolvalue = true
elseif message:sub(1,7) == "t/off" and ATTACK1 == false then
			coolvalue = false
end
end)

	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
end

-------------------------------------------------




end)

local Tab = Window:NewTab("Free Scripts")
local Section = Tab:NewSection("Free Scripts *melon is still a pedo*")

Section:NewButton("Glitcher", "ButtonInfo", function()
    print("Clicked")


if not game:IsLoaded() then
	local notLoaded = Instance.new("Message",workspace)
	notLoaded.Text = 'SWORDS FE STAR IS WAITING FOR THE GAME TO LOAD'
	game.Loaded:Wait()
	notLoaded:Destroy()
end




setfflag("AbuseReportScreenshotPercentage", 0)

setfflag("DFFlagAbuseReportScreenshot", "False")

setfflag("AbuseReportScreenshot", "False")

setfflag("CrashPadUploadToBacktraceToBacktraceBaseUrl", "")

setfflag("CrashUploadToBacktracePercentage", "0")

setfflag("CrashUploadToBacktraceBlackholeToken", "")

setfflag("CrashUploadToBacktraceWindowsPlayerToken", "")

local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil




Player = game:GetService("Players").LocalPlayer
        Cam = workspace.CurrentCamera
        Character = game.Players.LocalPlayer.Character
        Head = Character.Head
        Cam.CameraSubject = Head
	local data = {}

	local script = game:GetObjects("rbxassetid://5446036971")[1]

	script.WingPiece.qPerfectionWeld:Destroy()
    GlobalFunctions = {}
    loadstring(game:HttpGet(('https://pastebin.com/raw/0n3Du5SM'),true))()
    loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
    local cnnnnn = game.Players.LocalPlayer.Character
    local function gp(parent, name, className)
        local ret = nil
        if parent then
            for i, v in pairs(parent:GetChildren()) do
                if (v.Name == name) and v:IsA(className) then
                    ret = v
                end
            end
        end
        return ret
    end
	do
		local NEVER_BREAK_JOINTS = false

		local function CallOnChildren(Instance, FunctionToCall)
			FunctionToCall(Instance)

			for _, Child in next, Instance:GetChildren() do
				CallOnChildren(Child, FunctionToCall)
			end
		end

		local function GetBricks(StartInstance)
			local List = {}
			CallOnChildren(StartInstance, function(Item)
				if Item:IsA("BasePart") then
					List[#List+1] = Item;
				end
			end)

			return List
		end

		local function Modify(Instance, Values)
			assert(type(Values) == "table", "Values is not a table");

			for Index, Value in next, Values do
				if type(Index) == "number" then
					Value.Parent = Instance
				else
					Instance[Index] = Value
				end
			end
			return Instance
		end

		local function Make(ClassType, Properties)
			return Modify(Instance.new(ClassType), Properties)
		end

		local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
		local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

		local function HasWheelJoint(Part)
			for _, SurfaceName in pairs(Surfaces) do
				for _, HingSurfaceName in pairs(HingSurfaces) do
					if Part[SurfaceName].Name == HingSurfaceName then
						return true
					end
				end
			end

			return false
		end

		local function ShouldBreakJoints(Part)
			if NEVER_BREAK_JOINTS then
				return false
			end

			if HasWheelJoint(Part) then
				return false
			end

			local Connected = Part:GetConnectedParts()

			if #Connected == 1 then
				return false
			end

			for _, Item in pairs(Connected) do
				if HasWheelJoint(Item) then
					return false
				elseif not Item:IsDescendantOf(script.Parent) then
					return false
				end
			end

			return true
		end

		local function WeldTogether(Part0, Part1, JointType, WeldParent)

			JointType = JointType or "Weld"
			local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

			local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
			Modify(NewWeld, {
				Name = "qCFrameWeldThingy";
				Part0  = Part0;
				Part1  = Part1;
				C0     = CFrame.new();--Part0.CFrame:inverse();
				C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
				Parent = Part1;
			})

			if not RelativeValue then
				RelativeValue = Make("CFrameValue", {
					Parent     = Part1;
					Name       = "qRelativeCFrameWeldValue";
					Archivable = true;
					Value      = NewWeld.C1;
				})
			end

			return NewWeld
		end

		local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)

			for _, Part in pairs(Parts) do
				if ShouldBreakJoints(Part) then
					Part:BreakJoints()
				end
			end

			for _, Part in pairs(Parts) do
				if Part ~= MainPart then
					WeldTogether(MainPart, Part, JointType, MainPart)
				end
			end

			if not DoNotUnanchor then
				for _, Part in pairs(Parts) do
					Part.Anchored = false
				end
				MainPart.Anchored = false
			end
		end

		local function PerfectionWeld()	
			local Parts = GetBricks(script.WingPiece)
			WeldParts(Parts, script.WingPiece.Main, "Weld", false)
		end
		PerfectionWeld()
	end

	--// Shortcut Variables \\--
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players
	local UIS = S.UserInputService

	local Player = game.Players.LocalPlayer
	data.User = Player
	data.Local = Player
	local Char = Player.Character
	local Mouse = Player:GetMouse()
	local Hum = Char:FindFirstChildOfClass'Humanoid'
	local Torso = Char.Torso
	local RArm = Char["Right Arm"]
	local LArm = Char["Left Arm"]
	local RLeg = Char["Right Leg"]
	local LLeg = Char["Left Leg"]	
	local Root = Char:FindFirstChild'HumanoidRootPart'
	local Head = Char.Head
	local Sine = 0;
	local Change = 1
	local Attack=false
	local NeutralAnims=true
	local timePos=30;
	local walking=true;
	local legAnims=true;
	local movement = 8
	local footsound=0;
	local WalkSpeed=16;
	local Combo=0;
	local Mode='POWER'
	local vaporwaveMode=false;
	local WingAnim='NebG1'
	local music;
	local hue = 0;
	local WingSine=0;
	local MusicMode=1;
	local visSong = 1702473314;
	local EffectFolder = script:WaitForChild'FXFolder'
	local PrimaryColor = Color3.new(1,1,1)
	local ClickTimer = 0;
	local ClickAttack = 1;
	local camera = workspace.CurrentCamera
	local LastSphere = time();
	local Frame_Speed = 60
	local VaporwaveSongs={
		2231500330;
		654094806;
		743334292;
		334283059;
		2082142910;
	}
    pcall(game.Destroy,Player.Character:FindFirstChild'Animate')
    pcall(game.Destroy,Hum:FindFirstChild'Animator')

	local WingPiece = script:WaitForChild'WingPiece'
	WingPiece.Parent=nil
	local WingAnims={}
	local Playlist={
		Default=1702473314;
		ScrapBoy=1215691669;
		Defeated=860594509;
		Annihilate=2116461106;
		DashAndDodge=2699922745;
		ZenWavy=2231500330;
		Beachwalk=334283059;
		Pyrowalk=2082142910;
		Vapor90s=654094806;
	}

--[[
Achromatic - The Big Black - Lost Soul
Iniquitous
Mythical - Legendary
Ruined - Th1rt3en
Atramentous - Vanta Black
Subzero - Frostbite
Troubadour
Infectious - Radioactive
Love - Lust
]]

	--2699922745
	local modeInfo={
		{Name="POWER",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(150, 150, 0);Music=1504604335,LeftWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='NebG1'};
		{Name="WORMHOLE",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(150, 150, 0);Music=1842621252,LeftWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Lilac'.Color,Enum.Material.Neon};WingAnim='Worm'};
		{Name="PULSAR",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(0, 0, 255);Music=1842621252,LeftWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.Neon};WingAnim='PULSE'};
		{Name="FORCE",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(0, 0, 255);Music=511836626,LeftWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.Neon};WingAnim='FORCE'};
		{Name="HYBRID",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 0, 0);Music=1842621252,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='Things'};
		{Name="APCOCLYPTIC",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(150, 0, 0);Music=1282491661,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='HAHAHA1'};
		{Name="GENOCIDE",Walkspeed=60,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.N(255, 0, 0);Music=4736655124,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Maroon'.Color,Enum.Material.Neon};WingAnim='GENOCIDE'};
		{Name="BURNING BRAIN",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 0, 0);Music=833779944,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='ZENITH'};
		{Name="PESTILENCE",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(0, 0, 0);Music=4177790309,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PEST1'};
	    {Name="ACE-OF-SPADES",Walkspeed=66,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 238, 0);Music=1446376775,LeftWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='PROESTGAMER'};
		{Name="PUNISHED",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 0, 0);Music=1074484884,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='PUNISHED'};
		{Name="PURGED",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 0, 0);Music=1074484884,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='PUNISHED'};
	    {Name="???",Walkspeed=60,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(150, 150, 0);Music=234242423,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='Question'};
		{Name="R E M E M B E R E D",Walkspeed=16,moveVal=10,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(255, 255, 255);Music=614032233,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};WingAnim='REMEMBER'};
		{Name="Splits",Walkspeed=16,moveVal=10,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(0, 38, 255);Music=614032233,LeftWing={0,BrickColor.new'Really blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='NebG2'};
		{Name="GREATSWORD",Walkspeed=16,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 255, 255);Music=614032233,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='GSWORD'};
		{Name="TIME WARP",Walkspeed=66,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 140, 0);Music=348832364,LeftWing={0,BrickColor.new'Flame reddish orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};WingAnim='PERSON'};
		{Name="Nefarious",Walkspeed=16,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(255, 0, 0);Music=6614038981,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Bright red'.Color,Enum.Material.Neon};WingAnim='Star7'};
		{Name="ECHO",Walkspeed=16,moveVal=8,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(0, 0, 0);Music=573736432,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Echo1'};
		{Name="",Walkspeed=16,moveVal=8,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(0, 0, 0);Music=573736432,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Echo2'};
		{Name="Liar X",Walkspeed=16,moveVal=10,Font=Enum.Font.Fantasy,StrokeColor=C3.N(235, 0, 0);Music=1751171913,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='LIES'};
		{Name="EXCALIBUR",Walkspeed=40,moveVal=10,Font=Enum.Font.Fantasy,StrokeColor=C3.N(0, 0, 0);Music=1751171913,LeftWing={0,BrickColor.new'Gold'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='Sword1'};
		{Name="Deleterious",Walkspeed=40,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(100, 0, 0);Music=573736432,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='DELETE'};
		{Name="EXCALIBUR X",Walkspeed=40,moveVal=10,Font=Enum.Font.Fantasy,StrokeColor=C3.N(0, 0, 0);Music=1751171913,LeftWing={0,BrickColor.new'Gold'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='Sword1'};
		{Name="YING-YANG",Walkspeed=16,moveVal=10,Font=Enum.Font.Fantasy,StrokeColor=C3.N(0, 0, 0);Music=1842859173,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Atoms'};
		{Name="Atomic Collisions",Walkspeed=66,moveVal=10,Font=Enum.Font.Fantasy,StrokeColor=C3.N(0, 0, 0);Music=1837612618,LeftWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Camo'.Color,Enum.Material.Neon};WingAnim='Atomic'};
		{Name="FUTURE",Walkspeed=16,moveVal=10,Font=Enum.Font.SourceSansItalic,StrokeColor=C3.N(0, 0, 0);Music=3405566511,LeftWing={0,BrickColor.new'Lilac'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};WingAnim='Future'};
		{Name="SYSTEM_32",Walkspeed=16,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.N(100, 0, 0);Music=3405566511,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='SYS32'};
		{Name="Overclocked",Walkspeed=200,moveVal=30,Font=Enum.Font.Arcade,StrokeColor=C3.N(255, 140, 0);Music=1138145518,LeftWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Tr. Red'.Color,Enum.Material.Neon};WingAnim='NebG3'};
		{Name="S P A C E T I M E",Walkspeed=150,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.N(0, 0, 255);Music=4597078271,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really blue'.Color,Enum.Material.Neon};WingAnim='SPACETIME'};
		{Name="INEVITABLE",Walkspeed=16,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.N(255, 255, 255);Music=6215034956,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='isgonnahappensoon'};
		{Name="ERROR_404",Walkspeed=16,moveVal=10,Font=Enum.Font.Code,StrokeColor=C3.N(255, 0, 0);Music=2954216473,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Doom'};
	    {Name="CRAZED",Walkspeed=200,moveVal=10,Font=Enum.Font.Code,StrokeColor=C3.N(0, 0, 0);Music=719008519,LeftWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='KRAZY'};
		{Name="MURDEROUS",Walkspeed=10,moveVal=5,Font=Enum.Font.Antique,StrokeColor=C3.N(155, 0, 0);Music=5926497202,LeftWing={0,BrickColor.new'Maroon'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Dead'};
		{Name="Lightning Cannon",Walkspeed=99,moveVal=5,Font=Enum.Font.Antique,StrokeColor=C3.N(255, 255, 255);Music=5485798026,LeftWing={0,BrickColor.new'Maroon'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='LC1'};
		{Name="INFINITE",Walkspeed=66,moveVal=5,Font=Enum.Font.Bodoni,StrokeColor=C3.N(155, 0, 0);Music=5926497202,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};WingAnim='Liquid'};
		{Name="SINGULARITY",Walkspeed=66,moveVal=5,Font=Enum.Font.Bodoni,StrokeColor=C3.N(0, 0, 0);Music=1838627204,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='BLACKHOLE'};
		{Name="DESTROYED",Walkspeed=250,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.N(0,0,0);Music=1837797865,LeftWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Bruh'};
		{Name="god slayer",Walkspeed=16,moveVal=6,Font=Enum.Font.Antique,StrokeColor=C3.N(0,0,0);Music=2116461106,LeftWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Flame reddish orange'.Color,Enum.Material.Neon};WingAnim='Star1'};
		{Name="Radioactivity",Walkspeed=100,moveVal=15,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(0,0,0);Music=4920807873,LeftWing={0,BrickColor.new'Camo'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Lime green'.Color,Enum.Material.Neon};WingAnim='Star2'};
		{Name="Fearless",Walkspeed=50,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.N(255,0,0);Music=5548894866,LeftWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Star3'};
		{Name="L0st",Walkspeed=17,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.2,.2,.2);Music=143367704,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Granite};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Grass};WingAnim='Lost'};
		{Name="Destiny",Walkspeed=40,moveVal=10,Font=Enum.Font.SourceSansLight,StrokeColor=C3.N(.2,.2,.2);Music=2071274388,LeftWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Destiny'};
		{Name="Calamity",Walkspeed=40,moveVal=10,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(.2,.2,.2);Music=3221578654,LeftWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};WingAnim='Calam'};
		{Name="SPEED OF LIGHT",Walkspeed=1000,moveVal=10,Font=Enum.Font.SourceSansBold,StrokeColor=C3.N(.2,.2,.2);Music=3221578654,LeftWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};WingAnim='LIGHTSPEED'};
		{Name="Catastrophe",Walkspeed=40,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.N(.2,.2,.2);Music=4554066200,LeftWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Cata'};
		{Name="Cataclysm",Walkspeed=50,moveVal=13,Font=Enum.Font.Garamond,StrokeColor=C3.N(.2,.2,.2);Music=143367704,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Cataclysm'};
		{Name="PLATFORM",Walkspeed=50,moveVal=13,Font=Enum.Font.Bodoni,StrokeColor=C3.N(140,140,140);Music=1256962511,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PLATFORM'};
		{Name="Mythical",Walkspeed=40,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.N(.2,.2,.2);Music=1301290348,LeftWing={0,BrickColor.new'Lilac'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pastel light blue'.Color,Enum.Material.Neon};WingAnim='Mythic'};
		{Name="80s",Walkspeed=16,moveVal=5,Font=Enum.Font.Jura,StrokeColor=C3.N(.2,.2,.2);Music=1217805820,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='GEO'};
		{Name="THE VOID",Walkspeed=16,moveVal=5,Font=Enum.Font.Jura,StrokeColor=C3.N(.2,.2,.2);Music=1836762394,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='VOID'};
		{Name="90s",Walkspeed=66,moveVal=2,Font=Enum.Font.SourceSansItalic,StrokeColor=C3.N(.2,.2,.2);Music=1169573062,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='Solaris'};
		{Name="Inferno",Walkspeed=190,moveVal=5,Font=Enum.Font.Fantasy,StrokeColor=C3.N(.2,.2,.2);Music=1609011649,LeftWing={0,BrickColor.new'Neon orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Flame reddish orange'.Color,Enum.Material.Neon};WingAnim='bot2'};
		{Name="Volcanic",Walkspeed=190,moveVal=5,Font=Enum.Font.Antique,StrokeColor=C3.N(.2,.2,.2);Music=5865332363,LeftWing={0,BrickColor.new'Flame reddish orange'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='bot3'};
		{Name="ILLUSION",Walkspeed=190,moveVal=5,Font=Enum.Font.Arcade,StrokeColor=C3.N(.6,.0,.9);Music=6545552463,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Hypnotic'};
		{Name="F0RG0TT3N",Walkspeed=14,moveVal=5,Font=Enum.Font.Arcade,StrokeColor=C3.N(0,.0,0);Music=2598224585,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='LOST2'};
		{Name="Looped Error",Walkspeed=14,moveVal=5,Font=Enum.Font.Arcade,StrokeColor=C3.N(0,.0,0);Music=2113856318,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Lime green'.Color,Enum.Material.Neon};WingAnim='Error303'};
		{Name="HYPNOTIC",Walkspeed=190,moveVal=5,Font=Enum.Font.Arcade,StrokeColor=C3.N(.6,.0,.9);Music=873042302,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Hyposis'};
		{Name="DIMENSIONAL",Walkspeed=190,moveVal=5,Font=Enum.Font.Arcade,StrokeColor=C3.N(.6,.0,.9);Music=873042302,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Dimension'};
    	{Name="Toxicities",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSansBold,StrokeColor=C3.RGB(98,220,109);Music=983667055,LeftWing={0,BrickColor.new'Camo'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Lime green'.Color,Enum.Material.Neon};WingAnim='Toxicities'};	
    	{Name="bored",Walkspeed=66,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(.2,.2,.2);Music=1117396305,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='ihavenothingtodo'};	
    	{Name="CaTAstOphIc",Walkspeed=66,moveVal=8,Font=Enum.Font.Antique,StrokeColor=C3.RGB(179, 0, 255);Music=930541401,LeftWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.Neon};WingAnim='Catastophic'};	
    	{Name="",Walkspeed=66,moveVal=8,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(255, 0, 0);Music=4835535512,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='Blood'};	
    	{Name="Euclidiean",Walkspeed=66,moveVal=8,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(255, 0, 0);Music=4615217001,LeftWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='Solid'};	
    	{Name="CMD:_____",Walkspeed=66,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=5042439286,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='Glitch'};	
    	{Name="Sub-Normal",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=983667055,LeftWing={0,BrickColor.new'Lime green'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Notnormal'};
	    {Name="WITHERED X",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=983667055,LeftWing={0,BrickColor.new'Gray'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Notnormal'};
    	{Name="Normal",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=2910839557,LeftWing={0,BrickColor.new'Lime green'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='normal'};	
    	{Name="DESTRUCTION",Walkspeed=66,moveVal=8,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 0);Music=4615964997,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Destruction'};	
    	{Name="CLOCKWISE",Walkspeed=16,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(255, 255, 255);Music=4755356172,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='FIGHT'};	
    	{Name="",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=412333048,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='NUKE'};	
    	{Name="OMEGA",Walkspeed=66,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=577543579,LeftWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};WingAnim='OMEGA'};	
    	{Name="ARCADE",Walkspeed=66,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=6882952717,LeftWing={0,BrickColor.new'Brick yellow'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Brick yellow'.Color,Enum.Material.Neon};WingAnim='Cave'};	
    	{Name="WITHERED",Walkspeed=66,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=1470848774,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='WITHERED'};	
    	{Name="I N S A N E",Walkspeed=66,moveVal=8,Font=Enum.Font.Bodoni,StrokeColor=C3.RGB(255, 0, 0);Music=1899417820,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='Hell'};	
    	{Name="MENTALLY INSANE",Walkspeed=66,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.RGB(255, 0, 0);Music=2722935436,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='xd'};	
    	{Name="COMPLETELY LOST",Walkspeed=66,moveVal=8,Font=Enum.Font.Antique,StrokeColor=C3.RGB(0, 0, 0);Music=3539622212,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='COMPLETELYLOST'};	
    	{Name="Hydro",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=4211108982,LeftWing={0,BrickColor.new'Dark blue'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};WingAnim='bot'};	
    	{Name="PSYCHO",Walkspeed=66,moveVal=8,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 0);Music=1588725965,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Crimson'.Color,Enum.Material.Neon};WingAnim='mylifeispain'};
    	{Name="UNMERCIFUL",Walkspeed=66,moveVal=8,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 0);Music=6901111184,LeftWing={0,BrickColor.new'Crimson'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='UNMERCIFUL1'};
    	{Name="CURED",Walkspeed=66,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.RGB(255, 238, 0);Music=5544632371,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='CURED'};
    	{Name="",Walkspeed=66,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.RGB(1, 1, 1);Music=5544632371,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Dark stone grey'.Color,Enum.Material.Neon};WingAnim='Spookbday'}; -- Made for Spookitys / Typical Flame for his bday!
    	{Name="Relax",Walkspeed=66,moveVal=8,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=3013643030,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='inf'};
    	{Name="SHATTERED",Walkspeed=66,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.RGB(155, 0, 255);Music=4755976868,LeftWing={0,BrickColor.new'Royal purple'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Shatter'};
    	{Name="disintegrated",Walkspeed=120,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=3539622212,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='nonexistant'};
    	{Name="ENDLESS SILENCE",Walkspeed=120,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=3539622212,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='hi'};
    	{Name="BYE BYE",Walkspeed=120,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 0);Music=5841497754,LeftWing={0,BrickColor.new'Black'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='bye'};
	}

    NewInstance = function(instance,parent,properties)
        local inst = Instance.new(instance)
        inst.Parent = parent
        if(properties)then
            for i,v in next, properties do
                pcall(function() inst[i] = v end)
            end
        end
        return inst;
    end
    
    local CF={N=CFrame.new,A=CFrame.Angles}
    
    local Head = Player.Character:WaitForChild'Head'
    local Torso = Player.Character:WaitForChild'Torso'
    local LArm = Player.Character:WaitForChild'Left Arm'
    local RArm = Player.Character:WaitForChild'Right Arm'
    local LLeg = Player.Character:WaitForChild'Left Leg'
    local RLeg = Player.Character:WaitForChild'Right Leg'
    local Root = Player.Character:WaitForChild'HumanoidRootPart'
    local targetnnn = nil
    function newMotor(P0,P1,C0,C1)
        return NewInstance('Motor',P0,{Part0=P0,Part1=P1,C0=C0,C1=C1})
    end
    
    local welds = {}
    local vars = {}
    local Hit = {}
    
    
    table.insert(welds,newMotor(Torso,Head,CF.N(0,1.5,0),CF.N()))
    table.insert(welds,newMotor(Root,Torso,CF.N(),CF.N()))
    table.insert(welds,newMotor(Torso,RLeg,CF.N(.5,-1,0),CF.N(0,1,0)))
    table.insert(welds,newMotor(Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0)))
    table.insert(welds,newMotor(Torso,LLeg,CF.N(-.5,-1,0),CF.N(0,1,0)))
    table.insert(welds,newMotor(Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0)))
    
    vars.WeldDefaults={}
    for i = 1,#welds do
        local v=welds[i]
        vars.WeldDefaults[i]=v.C0
    end

    local NK,RJ,RH,RS,LH,LS=unpack(welds)

    local NKC0,RJC0,RHC0,RSC0,LHC0,LSC0=unpack(vars.WeldDefaults)

	function makeMusic(id,pit,timePos)
		local sound = Torso:FindFirstChild(Player.Name.."song") or Char:FindFirstChild(Player.Name.."song")
		local parent = (MusicMode==2 and Char or Torso)
		if(not sound)then 
			sound = NewInstance("Sound",parent,{Name=Player.Name.."song",Volume=(MusicMode==3 and 0 or 5),Pitch=(pit or 1),Looped=true})
			NewInstance("EqualizerSoundEffect",sound,{HighGain=0,MidGain=2,LowGain=10})
		end
		if(id=='stop')then
			if(sound)then
				sound:Stop()
			end
		else
			local timePos = typeof(timePos)=='number' and timePos or sound.TimePosition
			sound.Volume = (MusicMode==3 and 0 or 5)
			sound.Name = Player.Name.."song"
			sound.Looped=true
			sound.SoundId = "rbxassetid://"..id
			sound.Pitch=(pit or 1)
			sound:Play()
			sound.TimePosition = timePos
		end
		return sound;
	end

	function playMusic(id,pitch,timePos)
		return makeMusic(id,pitch,timePos)
	end

	for _,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop(0);
	end

	-- SCRIPT STUFF --

	function swait(num)
		if num == 0 or num == nil then
			game:GetService("RunService").RenderStepped:wait()
		else
			for i = 0, num do
				game:GetService("RunService").RenderStepped:wait()
			end
		end
	end

	--// Effects \\--

	function Tween(obj,props,time,easing,direction,repeats,backwards)
		local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
		local tween = S.TweenService:Create(obj, info, props)

		tween:Play()
	end

	function StartShake(Settings)
		return true
	end

	function Camshake(shakedata)
		StartShake(shakedata)
	end

	local Effects=NewInstance("Folder",Char)
	Effects.Name=Player.Name..'Effects'


	function ShowDamage(Pos, Text, Time, Color)
		local Pos = Pos or V3.N(0, 0, 0)
		local Text = tostring(Text or "")
		local Time = Time or 2
		local Color = Color or C3.N(1, 0, 1)
		local EffectPart = Part(Effects,Color,Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CFrame.new(Pos),true,false)
		EffectPart.Transparency=1
		local BillboardGui = NewInstance("BillboardGui",EffectPart,{
			Size = UDim2.new(3,0,3,0),
			Adornee = EffectPart,
		})

		local TextLabel = NewInstance("TextLabel",BillboardGui,{
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold, 
		})
		S.Debris:AddItem(EffectPart, Time+.5)
		delay(0, function()
			local rot=math.random(-10,10)/15
			local raise=.2
			local Frames = Time/Frame_Speed
			for i=0,1.1,.02 do
				swait()
				TextLabel.Rotation=TextLabel.Rotation+rot
				raise=raise-.008
				EffectPart.Position = EffectPart.Position + Vector3.new(0, raise, 0)
				TextLabel.TextTransparency=i
				TextLabel.TextStrokeTransparency=i
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end


	local baseSound = IN("Sound")

	function Soond(parent,id,pitch,volume,looped,effect,autoPlay)
		local Sound = baseSound:Clone()
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				Sound:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent =parent or Torso
		return Sound
	end

	function SoondPart(id,pitch,volume,looped,effect,autoPlay,cf)
		local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				soundPart:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent = soundPart
		return Sound,soundPart
	end

	function SoundPart(...)
		return SoondPart(...)
	end

	function Sound(...)
		return Soond(...)
	end

	function Part(parent,color,material,size,cframe,anchored,cancollide)
		local part = IN("Part")
		part.Parent = parent or Char
		part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
		part.Material = material or Enum.Material.SmoothPlastic
		part.TopSurface,part.BottomSurface=10,10
		part.Size = size or V3.N(1,1,1)
		part.CFrame = cframe or CF.N(0,0,0)
		part.CanCollide = cancollide or false
		part.Anchored = anchored or false
		return part
	end

	function Weld(part0,part1,c0,c1)
		local weld = IN("Weld")
		weld.Parent = part0
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0 or CF.N()
		weld.C1 = c1 or CF.N()
		return weld
	end

	function Mesh(parent,meshtype,meshid,textid,scale,offset)
		local part = IN("SpecialMesh")
		part.MeshId = meshid or ""
		part.TextureId = textid or ""
		part.Scale = scale or V3.N(1,1,1)
		part.Offset = offset or V3.N(0,0,0)
		part.MeshType = meshtype or Enum.MeshType.Sphere
		part.Parent = parent
		return part
	end

	function GotEffect(data)
		-- just for easy reference
		local color = data.Color or Color3.new(.7,.7,.7);
		local endcolor = data.EndColor or nil;
		local mat = data.Material or Enum.Material.SmoothPlastic;
		local cframe = data.CFrame or CFrame.new();
		local endpos = data.EndPos or nil;
		local meshdata = data.Mesh or {}
		local sounddata = data.Sound or {}
		local size = data.Size or Vector3.new(1,1,1)
		local endsize = data.EndSize or Vector3.new(6,6,6)
		local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
		local transparency = data.Transparency or NumberRange.new(0,1)
		local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
		local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
		local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
		local lifetime = data.Lifetime or 1;
		local system = data.FXSystem;
		local setpart = typeof(data.Part)=='string' and EffectFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil

		local S,PM;

		local P = setpart or Part(Effects,color,mat,Vector3.new(1,1,1),cframe,true,false)

		if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
			if(meshdata == "Blast")then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8))
			elseif(meshdata == 'Ring')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
			elseif(meshdata == 'Slash1')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
			elseif(meshdata == 'Slash2')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
			elseif(meshdata == 'Tornado1')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
			elseif(meshdata == 'Tornado2')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
			elseif(meshdata == 'Skull')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
			elseif(meshdata == 'Crystal')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
			elseif(meshdata == 'Cloud')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
			elseif(typeof(meshdata) == 'table')then
				local Type = meshdata.Type or Enum.MeshType.Brick
				local ID = meshdata.ID or '';
				local Tex = meshdata.Texture or '';
				local Offset = meshdata.Offset or Vector3.new(0,0,0)
				PM = Mesh(P,Type,ID,Tex,size,Offset)
			else
				PM = Mesh(P,Enum.MeshType.Brick,'','',size)
			end
		end
		local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
		local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1

		P.Material = mat
		P.CFrame = cframe
		P.Color = (typeof(color)=='BrickColor' and color.Color or color)
		P.Anchored = true
		P.CanCollide = false
		P.Transparency = startTrans
		P.Parent = Effects
		local random = Random.new();
		game:service'Debris':AddItem(P,lifetime+3)


		-- actual effect stuff
		local mult = 1;
		if(PM)then
			if(PM.MeshId == 'rbxassetid://20329976')then
				PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
			elseif(PM.MeshId == 'rbxassetid://4770583')then
				mult = 2
			elseif(PM.MeshId == 'rbxassetid://168892432')then
				mult = .25
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				mult = .1
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				mult = .1
			end
		end	
		coroutine.wrap(function()
			if(system == 'Legacy' or system == 1 or system == nil)then
				local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*Frame_Speed
				for i = 0, frames do
					local div = (i/frames)
					P.Transparency=(startTrans+(endTrans-startTrans)*div)

					if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end

					local RotCF=CFrame.Angles(0,0,0)

					if(rotinc == 'random')then
						RotCF=CFrame.Angles(math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)))
					elseif(typeof(rotinc) == 'table')then
						RotCF=CFrame.Angles(unpack(rotinc))
					end

					if(PM and PM.MeshId == 'rbxassetid://20329976')then
						PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
					end

					if(endpos and typeof(endpos) == 'CFrame')then
						P.CFrame=cframe:lerp(endpos,div)*RotCF
					elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
						local force = acceleration.Force;
						if(typeof(force)=='CFrame')then
							force=force.p;
						end
						if(typeof(force)=='Vector3')then
							if(acceleration.LookAt)then
								P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
							else
								P.CFrame=(P.CFrame+force)*RotCF
							end
						end
					else
						P.CFrame=P.CFrame*RotCF
					end

					if(endcolor and typeof(endcolor) == 'Color3')then
						P.Color = color:lerp(endcolor,div)
					end
					swait()
				end
				P:destroy()
			elseif(system == 'Experimental' or system == 2)then
				local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
				local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
				if(style == Enum.EasingStyle.Elastic)then
					info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
				elseif(style == Enum.EasingStyle.Bounce)then
					info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
				end
				local tweenPart = game:service'TweenService':Create(P,info2,{
					CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CFrame.Angles(unpack(endrot)),
					Color=typeof(endcolor) == 'Color3' and endcolor or color,
					Transparency=endTrans,
				})
				local off = Vector3.new(0,0,0)
				if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end

				local tweenMesh = game:service'TweenService':Create(PM,info,{
					Scale=endsize*mult,
					Offset=off,
				})
				tweenPart:Play()
				tweenMesh:Play()
			end
		end)()
	end

	function Effect(edata)
		GotEffect(edata)
	end

	function Trail(data)
		coroutine.wrap(function()
			data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
			data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
			local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
			data.EndPos=nil
			local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
			trailPart.Transparency=1
			local start = data.CFrame
			for i = 1, data.Frames do
				trailPart.CFrame = start:lerp(ep,i/data.Frames)
				data.CFrame = trailPart.CFrame
				Effect(data)
				swait()
			end	
		end)()
	end

	function ClientTrail(data)
		coroutine.wrap(function()
			data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
			data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
			local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
			data.EndPos=nil
			local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
			trailPart.Transparency=1
			local start = data.CFrame
			for i = 1, data.Frames do
				trailPart.CFrame = start:lerp(ep,i/data.Frames)
				data.CFrame = trailPart.CFrame
				GotEffect(data)
				swait()
			end	
		end)()
	end


	if(Char:FindFirstChild('NGRWings'..Player.Name))then
		Char['NGRWings'..Player.Name]:destroy()
	end

	for _,v in next, Char:children() do
		if(v.Name:lower():find'wings')then 
			v:destroy()
		end
	end

	local wingModel = Instance.new("Model",Char)
	wingModel.Name="NGRWings"..Player.Name
	local rightWing = NewInstance("Model",wingModel,{Name='Right'})
	local leftWing = NewInstance("Model",wingModel,{Name='Left'})

    local International = {}
    local InternationalAttach = {}
    for _,v in pairs(Char:GetChildren()) do
        if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") or v.Name:find("InternationalFedora") or v.Name:find("International Fedora") then
            table.insert(International,v)
            print(v)
        end
    end
    --[[for i = 1,#International do
        local v=International[i]
        print(v)
    end--]]

	local LWP1 = WingPiece:Clone();
	
	LWP1.Parent = leftWing
	local LWP2 = WingPiece:Clone();


	LWP2.Parent = leftWing
	local LWP3 = WingPiece:Clone();

	LWP3.Parent = leftWing
	local RWP1 = WingPiece:Clone();

	RWP1.Parent = rightWing
	local RWP2 = WingPiece:Clone();

	RWP2.Parent = rightWing
	local RWP3 = WingPiece:Clone();


	RWP3.Parent = rightWing
	local RWP4 = WingPiece:Clone();


	RWP4.Parent = rightWing
	local RWP5 = WingPiece:Clone();



	RWP5.Parent = rightWing
	local LWP1W=Weld(LWP1.PrimaryPart,Torso,CF.N(2,-2,-1)*CF.A(0,0,0))
	local LWP2W=Weld(LWP2.PrimaryPart,Torso,CF.N(4.25,-1,-1)*CF.A(0,0,M.R(15)))
	local LWP3W=Weld(LWP3.PrimaryPart,Torso,CF.N(6.5,.5,-1)*CF.A(0,0,M.R(30)))

	local RWP1W=Weld(RWP1.PrimaryPart,Torso,CF.N(-2,-2,-1)*CF.A(0,0,0))
	local RWP2W=Weld(RWP2.PrimaryPart,Torso,CF.N(-4.25,-1,-1)*CF.A(0,0,M.R(-15)))
	local RWP3W=Weld(RWP3.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
	local RWP4W=Weld(RWP4.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
	local RWP5W=Weld(RWP5.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
    for _,v in pairs(leftWing:GetChildren()) do
        if v:IsA("Model") then
            PrimaryPart = v.PrimaryPart
            table.insert(InternationalAttach,PrimaryPart)
        end
    end
    for _,v in pairs(rightWing:GetChildren()) do
        if v:IsA("Model") then
            PrimaryPart = v.PrimaryPart
            table.insert(InternationalAttach,PrimaryPart)
        end
    end
    for i = 1,#InternationalAttach do
        local vn=InternationalAttach[i]
        local hatvariable = gp(vn, "att1_Handle", "Attachment")
        if hatvariable then return end
        local v=International[i]
        local hat = gp(gp(gp(cnnnnn, v.Name, "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
        local hatmesh = gp(gp(cnnnnn.Model, v.Name, "Accessory"), "Handle", "BasePart")
        local hatmesh = hatmesh:FindFirstChild("SpecialMesh") or hatmesh:FindFirstChild("Mesh")
        if hatvariable then return end
        hat.Parent = vn
        hat.Name = v.Name
        if i == 1 then 
        hat.Position = Vector3.new(0,-2,0)
        elseif i == 2 then
            hat.Position = Vector3.new(0,-2,0)
        elseif i == 3 then
            hat.Position = Vector3.new(0,-2,0)
        elseif i == 4 then
            hat.Position = Vector3.new(0,-2,0)
        elseif i == 5 then
            hat.Position = Vector3.new(0,-2,0)
        elseif i == 6 then
            hat.Position = Vector3.new(0,-2,0)
        elseif i == 7 then
            hat.Position = Vector3.new(0, -3.5, 0)
        elseif i == 8 then
            hat.Position = Vector3.new(0, 0.5, -0)
        end
        hatmesh:Destroy()
        for _,v in pairs(vn.Parent:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Transparency = 1
            end
        end
        print("---") print(vn.Parent) print("Attached") print(v) print("---")
    
    end
	local bbg=Head:FindFirstChild'Nametag' or NewInstance("BillboardGui",Head,{
		Adornee=Head;
		Name='Nametag';
		Size=UDim2.new(4,0,1.2,0);
		StudsOffset=V3.N(-8,5.3,0);
	})
	local text=bbg:FindFirstChild'TextLabel' or NewInstance("TextLabel",bbg,{
		Size=UDim2.new(5,0,3.5,0);
		TextScaled=true;
		BackgroundTransparency=1;
		TextStrokeTransparency=0;
		Font=Enum.Font.Arcade;
		TextColor3=C3.N(1,1,1);
		Text='POWER'
	})

	function getMode(modeName)
		for i,v in next, modeInfo do
			if(v.Name==modeName)then
				return v
			end
		end
		return modeInfo[1]
	end

	function IsVaporwave(song)
		for i = 1,#VaporwaveSongs do
			if(VaporwaveSongs[i]==song)then
				return true
			end
		end
		return false
	end

	local blush = NewInstance('Decal',Head,{Transparency=1,Texture='rbxassetid://0',Color3=(Player.UserId==5719877 and C3.N(.45,0,1) or C3.N(1,0,0))})

	function changeMudo(modeName)
		local info = getMode(modeName)
		Mode=info.Name
		WalkSpeed=info.Walkspeed
		movement=info.moveVal
		music=makeMusic(info.Music or 0,info.Pitch or 1,info.TimePos or music and music.TimePosition or 0)
		WingAnim=info.WingAnim or 'NebG1'
		text.Text = info.Name
		text.TextColor3 = info.LeftWing[2]
		text.TextStrokeColor3 = info.StrokeColor
		text.Font=info.Font;
		if(Mode=='Love' or Mode=='Lust')then
			blush.Transparency=0
			blush.Texture='rbxassetid://2664127437'
		else
			blush.Transparency=1
			blush.Texture='rbxassetid://0'
		end
		for _,v in next,leftWing:GetDescendants() do
			if(v:IsA'BasePart' and v.Name~='Main')then
				--v.Transparency=info.LeftWing[1]
				v.Color=info.LeftWing[2]
				v.Material=info.LeftWing[3]
			elseif(v:IsA'Trail')then
				--v.Transparency=NumberSequence.new(info.LeftWing[1],1)
				v.Color=ColorSequence.new(info.LeftWing[2])	
			end
		end

		for _,v in next,rightWing:GetDescendants() do
			if(v:IsA'BasePart' and v.Name~='Main')then
				--v.Transparency=info.RightWing[1]
				v.Color=info.RightWing[2]
				v.Material=info.RightWing[3]
			elseif(v:IsA'Trail')then
				--v.Transparency=NumberSequence.new(info.RightWing[1],1)
				v.Color=ColorSequence.new(info.RightWing[2])	
			end
		end

		PrimaryColor = info.PrimaryColor or info.LeftWing[2]
	end

	function changeMode(modeName)
		changeMudo(modeName)
	end	

	function syncStuff(data)
		local neut,legwelds,c0s,c1s,sine,mov,walk,inc,musicmode,tpos,pit,wingsin,visSett,mode,newhue=unpack(data)
		local head0,torso0,rleg0,rarm0,lleg0,larm0=unpack(c0s)
		local head1,torso1,rleg1,rarm1,lleg1,larm1=unpack(c1s)
		legAnims=legwelds
		NeutralAnims=neut
		if(not neut)then
			NK.C0=head0
			RJ.C0=torso0
			RH.C0=rleg0
			RS.C0=rarm0
			LH.C0=lleg0
			LS.C0=larm0

			NK.C1=head1
			RJ.C1=torso1
			RH.C1=rleg1
			RS.C1=rarm1
			LH.C1=lleg1
			LS.C1=larm1
		end
		if(Mode~=mode)then
			changeMudo(mode)
		end
		movement=mov
		walking=walk
		Change=inc
		print(MusicMode,musicmode)
		if(musicmode~=MusicMode and music)then
			MusicMode=musicmode
			if(MusicMode==1)then
				music:Pause()
				music.Volume=5
				music.Parent=Torso
				music:Resume()
			elseif(MusicMode==2)then
				music:Pause()
				music.Volume=5
				music.Parent=Char
				music:Resume()
			elseif(MusicMode==3)then
				music.Volume = 0
			end
		end
		if(Sine-sine>.8 or Sine-sine<-.8)then
			Sine=sine
		end
		if(hue-newhue>.8 or hue-newhue<-.8)then
			hue=newhue
		end
		if(WingSine-wingsin>.8 or WingSine-wingsin<-.8)then
			WingSine=wingsin
		end
		if(music and (music.TimePosition-tpos>.8 or music.TimePosition-tpos<-.8))then
			music.TimePosition=tpos
		end
		if(music and pit)then
			music.Pitch = pit
		end
		if(Mode=='Troubadour' and music.SoundId~='rbxassetid://'..visSett.Music)then
			music.SoundId='rbxassetid://'..visSett.Music
		end
		getMode('Troubadour').Music = visSett.Music
		getMode('Troubadour').Pitch = visSett.Pitch
	end


	local footstepSounds = {
		[Enum.Material.Grass]=510933218;
		[Enum.Material.Metal]=1263161138;
		[Enum.Material.CorrodedMetal]=1263161138;
		[Enum.Material.DiamondPlate]=1263161138;
		[Enum.Material.Wood]=2452053757;
		[Enum.Material.WoodPlanks]=2452053757;
		[Enum.Material.Sand]=134456884;
		[Enum.Material.Snow]=2452051182;
	}


	function Vaporwaveify(s)
		local function wide(a)
			if a<'!' or a>'~' then return a end
			if a==' ' then return '  ' end 
			a = a:byte()+160
			if a<256 then return string.char(239,188,a-64) end
			return string.char(239,189,a-128)
		end
		return(s:gsub(".",wide))
	end



	function Choot(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Antique,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end
	
		function Choot2(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Fantasy,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		
		
				function Choot8(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.SourceSans,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		
		function Choot3(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Fondamento,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot4(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.SourceSansItalic,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end

		function Choot5(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Arcade,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot6(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Jura,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot7(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Bodoni,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end

	function Chat(text)
		Choot(text)
	end
	
	function Chat7(text)
		Choot7(text)
	end
	
		function Chat8(text)
		Choot8(text)
	end
	
    function Chat2(text)
		Choot2(text)
    end
    
    function Chat3(text)
		Choot3(text)
    end
    
    function Chat4(text)
		Choot4(text)
    end

    function Chat5(text)
		Choot5(text)
    end
    
    function Chat6(text)
		Choot6(text)
	end

	function DealDamage(...)
		return true
	end

	function getRegion(point,range,ignore)
		return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
	end
	function AOEDamage(where,range,options)
		local hit = {}
		for _,v in next, getRegion(where,range,{Char}) do
			if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent:FindFirstChildOfClass'Humanoid'])then
				local callTable = {Who=v.Parent}
				hit[v.Parent:FindFirstChildOfClass'Humanoid'] = true
				for _,v in next, options do callTable[_] = v end
				DealDamage(callTable)
			end
		end
		return hit
	end


	function Click1()
		Attack=true
		NeutralAnims=false
		legAnims=false
		local orig = WalkSpeed
		WalkSpeed=4
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-44.6),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.8,-1,-0.3)*CF.A(M.R(-17.4),M.R(44.4),M.R(7.1)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.4,-1,0)*CF.A(M.R(1.6),M.R(-13.1),M.R(7)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.3)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.1)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(44.6),M.R(0)),Alpha)
		end
		for i = 0, 1, 0.1 do
			swait()
			AOEDamage(RArm.CFrame.p,2,{
				DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
				MinimumDamage=5;
				MaximumDamage=15;
			})
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,0,-0.7)*CF.A(M.R(0),M.R(50.5),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.6)*CF.A(M.R(-26),M.R(0),M.R(0)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.6,-1.1,-0.1)*CF.A(M.R(20.2),M.R(-47.6),M.R(15.2)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-20.4)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(50.5)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-50.5),M.R(0)),Alpha)
		end
		WalkSpeed=orig
		legAnims=true
		Attack=false
		NeutralAnims=true
	end

	function SwordSummon()
		Attack = true
		NeutralAnims = false
		local orig=WalkSpeed
		WalkSpeed=4
		legAnims=false
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			Effect{
				Lifetime=.25;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				Color=PrimaryColor;
				Transparency={.5,1};
				Material=Enum.Material.Neon;
				Size=Vector3.new(.6,1,.6);
				EndSize=Vector3.new(.1,3,.1);
			}
			RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,-0.1)*CF.A(M.R(-12.4),M.R(-15.7),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.5)*CF.A(M.R(16.2),M.R(15.2),M.R(-0.8)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-28.5),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.4,0.5,0)*CF.A(M.R(27.2),M.R(-3.8),M.R(-5)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.3,0.6,0)*CF.A(M.R(-33.8),M.R(-18.1),M.R(24.8)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(13.4),M.R(15.3),M.R(-3.6)),Alpha)
		end
		for i = 0, 5 do
			delay(.05*i,function()
				local pos = Root.CFrame*CF.N(0,-2,-2-i*4)*CF.A(M.R(80),0,0)
				local pos2 = Root.CFrame*CF.N(0,-3,-2-i*4)
				Camshake({
					Duration=.2;
					FadeOut=.2;
					Intensity=1.5;
					Position=Vector3.new(.5,.5,.5);
					Rotation=Vector3.new(.5,.5,3);
					DropDist=15;
					IneffectiveDist=40;
					Origin=pos2;
				})
				AOEDamage(pos.p,5,{
					DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
					MinimumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/10 or 10);
					MaximumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/8 or 35);
				})
				SoundPart(178452221,1,2,false,true,true,pos)
				Effect{
					Lifetime=.4;
					Part='Sword',
					--Mesh={Type=Enum.MeshType.Sphere};
					CFrame=pos;
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
				}
				Effect{
					Lifetime=.4;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=pos2;
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(4,.1,4);
					EndSize=V3.N(6,.1,6);
				}
				Effect{
					Lifetime=.1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=pos;
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(7,7,7);
					EndSize=V3.N(12,12,12);
				}
				for i = 1, 5 do
					Effect{
						Lifetime=.5;
						Mesh={Type=Enum.MeshType.Sphere};
						CFrame=pos;
						Color=PrimaryColor;
						Transparency={0,1};
						Material=Enum.Material.Neon;
						Size=V3.N(1,1,1);
						EndSize=V3.N(1,1,1);
						Acceleration={Force=V3.N(M.RNG(-75,75)/100,M.RNG(-75,75)/100,M.RNG(-75,75)/100)};
					}
				end
			end)
		end
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
		end
		legAnims=true
		WalkSpeed=orig
		Attack = false
		NeutralAnims = true
	end

	function Bombs()
		Attack=true
		NeutralAnims=false
		legAnims=false
		local orig = WalkSpeed
		WalkSpeed=0
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(19.1)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(-21.3)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		end
		coroutine.wrap(function()
			for i = 0, 2 do
				Camshake({
					Duration=.2;
					FadeOut=.2;
					Intensity=1.5;
					Position=Vector3.new(.5,.5,.5);
					Rotation=Vector3.new(.5,.5,3);
					DropDist=15;
					IneffectiveDist=40;
					Origin=Root.CFrame*CF.N(0,0,-4-i*4);
				})
				SoundPart(206083252,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
				AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
					DamageColor=PrimaryColor;
					MinimumDamage=25;
					MaximumDamage=45;
				})
				Effect{
					Lifetime=.4;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Material=Enum.Material.Neon;
					CFrame=Root.CFrame*CF.N(0,0,-4-i*4);
					Size=V3.N(1,1,1);
					EndSize=V3.N(10,10,10);
				}
				Effect{
					Lifetime=.4;
					Part='Ring';
					Color=PrimaryColor;
					Material=Enum.Material.Neon;
					CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
					Size=V3.N(4,4,.2);
					EndSize=V3.N(13,13,.2);
				}
				Effect{
					Lifetime=.4;
					Part='Ring';
					Color=PrimaryColor;
					Material=Enum.Material.Neon;
					CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
					Size=V3.N(4,4,.2);
					EndSize=V3.N(13,13,.2);
				}
				swait(4)
			end
		end)()
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,0.7)*CF.A(M.R(18.2),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,-0.4)*CF.A(M.R(-33.4),M.R(0),M.R(0)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.5,-0.9,-0.2)*CF.A(M.R(-6.7),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.4,0.4,0.1)*CF.A(M.R(90.7),M.R(-2.5),M.R(-50)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.2)*CF.A(M.R(89.5),M.R(2.6),M.R(50)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		end
		WalkSpeed=orig
		legAnims=true
		Attack=false
		NeutralAnims=true
	end


	function ClickCombo()
		ClickTimer=180
		if(Combo==1)then
			Click1()
			Combo=2
		elseif(Combo==2)then
			SwordSummon()
			Combo=3
		elseif(Combo==3)then
			Bombs()
			Combo=1
		end
	end

	function VaporTaunt()
		Attack = true
		NeutralAnims = false
		local orig=WalkSpeed
		WalkSpeed=0
		legAnims=false
		Chat"You need to chill out.."
		for i = 0, 14, 0.1 do
			swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CF.N(-0.1,-0.1-.1*M.S(Sine/36),0.6)*CF.A(M.R(55.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.6,-1.2,-0.1)*CF.A(M.R(56.3+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.9,-1.2,-0.2)*CF.A(M.R(25+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.2)*CF.A(M.R(61-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-38.9-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
		end
		legAnims=true
		WalkSpeed=orig
		Attack = false
		NeutralAnims = true
	end



	UIS.InputBegan:connect(function(io,gpe)
		if(gpe or Attack or data.User~=data.Local)then return end
		--MODES
		if(io.KeyCode == Enum.KeyCode.One and Mode~='POWER')then 
			changeMode'POWER'
			game.Lighting.FogEnd = 999999999
			Chat7"THE EARTH QUAKES BENEATH ME!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[POWER] THE EARTH QUAKES BENEATH ME!", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.U and Mode=='POWER')then 
			changeMode'FORCE'
			game.Lighting.FogEnd = 999999999
			Chat7"THE EARTH QUAKES BENEATH ME!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[POWER] THE EARTH QUAKES BENEATH ME!", "All")
else
end


elseif(io.KeyCode == Enum.KeyCode.U and Mode=='PSYCHO')then 
			changeMode'F0RG0TT3N'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"End my forgotten existence"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[FORGOTTEN] end my FORGOTTEN existence", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.P and Mode=='S P A C E T I M E')then 
			changeMode'PULSAR'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat"Pulsing Energy"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[PULSAR] PULSING ENERGY", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='PUNISHED')then 
			changeMode'HYBRID'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"I AM YOU AND ME!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[HYBRID] 2 Of Us?", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.U and Mode=='PSYCHO')then 
			changeMode'F0RG0TT3N'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"End my forgotten existence"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[FORGOTTEN] end my FORGOTTEN existence", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='DESTRUCTION')then 
			changeMode'APCOCLYPTIC'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"APOCOLYPSE!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[APCOCLYPTIC] HAHAHAHAHAHAH", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.U and Mode=='ACE-OF-SPADES')then 
			changeMode'BURNING BRAIN'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"WEILD THE POWER"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ZENITH] THE ALMIGHTY!", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.H and Mode=='MURDEROUS')then 
			changeMode'PUNISHED'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"YOU SHALL BE PUNISHED"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[PUNISHED] YOU SHALL BE PUNISHED.", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.L and Mode~='ACE-OF-SPADES')then 
			changeMode'ACE-OF-SPADES'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"LETS SEE SOME MAGIC!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[PUNISHED] YOU SHALL BE PUNISHED.", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.G and Mode=='S P A C E T I M E')then 
			changeMode'WORMHOLE'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"INSTANT TRAVEL"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[WORMHOLE] INSTANT TRAVEL", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='ECHO')then 
			changeMode'Deleterious'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"CLEAR THIS REALITY"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Deleterious] CLEAR THIS REALITY", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.B and Mode~='???')then 
			changeMode'???'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"Question your existence"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[???] Question your purpose...", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='EXCALIBUR')then 
			changeMode'GREATSWORD'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"LONGEST SWORD KNOWN TO MAN"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[GREATSWORD] THE LARGEST SWORD", "All")
else
end



	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Toxicities')then 
			changeMode'Atomic Collisions'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"ATOMIC FUSION"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ATOMIC COLLISIONS] NUCLEAR FUSION", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='')then 
			changeMode'Lightning Cannon'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"LIGHTNING CANNON MODE, BY ME"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[LIGHTNING CANNON] I WILL STRIKE!", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.G and Mode=='MURDEROUS')then 
			changeMode'ECHO'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat8" Has Arrived."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(Player.Name.." Has Arrived", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.F and Mode=='ECHO')then 
			changeMode''
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat8" Has Arrived."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Cheems glitcher v1.2] Welcome "..game.Players.LocalPlayer.Name.."...", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='SINGULARITY')then 
			changeMode'THE VOID'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"ETERNAL DARKNESS"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[THE VOID] ENDLESS DARKNESS!", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.V and Mode~='INEVITABLE')then 
			changeMode'INEVITABLE'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"Everything you know is in your mind..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[INEVITABLE] Everything you know is in your mind...", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.B and Mode~='Nefarious')then 
			changeMode'Nefarious'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"JUST DIE ALREADY!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Nefarious] JUST DIE ALREADY!", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Nefarious')then 
			changeMode'UNMERCIFUL'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"I  spare you."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[UNMERCIFUL] DONT SPARE ANYONE", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='CURED')then 
			changeMode'SPEED OF LIGHT'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"FASTER THEN HYPER SPEED"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[SPEED OF LIGHT] BEYOND SPEED", "All")
else
end

	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='F0RG0TT3N')then 
			changeMode'R E M E M B E R E D'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 4
			Chat5"I AM NOT FORGOTTEN JUST YET!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[REMEMBERED!] I AM NOT FORGOTTEN YET!!", "All")
else
end


	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='bored')then 
			changeMode'CLOCKWISE'
			game.Lighting.FogEnd = 999999999
			game.Lighting.ClockTime = 14
			Chat5"CLOCKWISE"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CLOCKWISE] FORWARD OF TIME", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Two and Mode~='Splits')then 
			changeMode'Splits'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Splits] Ha!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.C and Mode~='PLATFORM')then 
			changeMode'PLATFORM'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[PLATFORM] is this helicopter?", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='POWER')then 
			changeMode'EXCALIBUR'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"I WILL DESTROY YOU!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[EXCALIBUR] YOU CANT DEFEAT ME!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='EXCALIBUR')then 
			changeMode'EXCALIBUR X'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"YOU THINK I WOULD FALL THAT EASY?!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[EXCALIBUR X] TRY AGAIN!!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='EXCALIBUR X')then 
			changeMode'EXCALIBUR'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[LETS GO BACK.. BUT NOT TOO FAR BACK.] Ha!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='')then 
			changeMode''
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"    "
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[] I WILL CORRUPT EVERYTHING!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='S P A C E T I M E')then 
			changeMode'OMEGA'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[OMEGA] Ha!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='MURDEROUS')then 
			changeMode'WITHERED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"CEASE TO EXIST"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[WITHERED] CEASE TO EXIST!", "All")
else
end


		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='ERROR_404')then 
			changeMode'SYSTEM_32'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[SYSTEM 32] ERROR", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='ERROR_404')then 
			changeMode'ARCADE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ARCADE] 1000 - 0!", "All")
else
end


		elseif(io.KeyCode == Enum.KeyCode.X and Mode~='FUTURE')then 
			changeMode'FUTURE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"10,000 YEARS!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[FUTURE] IM 10000 YEARS AHEAD OF YOU!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='POWER')then 
			changeMode'YING-YANG'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat2"Perfectly Balanced. As all things should be..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[YING YANG] Perfectly Balanced. As all things should be...", "All")
else
end


		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='S P A C E T I M E')then 
			changeMode'Euclidiean'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"I Control every state of matter"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Euclidiean] SOLIDS", "All")
else
end


		elseif(io.KeyCode == Enum.KeyCode.E and Mode=='S P A C E T I M E')then 
			changeMode'DIMENSIONAL'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"INTER DIMENSIONAL!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[DIMENSIONAL] INTER DIMENSIONAL", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Liar X')then 
			changeMode'INFINITE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat7"INFINITE POWER!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[INFINITE] INFINITE POWER!", "All")
else
end



		elseif(io.KeyCode == Enum.KeyCode.P and Mode=='MURDEROUS')then 
			changeMode'CRAZED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"LETS SEE HOW LONG YOU LAST"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CRAZED] LETS SEE HOW LONG YOU LAST!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.U and Mode=='MURDEROUS')then 
			changeMode'Liar X'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"I WILL BREAK THE TRUTH"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Liar X] I WILL BREAK THE TRUTH!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='S P A C E T I M E')then 
			changeMode'SINGULARITY'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"DES(^(UC*&*&ION"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[SINGULARITY] DESTROYED UNIVERSE", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='ILLUSION')then 
			changeMode'HYPNOTIC'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
		    Chat5"I WILL CONTROL YOU"
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[HYPNOTIC] I CAN CONTROL ANYTHING", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Z and Mode~='bored')then 
			changeMode'bored'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
		if voicelines == false then
		    Chat5"You make me bored every second of your existence"
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[bored] e", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Sub-Normal')then 
			changeMode'ILLUSION'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat5"Everything is not as it seems"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ILLUSION] EVERYTHING IS NOT AS IT SEEMS", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Inferno')then 
			changeMode'Volcanic'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat3"RAINING FIRE!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Volcanic] RAINING FIRE", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='I N S A N E')then 
			changeMode'Fearless'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat"FEARLESS"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[FEARLESS] I FEAR NOTHING!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Three and Mode~='Overclocked')then 
			changeMode'Overclocked'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Hyper Power!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Over-clocked] Hyper power!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Overclocked')then 
			changeMode'TIME WARP'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Warping through time..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[TIME WARP] I Difine who everyone is.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Four and Mode~='S P A C E T I M E')then 
			changeMode'S P A C E T I M E'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 40000
						Chat5"BENDING SPACE AND TIME..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[S P A C E T I M E] Bending time and space!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Five and Mode~='ERROR_404')then 
			changeMode'ERROR_404'
			game.lighting.ClockTime = 3
			game.lighting.FogEnd = 300
						Chat"$#%#E$%#$%$#RR%#%O$R"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ERROR_404] ___ __ _______", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Six and Mode~='MURDEROUS')then 
			changeMode'MURDEROUS'
			game.lighting.ClockTime = 4
			game.lighting.FogEnd = 600
			Chat"DIE!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[MURDEROUS] I regret nothing.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Seven and Mode~='DESTROYED')then 
			changeMode'DESTROYED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000
			Chat"YOUR EXISTENCE IS A MISTAKE!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[DESTROYED] ENOUGH!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Eight and Mode~='god slayer')then 
			changeMode'god slayer'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000
			Chat"YOUR EXISTANCE IS OBSOLETE."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[god slayer] YOUR EXISTANCE IS OBSOLETE.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Nine and Mode~='Toxicities')then 
			changeMode'Toxicities'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Toxicities] Poison!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='MURDEROUS')then 
			changeMode'I N S A N E'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000000000
			Chat"TRUE CARNAGE"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[I N S A N E] INSANITY IS UPON US!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Q and Mode~='L0st')then 
			changeMode'L0st'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[L0st] Where am i?", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.F and Mode~='Destiny')then 
			changeMode'Destiny'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Destiny] DESTINY HAS LEFT ME HERE!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.M and Mode=='Destiny')then 
			changeMode'Calamity'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Calamity] YOU IDIOT.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.M and Mode=='Calamity')then 
			changeMode'Catastrophe'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Catastrophe] Bout time this world ends!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.N and Mode=='Catastrophe')then 
			changeMode'Mythical'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Mythical] This world is my fantasy!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.B and Mode=='Catastrophe')then 
			changeMode'Cataclysm'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Cataclysm] CHAOS!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='90s')then 
			changeMode'80s'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600
			Chat6"Dont play games with me..."
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[80s] Im back in time...", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='Sub-Normal')then 
			changeMode'90s'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[90s] Im already here!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Toxicities')then 
			changeMode'Radioactivity'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 300
            Chat"T O X I C"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Radioactivity] I'LL TOXICATE YOU!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Catastrophe')then 
			changeMode'CaTAstOphIc'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CaTAstOphIc] TORN APART.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='Splits')then 
			changeMode''
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[] JJsploit is the best!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='ERROR_404')then 
			changeMode'CMD:_____'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CMD:_____] ERADICATE YOURSELF.", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='ERROR_404')then 
			changeMode'Looped Error'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000000000
			Chat"ENDLESS ERROR!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Looped Error] ERADICATE YOURSELF.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Zero and Mode~='Sub-Normal')then 
			changeMode'Sub-Normal'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Sub-Normal] I've Changed.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Sub-Normal')then 
			changeMode'Normal'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 6000000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Normal] Nothing in particular.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='MURDEROUS')then 
			changeMode'DESTRUCTION'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 500
			Chat"IL SAVE YOU FROM THIS HELL CALLED EARTH!"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[DESTRUCTION] I'LL FREE YOU FROM THIS HELL!", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='DESTRUCTION')then 
			changeMode'GENOCIDE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 500
			Chat"I WILL KILL EVERYBODY"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[DESTRUCTION] I'LL FREE YOU FROM THIS HELL!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='L0st')then 
			changeMode'COMPLETELY LOST'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 400
			Chat("L O S T")
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Completley Lost] Shattered across time and space.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.R and Mode=='L0st')then 
			changeMode'PSYCHO'
			game.lighting.ClockTime = 4
			game.lighting.FogEnd = 99999999999999999
			Chat"PSYCHOTIC"
			wait(1)
			Chat"*&$(**&$(*&T(8948794"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[PSYCHO] YOU CAN RUN BUT NOT HIDE!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Splits')then 
			changeMode'Relax'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 1000000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Relax] ;)", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='DESTROYED')then 
			changeMode'SHATTERED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000
			Chat2"I WILL SHRED THE THIS WORLD TO ITS CORE"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[SHATTERED] I'LL SHRED THIS EARTH DOWN TO ITS CORE.", "All")
else
end

		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='PSYCHO')then 
			changeMode'CURED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000
						Chat"How the tables turn."
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CURED] How the tables turn.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.E and Mode=='L0st')then 
			changeMode'disintegrated'
			game.lighting.ClockTime = 2
			game.lighting.FogEnd = 600
			Chat"Faded..."
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[disintegrated] faded", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.T and Mode=='disintegrated')then 
			changeMode'ENDLESS SILENCE'
game.lighting.ClockTime = 1
			game.lighting.FogEnd = 300
			Chat"Silence eternally"
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ETERNAL SILENCE] THIS IS THE LAST STRAW!", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='L0st')then 
			changeMode'BYE BYE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000
					if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[BYE BYE] My bodys looking wrong.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='PSYCHO')then 
			changeMode'MENTALLY INSANE'
			game.lighting.ClockTime = 3
			game.lighting.FogEnd = 200
			Chat"GIVE HELP PLEASE SAVE HEFKJH$IUF..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[MENTALLY INSANE] HELP M$(*&(*", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.U and Mode=='L0st')then 
			changeMode''
			game.lighting.ClockTime = 4
			game.lighting.FogEnd = 600	
		    Chat"Horrifing.."
			if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[SPOOKITYS] Horrifing.", "All")
else
end
		elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Inferno')then 
			changeMode'Hydro'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 600000000000
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Hydro] The sea is mine to command!", "All")
else
    end
				elseif(io.KeyCode == Enum.KeyCode.N and Mode~='Inferno')then 
			changeMode'Inferno'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 60000000000000
			Chat2"BURN, BURN!!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Inferno] BURN, BURN!", "All")
else
    end
			--TOGGLE MUSIC
		elseif(io.KeyCode == Enum.KeyCode.M and getMode(Mode))then 
			MusicMode=MusicMode+1
			if(MusicMode>3)then MusicMode=1 end
			if(MusicMode==1)then
				music:Pause()
				music.Volume=5
				music.Parent=Torso
				music:Resume()
			elseif(MusicMode==2)then
				music:Pause()
				music.Volume=5
				music.Parent=Char
				music:Resume()
			elseif(MusicMode==3)then
				music.Volume = 0
			end
		elseif(io.KeyCode==Enum.KeyCode.B)then
			--TAUNTS
			if(vaporwaveMode and Mode=='Troubadour')then
				VaporTaunt()
			end
		end
		if(vaporwaveMode)then return end
		--ATTACKS
		if(io.UserInputType==Enum.UserInputType.MouseButton1)then
			ClickCombo()
		end
	end)

	WingAnims.NebG1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(3.5,4,-.0)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-90)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(3.5,4,-.0)*CF.A(M.R(170+-6000*M.C(WingSine/322)),0,M.R(-90)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+150*M.C(WingSine/32)),0,M.R(30+400*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3.5,4,-.0)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-90)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3.5,4,-.0)*CF.A(M.R(170+-6000*M.C(WingSine/322)),0,M.R(-90)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+150*M.C(WingSine/32)),0,M.R(-30-400*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	end
		WingAnims.Solaris=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4.9,-2,-1)*CF.A(M.R(5+700*M.C(WingSine/100)),0,M.R(0+300*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(5.8,-1,-1)*CF.A(M.R(10+700*M.C(WingSine/100)),0,M.R(15+300*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.7,.5,-1)*CF.A(M.R(15+700*M.C(WingSine/100)),0,M.R(30+300*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4.9,-2,-1)*CF.A(M.R(5+700*M.C(WingSine/100)),0,M.R(0-300*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-5.8,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+700*M.C(WingSine/100)),0,M.R(-15-300*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.7,.5,-1)*CF.A(M.R(15+700*M.C(WingSine/100)),0,M.R(-30-300*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
		WingAnims.Blood=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,3,5)*CF.A(M.R(100+6000*M.C(WingSine/322)),0,M.R(-40)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,6,5)*CF.A(M.R(0+-6000*M.C(WingSine/322)),0,M.R(-40)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,9,5)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-40)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,5)*CF.A(M.R(100+6000*M.C(WingSine/322)),0,M.R(40)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,6,5)*CF.A(M.R(0+-6000*M.C(WingSine/322)),0,M.R(40)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,9,5)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(40)),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end

	WingAnims.NebG2=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15*M.C(WingSine/32),1.5+.35*M.S(WingSine/32),-1)*CF.A(0,0,M.R(60+50*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1*M.C(WingSine/32),1.5+.25*M.C(WingSine/32),-1)*CF.A(0,0,M.R(90+23.50*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),1.5-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(120-50*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15*M.C(WingSine/32),1.5-.15*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-60-50*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1*M.C(WingSine/32),1.5+.3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-90-23.50*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),1.5+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-120+50*M.C(WingSine/32))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.NebG3=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+-8345*M.C(WingSine/600))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+6042*M.C(WingSine/600))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+-6523*M.C(WingSine/600))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+7425*M.C(WingSine/600))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(-120+-5357*M.C(WingSine/600))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+8547*M.C(WingSine/600))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Hell=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),6,4)*CF.A(M.R(0+-6000*M.C(WingSine/322)),10,M.R(10-720*M.C(WingSine/200))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),6,4)*CF.A(M.R(120+-6000*M.C(WingSine/322)),10,M.R(0-720*M.C(WingSine/200))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),6,4)*CF.A(M.R(240+-6000*M.C(WingSine/322)),10,M.R(0-720*M.C(WingSine/200))),.2)
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),1,4)*CF.A(M.R(0+10000*M.C(WingSine/222)),10,M.R(0-720*M.C(WingSine/200))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),1,4)*CF.A(M.R(120+10000*M.C(WingSine/222)),10,M.R(0-720*M.C(WingSine/200))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0+0*M.C(WingSine/90),1,4)*CF.A(M.R(240+10000*M.C(WingSine/222)),10,M.R(0-720*M.C(WingSine/200))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Mythic=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.S(WingSine/32),-1)*CF.A(0,0,M.R(60+180*M.C(WingSine/52))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.C(WingSine/32),-1)*CF.A(0,0,M.R(90+180*M.C(WingSine/52))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180+180*M.C(WingSine/52))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.C(WingSine/32),-1)*CF.A(0,0,M.R(120+180*M.C(WingSine/52))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.S(WingSine/32),-1)*CF.A(0,0,M.R(150+180*M.C(WingSine/52))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-5*M.C(WingSine/32),2.5+0*M.S(WingSine/32),-1)*CF.A(0,0,M.R(210+180*M.C(WingSine/52))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.GEO=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-4,2)*CF.A(M.R(200+-10*M.C(WingSine/32)),0,M.R(0+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,2)*CF.A(M.R(200+-15*M.C(WingSine/32)),0,M.R(-15+0*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(-100+20*M.C(WingSine/32)),0,M.R(30+150*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-4,2)*CF.A(M.R(200+-10*M.C(WingSine/32)),0,M.R(0-0*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,2+.05*M.S(WingSine/35))*CF.A(M.R(200+-15*M.C(WingSine/32)),0,M.R(15-0*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(-100+20*M.C(WingSine/32)),0,M.R(-30-150*M.C(WingSine/32))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
		WingAnims.Toxicities=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0*M.C(WingSine/32),1.5+100*M.S(WingSine/32),-1)*CF.A(0,0,M.R(90+144*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(5+5*M.C(WingSine/32),1.5+.25*M.C(WingSine/32),-1)*CF.A(0,0,M.R(90+1000*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(5+5*M.C(WingSine/32),1.5-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180+1000*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0*M.C(WingSine/32),1.5+100*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-90+720*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(5+5*M.C(WingSine/32),1.5+.3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-90+1000*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(5+5*M.C(WingSine/32),1.5+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(0+1000*M.C(WingSine/32))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Calam=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,4,-6)*CF.A(1,M.R(0+2.5*M.C(WingSine/36)),M.R(0+2000*M.C(WingSine/400))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,4,-1)*CF.A(2,M.R(0+7.5*M.C(WingSine/32)),M.R(60+2000*M.C(WingSine/400))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(1,4,-6)*CF.A(1,M.R(0+5*M.C(WingSine/39)),M.R(120+2000*M.C(WingSine/400))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(1,4,-1)*CF.A(2,M.R(0+2.5*M.C(WingSine/36)),M.R(180+2000*M.C(WingSine/400))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(1,4,-6)*CF.A(1,M.R(0+7.5*M.C(WingSine/32)),M.R(240+2000*M.C(WingSine/400))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(1,4,-1)*CF.A(2,M.R(0+5*M.C(WingSine/39)),M.R(300+2000*M.C(WingSine/400))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.SPACETIME=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(3.5,1,-.9)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(3.5,1,-.9)*CF.A(M.R(120+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(3.5,1,-.9)*CF.A(M.R(240+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3.5,1,-.9)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3.5,1,-.9)*CF.A(M.R(120+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-3.5,1,-.9)*CF.A(M.R(240+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Worm=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(3.5,3,-.9)*CF.A(M.R(0+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(3.5,3,-.9)*CF.A(M.R(120+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(3.5,3,-.9)*CF.A(M.R(240+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3.5,3,-.9)*CF.A(M.R(0+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3.5,3,-.9)*CF.A(M.R(120+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-3.5,3,-.9)*CF.A(M.R(240+6000*M.C(WingSine/1300)),0,M.R(-90)),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Doom=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+2.5*M.C(WingSine/36)),M.R(60+20000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+7.5*M.C(WingSine/32)),M.R(120+25000*M.C(WingSine/2000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+5*M.C(WingSine/39)),M.R(180+30000*M.C(WingSine/3000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+35000*M.C(WingSine/4000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+7.5*M.C(WingSine/32)),M.R(-120+40000*M.C(WingSine/5000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(2,M.R(0+5*M.C(WingSine/39)),M.R(-1+45000*M.C(WingSine/6000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Dead=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(3+2.5*M.C(WingSine/36)),M.R(0+-8000*M.C(WingSine/900))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(6+7.5*M.C(WingSine/32)),M.R(60+-8000*M.C(WingSine/900))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(3+5*M.C(WingSine/39)),M.R(120+-8000*M.C(WingSine/900))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(3+2.5*M.C(WingSine/36)),M.R(180+8000*M.C(WingSine/900))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(6+7.5*M.C(WingSine/32)),M.R(240+8000*M.C(WingSine/900))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(2,1.5,-4)*CF.A(-7.3,M.R(3+5*M.C(WingSine/39)),M.R(300+8000*M.C(WingSine/900))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Bruh=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+5000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-120+5000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+5000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Solid=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+5000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-120+5000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,-8,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+5000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Destruction=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+3000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+3000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+3000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+3000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(-120+3000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+3000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Notnormal=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+5000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-120+5000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+5000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
		WingAnims.normal=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+7.5*M.C(WingSine/32)),M.R(120+5000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+7.5*M.C(WingSine/32)),M.R(-120+5000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(4,-1,-1)*CF.A(-5,M.R(0+5*M.C(WingSine/39)),M.R(-1+5000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Cata=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(60+-3000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(120+3000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(180+3000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(-60+3000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(-120+-3000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/20)),M.R(-1+3000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Glitch=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(200+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(100+15*M.C(WingSine/32)),0,M.R(15+40*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(1,-2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/1))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(200+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(100+15*M.C(WingSine/32)),0,M.R(-15-40*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-1,-2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-0-5*M.C(WingSine/1))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Cataclysm=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(60+-20000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(120+20000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(180+20000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(-60+20000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(-120+-20000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(0,M.R(0+5*M.C(WingSine/5)),M.R(-1+20000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Star2=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+20*M.C(WingSine/5)),M.R(60+-43363*M.C(WingSine/10))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,10,-1)*CF.A(0,M.R(0+20*M.C(WingSine/5)),M.R(120+-34633*M.C(WingSine/10))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+50*M.C(WingSine/5)),M.R(180+23452*M.C(WingSine/10))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,10,-1)*CF.A(0,M.R(0+20*M.C(WingSine/5)),M.R(-60+-63235*M.C(WingSine/10))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,5,-1)*CF.A(0,M.R(0+20*M.C(WingSine/5)),M.R(-120+13451*M.C(WingSine/10))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,10,-1)*CF.A(0,M.R(0+20*M.C(WingSine/5)),M.R(-1+43225*M.C(WingSine/10))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/5))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/5))),.2)
	end
	WingAnims.Star3=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,3)*CF.A(M.R(200+7.5*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-3,-1)*CF.A(M.R(200+10*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-3)*CF.A(M.R(15+200*M.C(WingSine/32)),0,M.R(30+200*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,3)*CF.A(M.R(200+7.5*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-3,-1+.05*M.S(WingSine/35))*CF.A(M.R(200+10*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-3)*CF.A(M.R(15+200*M.C(WingSine/32)),0,M.R(-30-200*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Star1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15*M.C(WingSine/32),1.5+1*M.S(WingSine/32),-1)*CF.A(0,0,M.R(160+400*M.C(WingSine/52))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1*M.C(WingSine/32),2.5+2*M.C(WingSine/32),-1)*CF.A(0,0,M.R(170+400*M.C(WingSine/52))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),3.5+3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180-400*M.C(WingSine/52))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15*M.C(WingSine/32),1.5+1*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-160-400*M.C(WingSine/52))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1*M.C(WingSine/32),2.5+2*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-170-400*M.C(WingSine/52))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),3.5+3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-180+400*M.C(WingSine/52))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Lost=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/12)),0,M.R(0+5*M.C(WingSine/2))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/22)),0,M.R(15+7.5*M.C(WingSine/42))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/23)),0,M.R(0-5*M.C(WingSine/12))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/2)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/22))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Destiny=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.FORCE=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(5,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(60+567*M.C(WingSine/334))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(2,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(120+543*M.C(WingSine/333))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(5,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(180+745*M.C(WingSine/234))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-7,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(240+453*M.C(WingSine/445))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-2,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(300+645*M.C(WingSine/343))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-5,2+5*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(360+565*M.C(WingSine/328))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PULSE=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2+-2*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(-90+1000*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2+-2*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(90+1000*M.C(WingSine/400))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,6,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0,2+2*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(180+1000*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0,2+2*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(0+1000*M.C(WingSine/400))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,6,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Things=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(40+10*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(90+-10*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(140+10*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-2+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-3)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Error303=function()
		LWP1W.C0 = LWP2W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-120-70*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-60-50*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+40*M.C(WingSine/10))),.2)

		RWP1W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(120+70*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(60+50*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+40*M.C(WingSine/10))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-100*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-100*M.C(WingSine/80))),.2)
	end
	
		WingAnims.HAHAHA1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,-10,-1)*CF.A(M.R(50+100*M.C(WingSine/22)),2,M.R(59+400*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,-10,-1)*CF.A(M.R(50+100*M.C(WingSine/22)),2,M.R(20.5+400*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/22)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-10,-1)*CF.A(M.R(50+100*M.C(WingSine/22)),2,M.R(-59+400*M.C(WingSine/50))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0,-10,-1)*CF.A(M.R(50+100*M.C(WingSine/22)),2,M.R(-20.5+400*M.C(WingSine/50))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/22)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.GENOCIDE=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(120+80*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(120+50*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-2,-0)*CF.A(M.R(-80+0*M.C(WingSine/32)),0,M.R(70+2*M.C(WingSine/1))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-120-80*M.C(WingSine/50))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-120-50*M.C(WingSine/50))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6,-4,-1)*CF.A(M.R(30+500*M.C(WingSine/32)),2,M.R(30+400*M.C(WingSine/63))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PEST1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(5,0,-1)*CF.A(M.R(-90+0*M.C(WingSine/32)),0,M.R(89+600*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(5,-5,-1)*CF.A(M.R(-90+0*M.C(WingSine/32)),0,M.R(89+600*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(50+50*M.C(WingSine/32)),0,M.R(89+600*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(5,0,-1)*CF.A(M.R(-90+0*M.C(WingSine/32)),0,M.R(-89+600*M.C(WingSine/50))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(5,-5,-1)*CF.A(M.R(-90+0*M.C(WingSine/32)),0,M.R(-89+600*M.C(WingSine/50))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(50+50*M.C(WingSine/32)),0,M.R(-89+600*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.ZENITH=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(100+-50*M.C(WingSine/10))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(7,-1,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(100+50*M.C(WingSine/10))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+32*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-100+50*M.C(WingSine/10))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-7,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-100-50*M.C(WingSine/10))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+32*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PROESTGAMER=function()
			LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,7,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+5000*M.C(WingSine/400)))*CF.A(20.5,M.R(2),0)*CF.N(-0,4,0),.2)
	        LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,7,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(90+5000*M.C(WingSine/400)))*CF.A(20.5,M.R(2),0)*CF.N(-0,4,0),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(4.8,2,0-0*M.C(WingSine/500))*CF.A(M.R(180+9000*M.C(WingSine/500)),-9.5,M.R(-90)),.2)

			RWP1W.C0 = RWP1W.C0:lerp(CF.N(1,7,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-180+5000*M.C(WingSine/400)))*CF.A(20.5,M.R(2),0)*CF.N(-0,4,0),.2)
	        RWP2W.C0 = RWP2W.C0:lerp(CF.N(1,7,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(-90+5000*M.C(WingSine/400)))*CF.A(20.5,M.R(2),0)*CF.N(-0,4,0),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-4.8,2,0+0*M.C(WingSine/250))*CF.A(M.R(-180-9000*M.C(WingSine/500)),9.5,M.R(90)),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PUNISHED=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-6,-6,-1)*CF.A(M.R(60+200*M.C(WingSine/32)),2,M.R(60+200*M.C(WingSine/45))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-6,-4,-1)*CF.A(M.R(30+200*M.C(WingSine/32)),2,M.R(30+400*M.C(WingSine/63))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-6.5,3,-1)*CF.A(M.R(0+100*M.C(WingSine/32)),20,M.R(30+600*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Question=function()
    LWP1W.C0 = LWP1W.C0:lerp(CF.N(1.15*M.C(WingSine/52),3+3.25*M.S(WingSine/32),-1)*CF.A(45,0,M.R(260+425*M.C(WingSine/62))),.2)
    LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.1*M.C(WingSine/52),3+2.28*M.C(WingSine/32),-1)*CF.A(45,0,M.R(390+465.5*M.C(WingSine/62))),.2)
    LWP3W.C0 = LWP3W.C0:lerp(CF.N(1.25*M.C(WingSine/52),1+5*M.S(WingSine/32),-1)*CF.A(45,0,M.R(120+315*M.C(WingSine/62))),.2)
    
    RWP1W.C0 = RWP1W.C0:lerp(CF.N(2.15*M.C(WingSine/52),4+2.15*M.C(WingSine/32),-1)*CF.A(45,0,M.R(-260+545*M.C(WingSine/62))),.2)
    RWP2W.C0 = RWP2W.C0:lerp(CF.N(2.1*M.C(WingSine/52),4+2.3*M.S(WingSine/32),-1)*CF.A(45,0,M.R(-390+434.5*M.C(WingSine/62))),.2)
    RWP3W.C0 = RWP3W.C0:lerp(CF.N(2.25*M.C(WingSine/52),2+5*M.S(WingSine/32),-1)*CF.A(45,0,M.R(-120+475*M.C(WingSine/62))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PERSON=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(-0-5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(-0-5*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.GSWORD=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-1.3,0,1.8)*CF.A(M.R(100+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-1.3,5,1.8)*CF.A(M.R(100+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(1,1,5)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(180+0*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1.3,10,1.8)*CF.A(M.R(100+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.3,15,1.8)*CF.A(M.R(100+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-1,2,5)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-360+0*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.UNMERCIFUL1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-3,1,-1)*CF.A(M.R(0+-6000*M.C(WingSine/160)),0,M.R(-90)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-3,1,-1)*CF.A(M.R(170+-6000*M.C(WingSine/160)),0,M.R(-90)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-4,1,-1)*CF.A(M.R(170+-6000*M.C(WingSine/190)),0,M.R(-90)),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3,4,-1)*CF.A(M.R(0+6000*M.C(WingSine/160)),0,M.R(-90)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3,4,-1)*CF.A(M.R(170+6000*M.C(WingSine/160)),0,M.R(-90)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-4,1,-1)*CF.A(M.R(340+-6000*M.C(WingSine/190)),0,M.R(-90)),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	end
	
	
		WingAnims.Star7=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+-20*M.C(WingSine/5))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(5,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+30*M.C(WingSine/5))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(7,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+-40*M.C(WingSine/5))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+20*M.C(WingSine/5))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-5,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-30*M.C(WingSine/5))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30+40*M.C(WingSine/5))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Atomic=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-2,-4)*CF.A(M.R(0+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(100+50*M.C(WingSine/32)),0,M.R(15+0*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+2000*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,-2,-4)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(100+50*M.C(WingSine/32)),0,M.R(-15-0*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+2000*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.EMPTY=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(400,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(400,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(400,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-400,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-400,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-400,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.LC1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(1.3,-6,-1)*CF.A(M.R(40+0*M.C(WingSine/32)),0,M.R(-20+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.3,-6.1,-0.7)*CF.A(M.R(40+0*M.C(WingSine/32)),0,M.R(-20+0*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(1.3,-8,-1.3)*CF.A(M.R(30+5*M.C(WingSine/32)),0,M.R(-20-5*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(1.3,-6.2,-0.4)*CF.A(M.R(40+0*M.C(WingSine/32)),0,M.R(-20+0*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(1.3,-6.7,-0.7)*CF.A(M.R(40+0*M.C(WingSine/32)),0,M.R(-20+0*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.3,-8.2,-0.1)*CF.A(M.R(50+-5*M.C(WingSine/32)),0,M.R(-20+5*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Echo1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(300,1.2,-1.8)*CF.A(M.R(100+0*M.C(WingSine/32)),-0.4,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(300,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(300,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(300,-2,-2)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(300,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(300,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end

		WingAnims.Echo2=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(1.3,0.5,1.5)*CF.A(M.R(100+0*M.C(WingSine/32)),0,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(300,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(300,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(300,-2,-2)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(300,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(300,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.isgonnahappensoon=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/64))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(50+15*M.C(WingSine/64)),0,M.R(15+10*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/300))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(0+5*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/64))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(50+15*M.C(WingSine/64)),0,M.R(-15-10*M.C(WingSine/32))),.2)
			RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/300))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.FIGHT=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(6,-2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(6,-1,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(70+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89-300*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-6,-2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-6,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-70-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89-900*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end

		WingAnims.REMEMBER=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,3,-3)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+700*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0.5,1,2)*CF.A(M.R(650+0*M.C(WingSine/32)),0,M.R(70+0*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-3)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89-700*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,-3,-2)*CF.A(M.R(15+5*M.C(WingSine/32)),0,M.R(-0-0*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.LIGHTSPEED=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(-4,2,0-0*M.C(WingSine/500))*CF.A(M.R(0+9000*M.C(WingSine/500)),-40,M.R(-90)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(-4,2,0-0*M.C(WingSine/500))*CF.A(M.R(180+9000*M.C(WingSine/500)),-40,M.R(-90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(-4,2,0-0*M.C(WingSine/500))*CF.A(M.R(360+9000*M.C(WingSine/500)),-40,M.R(-90)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(4,2,0+0*M.C(WingSine/250))*CF.A(M.R(0-9000*M.C(WingSine/500)),-44.8,M.R(90)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(4,2,0+0*M.C(WingSine/250))*CF.A(M.R(180-9000*M.C(WingSine/500)),-44.8,M.R(90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(4,2,0+0*M.C(WingSine/250))*CF.A(M.R(360-9000*M.C(WingSine/500)),-44.8,M.R(90)),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.LOST2=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1*M.C(WingSine/32),-7.7+2*M.S(WingSine/32),2)*CF.A(-1,0,M.R(60+10*M.C(WingSine/42))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1*M.C(WingSine/32),-7.7+2*M.C(WingSine/32),2)*CF.A(-1,0,M.R(110+10*M.C(WingSine/42))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-2,-0)*CF.A(M.R(80+0*M.C(WingSine/32)),0,M.R(70+2*M.C(WingSine/1))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1*M.C(WingSine/32),-7.7+2*M.C(WingSine/32),2)*CF.A(-1,0,M.R(-60-10*M.C(WingSine/42))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1*M.C(WingSine/32),-7.7+2*M.S(WingSine/32),2)*CF.A(-1,0,M.R(-110-10*M.C(WingSine/42))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-1*M.C(WingSine/32),-999.7+2*M.S(WingSine/32),2)*CF.A(-1,0,M.R(-10-10*M.C(WingSine/42))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-0.80+0*M.S(WingSine/6),-999)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-0.64+0*M.S(WingSine/6),-999)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.PLATFORM=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1.8,2,0-0*M.C(WingSine/500))*CF.A(M.R(0+9000*M.C(WingSine/500)),7.8,M.R(-90)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.8,2,0-0*M.C(WingSine/500))*CF.A(M.R(60+9000*M.C(WingSine/500)),7.8,M.R(-90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(1.8,2,0-0*M.C(WingSine/500))*CF.A(M.R(120+9000*M.C(WingSine/500)),7.8,M.R(-90)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1.8,2,0+0*M.C(WingSine/250))*CF.A(M.R(0-9000*M.C(WingSine/500)),-7.8,M.R(90)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.8,2,0+0*M.C(WingSine/250))*CF.A(M.R(240-9000*M.C(WingSine/500)),-7.8,M.R(90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-1.8,2,0+0*M.C(WingSine/250))*CF.A(M.R(300-9000*M.C(WingSine/500)),-7.8,M.R(90)),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-100+0*M.S(WingSine/6),-2)*CF.A(500,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-100+0*M.S(WingSine/6),-2)*CF.A(500,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Sword1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-1.3,.4,2)*CF.A(M.R(100+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0,-2,-2)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.NUKE=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0-3*M.C(WingSine/100),1+-5*M.S(WingSine/32),-1)*CF.A(0,0,M.R(0+510*M.C(WingSine/100))),.2)
        LWP2W.C0 = LWP2W.C0:lerp(CF.N(0-3*M.C(WingSine/50),1-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(0+0*M.C(WingSine/100))),.2)
        LWP3W.C0 = LWP3W.C0:lerp(CF.N(0+3*M.C(WingSine/50),1-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(0+0*M.C(WingSine/100))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0+3*M.C(WingSine/100),1+5*M.C(WingSine/32),-1)*CF.A(0,0,M.R(0+510*M.C(WingSine/100))),.2)
    	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0-3*M.C(WingSine/50),1+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180+0*M.C(WingSine/100))),.2)
    	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0+3*M.C(WingSine/50),1+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180+0*M.C(WingSine/100))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.OMEGA=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89-40*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+40*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89-40*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+40*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
	WingAnims.Star1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15*M.C(WingSine/32),1.5+1*M.S(WingSine/32),-1)*CF.A(0,0,M.R(160+400*M.C(WingSine/52))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1*M.C(WingSine/32),2.5+2*M.C(WingSine/32),-1)*CF.A(0,0,M.R(170+400*M.C(WingSine/52))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),3.5+3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(180-400*M.C(WingSine/52))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15*M.C(WingSine/32),1.5+1*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-160-400*M.C(WingSine/52))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1*M.C(WingSine/32),2.5+2*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-170-400*M.C(WingSine/52))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),3.5+3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-180+400*M.C(WingSine/52))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	WingAnims.Lost=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/12)),0,M.R(0+5*M.C(WingSine/2))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/22)),0,M.R(15+7.5*M.C(WingSine/42))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/23)),0,M.R(0-5*M.C(WingSine/12))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/2)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/22))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.WITHERED=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,4,-1)*CF.A(1.1,M.R(0+2.5*M.C(WingSine/36)),M.R(60+9000*M.C(WingSine/1000))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,4,-1)*CF.A(1.1,M.R(0+7.5*M.C(WingSine/32)),M.R(120+9000*M.C(WingSine/1000))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(2,6,-1)*CF.A(1,M.R(0+5*M.C(WingSine/39)),M.R(180+-5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(1,4,-1)*CF.A(1.1,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+9000*M.C(WingSine/1000))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(1,4,-1)*CF.A(1.1,M.R(0+2.5*M.C(WingSine/36)),M.R(-120+9000*M.C(WingSine/1000))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(2,6,-1)*CF.A(1,M.R(0+5*M.C(WingSine/39)),M.R(-1+-5000*M.C(WingSine/1000))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
	
		WingAnims.SYS32=function()
        LWP1W.C0 = LWP1W.C0:lerp(CF.N(3*M.C(WingSine/52),3.2+.1*M.S(WingSine/32),-3)*CF.A(-4.2,0,M.R(380+3500*M.C(WingSine/232))),.2)
        LWP2W.C0 = LWP2W.C0:lerp(CF.N(4*M.C(WingSine/42),1.2+1*M.C(WingSine/42),-1)*CF.A(-4.2,0.1,M.R(180+555*M.C(WingSine/62))),.2)
        LWP3W.C0 = LWP3W.C0:lerp(CF.N(4*M.C(WingSine/42),5.2+1*M.S(WingSine/42),-2)*CF.A(-4,0.1,M.R(150+1555*M.C(WingSine/162))),.2)

        RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3*M.C(WingSine/52),3.2-.1*M.C(WingSine/32),-3)*CF.A(-4.2,0,M.R(-380-3500*M.C(WingSine/232))),.2)
        RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4*M.C(WingSine/42),1.2+1*M.S(WingSine/42),-1)*CF.A(-4.2,-0.1,M.R(-180-555*M.C(WingSine/62))),.2)
        RWP3W.C0 = RWP3W.C0:lerp(CF.N(-4*M.C(WingSine/42),5.2+1*M.S(WingSine/42),-2)*CF.A(-4,-0.1,M.R(-150-1555*M.C(WingSine/162))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Cave=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+-5*M.C(WingSine/1))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+5*M.C(WingSine/1))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+-5*M.C(WingSine/1))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5*M.C(WingSine/1))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-120+5*M.C(WingSine/1))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-1+-5*M.C(WingSine/1))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Future=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(60+1000*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(120+1000*M.C(WingSine/400))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(180+1000*M.C(WingSine/400))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(240+1000*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(300+1000*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(360+1000*M.C(WingSine/400))),.2)
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Atoms=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,-8,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/60))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(100+100*M.C(WingSine/20))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,-6,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+200*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-8,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/60))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-100-100*M.C(WingSine/20))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,-6,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89-200*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.Dimension=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+75*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+50*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+75*M.C(WingSine/50))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+50*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
	
		WingAnims.BLACKHOLE=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(3.5,1,-0)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(3.5,1,-0)*CF.A(M.R(170+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,4,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+500*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3.5,1,-0)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3.5,1,-0)*CF.A(M.R(170+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+500*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.KRAZY=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(90+3000*M.C(WingSine/100))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(147.5+3000*M.C(WingSine/100))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5-.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(32.5+3000*M.C(WingSine/100))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5-.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(-90+3000*M.C(WingSine/100))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(-147.5+3000*M.C(WingSine/100))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(-32.5+3000*M.C(WingSine/100))),.2)
    	--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end


		WingAnims.Liquid=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(5,-1,-1)*CF.A(M.R(10+500*M.C(WingSine/100)),0,M.R(15+500*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,7,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-5,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+500*M.C(WingSine/100)),0,M.R(-15-500*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,7,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.LIES=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1*M.C(WingSine/32),-5.5+1*M.S(WingSine/32),3)*CF.A(-1,0,M.R(90+10*M.C(WingSine/42))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1*M.C(WingSine/32),-5.5+1*M.C(WingSine/32),3)*CF.A(-1,0,M.R(120+10*M.C(WingSine/42))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(1*M.C(WingSine/32),-5.5+1*M.S(WingSine/32),3)*CF.A(-1,0,M.R(60+10*M.C(WingSine/42))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1*M.C(WingSine/32),-5.5+1*M.C(WingSine/32),3)*CF.A(-1,0,M.R(-90-10*M.C(WingSine/42))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1*M.C(WingSine/32),-5.5+1*M.S(WingSine/32),3)*CF.A(-1,0,M.R(-120-10*M.C(WingSine/42))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-1*M.C(WingSine/32),-5.5+1*M.S(WingSine/32),3)*CF.A(-1,0,M.R(-60-10*M.C(WingSine/42))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-1000*M.C(WingSine/220))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-1000*M.C(WingSine/220))),.2)
	end
		WingAnims.ihavenothingtodo=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,-5.7,-3.0)*CF.A(M.R(10+0*M.C(WingSine/32)),14.1,M.R(175+2*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-5.7,-3.0)*CF.A(M.R(10+0*M.C(WingSine/32)),14.1,M.R(175+2*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(1,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(1,-5.7,3.0)*CF.A(M.R(10+0*M.C(WingSine/32)),14.1,M.R(175+2*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,-5.7,3.0)*CF.A(M.R(10+0*M.C(WingSine/32)),14.1,M.R(175+2*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
		end

		WingAnims.DELETE=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(2,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(3,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(1,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-2,-2,1.7)*CF.A(M.R(90+0*M.C(WingSine/32)),14.1,M.R(0+2*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/1000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	end
		WingAnims.Hyposis=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+400*M.C(WingSine/16))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-400*M.C(WingSine/16))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15+400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Hypnotic=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+300*M.C(WingSine/32)),0,M.R(0+300*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(100+300*M.C(WingSine/32)),0,M.R(15+300*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+300*M.C(WingSine/32)),0,M.R(30+300*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+300*M.C(WingSine/32)),0,M.R(0+300*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(100+300*M.C(WingSine/32)),0,M.R(-15+300*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+300*M.C(WingSine/32)),0,M.R(-30+300*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.bot3=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+200*M.C(WingSine/32)),0,M.R(0+200*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+200*M.C(WingSine/32)),0,M.R(30+100*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+200*M.C(WingSine/32)),0,M.R(0-200*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+200*M.C(WingSine/32)),0,M.R(-30-100*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.bot2=function()
            LWP1W.C0 = LWP1W.C0:lerp(CF.N(-3,-3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.2)
            LWP2W.C0 = LWP2W.C0:lerp(CF.N(-3,-3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(90+WingSine)),.2)
            LWP3W.C0 = LWP3W.C0:lerp(CF.N(1,1.5+5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(0+5000*M.C(WingSine/200))),.2)

            RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3,-3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(180+WingSine)),.2)
            RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3,-3,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-90+WingSine)),.2)
            RWP3W.C0 = RWP3W.C0:lerp(CF.N(1,1.5+5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/200))),.2)
    RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1)*CF.A(0,0,M.R(-0-950*M.C(WingSine/402))),.2)
    RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/402))),.2) 
	end
	WingAnims.bot=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(7.25,-1,-1)*CF.A(M.R(10+100*M.C(WingSine/32)),-2,M.R(15+100*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+125*M.C(WingSine/32)),-2,M.R(15+125*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(10.25,-1,-1)*CF.A(M.R(10+150*M.C(WingSine/32)),-2,M.R(15+150*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-7.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+100*M.C(WingSine/32)),2,M.R(-15-100*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+125*M.C(WingSine/32)),2,M.R(-15-125*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-10.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+150*M.C(WingSine/32)),2,M.R(-15-150*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Spookbday=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(6.5,.5,-0.3)*CF.A(M.R(-600+20*M.C(WingSine/32)),0,M.R(30+150*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+100*M.C(WingSine/32)),-2,M.R(15+100*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2,-1)*CF.A(M.R(15+400*M.C(WingSine/32)),0,M.R(30+100*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-6.5,.5,-0.3)*CF.A(M.R(-600+20*M.C(WingSine/32)),0,M.R(-30-150*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+100*M.C(WingSine/32)),2,M.R(-15-100*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,2,-1)*CF.A(M.R(15+400*M.C(WingSine/32)),0,M.R(-30-100*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.xd=function()
		    
		    
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,-4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/1000))),.2)
    	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(0+-1000*M.C(WingSine/400))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-4,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(180+5000*M.C(WingSine/1000))),.2)
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-4,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/1000))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(120+-1000*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,2+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(240+-1000*M.C(WingSine/400))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.bye=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(100+10*M.C(WingSine/32)),0,M.R(0+400*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(100+5*M.C(WingSine/32)),0,M.R(15+100*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-0.5,-1)*CF.A(M.R(15+0*M.C(WingSine/32)),0,M.R(30+400*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(100+10*M.C(WingSine/32)),0,M.R(0-400*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(100+5*M.C(WingSine/32)),0,M.R(-15-100*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,-0.5,-1)*CF.A(M.R(15+0*M.C(WingSine/32)),0,M.R(-30-400*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.hi=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,0,-.9)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-300)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4,0,-.9)*CF.A(M.R(170+6000*M.C(WingSine/322)),0,M.R(-300)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+400*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,0,-.9)*CF.A(M.R(0+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4,0,-.9)*CF.A(M.R(170+6000*M.C(WingSine/322)),0,M.R(-0)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-400*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.nonexistant=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,0,-1)*CF.A(M.R(5+0*M.C(WingSine/32)),0,M.R(-90+5*M.C(WingSine/1))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(100+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+100*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,0,-1)*CF.A(M.R(5+0*M.C(WingSine/32)),0,M.R(90-5*M.C(WingSine/1))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(100+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-100*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(600,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.Shatter=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-1.8,1,-2)*CF.A(M.R(0+-6000*M.C(WingSine/160)),0,M.R(90)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-1.8,1,-2)*CF.A(M.R(170+-6000*M.C(WingSine/160)),0,M.R(90)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-1.7,-6)*CF.A(M.R(0+5*M.C(WingSine/22)),0,M.R(0+5*M.C(WingSine/34))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1.8,4,-2)*CF.A(M.R(0+6000*M.C(WingSine/160)),0,M.R(90)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.8,4,-2)*CF.A(M.R(170+6000*M.C(WingSine/160)),0,M.R(90)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,1.7,6)*CF.A(M.R(176+-5*M.C(WingSine/23)),0,M.R(-0-5*M.C(WingSine/23))),.2)
		--SPIN
        RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),5.0+0.4*M.S(WingSine/32),-1)*CF.A(165,0,M.R(-0-0*M.C(WingSine/80))),.2)
        RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),5.+0.4*M.S(WingSine/32),-0)*CF.A(150,0,M.R(-0-0*M.C(WingSine/80))),.2)
	end
		WingAnims.inf=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-6,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,.5,-1)*CF.A(M.R(15+0*M.C(WingSine/32)),0,M.R(30+5*M.C(WingSine/1))),.2) --Blade master blade

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-6,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,.5,-1)*CF.A(M.R(15+0*M.C(WingSine/32)),0,M.R(-30-5*M.C(WingSine/1))),.2) --Blade master blade
		--SPIN
		

		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end
		WingAnims.mylifeispain=function()
		    
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0.3,M.R(0+20*M.C(WingSine/5)),M.R(60+-43363*M.C(WingSine/10))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0.3,M.R(0+20*M.C(WingSine/5)),M.R(120+-34633*M.C(WingSine/10))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),.6-.30*M.S(WingSine/32),-1)*CF.A(0.3,0,M.R(560-9*M.C(WingSine/32))),.2)
	
		RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,3,-1)*CF.A(0.3,M.R(0+20*M.C(WingSine/5)),M.R(-60+-63235*M.C(WingSine/10))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,3,-1)*CF.A(0.3,M.R(0+20*M.C(WingSine/5)),M.R(-120+13451*M.C(WingSine/10))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),.6+.30*M.S(WingSine/32),-1)*CF.A(0.3,0,M.R(-560+9*M.C(WingSine/32))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
		
				WingAnims.VOID=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(60+100*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(120+100*M.C(WingSine/400))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(180+100*M.C(WingSine/400))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(240+100*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(300+100*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-0,2+-6*M.C(WingSine/1),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(360+100*M.C(WingSine/400))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
				WingAnims.CURED=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(3.8,4,-2)*CF.A(M.R(0+-3000*M.C(WingSine/160)),0,M.R(90)),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(3.8,4,-2)*CF.A(M.R(170+-3000*M.C(WingSine/160)),0,M.R(90)),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-5.8,1,-2)*CF.A(M.R(170+-4000*M.C(WingSine/160)),0,M.R(90)),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3.8,4,-2)*CF.A(M.R(0+3000*M.C(WingSine/160)),0,M.R(90)),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3.8,4,-2)*CF.A(M.R(170+3000*M.C(WingSine/160)),0,M.R(90)),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-5.8,1,-2)*CF.A(M.R(340+-4000*M.C(WingSine/160)),0,M.R(90)),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/7000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0,-2,0)*CF.A(0,M.R(0*M.C(WingSine/7000)),M.R(0-WingSine))*CF.A(20.4,M.R(90),0)*CF.N(-0,3,0),.2)
		end

		WingAnims.Catastophic=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+0*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(60+500*M.C(WingSine/62))),.2)
    	LWP2W.C0 = LWP2W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+0*M.C(WingSine/62),-1)*CF.A(0.5,0,M.R(90+500*M.C(WingSine/62))),.2)
    	LWP3W.C0 = LWP3W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+0*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(210+500*M.C(WingSine/62))),.2)
    	
    	RWP1W.C0 = RWP1W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5-0*M.C(WingSine/62),-1)*CF.A(0.5,0,M.R(120+500*M.C(WingSine/62))),.2)
    	RWP2W.C0 = RWP2W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+0*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(150+500*M.C(WingSine/62))),.2)
    	RWP3W.C0 = RWP3W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+0*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(180+500*M.C(WingSine/62))),.2)
    		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		end
		WingAnims.COMPLETELYLOST=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+1*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(60+1000*M.C(WingSine/52))),.2)
    	LWP2W.C0 = LWP2W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+1*M.C(WingSine/62),-1)*CF.A(0.5,0,M.R(90+1000*M.C(WingSine/52))),.2)
    	LWP3W.C0 = LWP3W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+1*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(210+1000*M.C(WingSine/52))),.2)
    	
    	RWP1W.C0 = RWP1W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5-1*M.C(WingSine/62),-1)*CF.A(0.5,0,M.R(120+1000*M.C(WingSine/52))),.2)
    	RWP2W.C0 = RWP2W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+1*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(150+1000*M.C(WingSine/52))),.2)
    	RWP3W.C0 = RWP3W.C0:lerp(CF.N(5*M.C(WingSine/62),2.5+1*M.S(WingSine/62),-1)*CF.A(0.5,0,M.R(180+1000*M.C(WingSine/52))),.2)
    		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.80+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
		RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/6),-1.64+0*M.S(WingSine/6),-2)*CF.A(0,0,M.R(-0-2000*M.C(WingSine/80))),.2)
	end



	while true do
		swait()
		ClickTimer=math.max(ClickTimer-1,0)
		if(ClickTimer<=0 and Combo~=1)then
			print('reset')
			Combo=1
		end
		Sine=Sine+Change
		hue=hue+1
		if(hue>360)then hue=1 end
		local hitfloor,posfloor = workspace:FindPartOnRayWithIgnoreList(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), {Effects,Char,workspace[Player.Name]})
		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y < -1 and "Fall" or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		Hum.WalkSpeed = WalkSpeed
		local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local sidevelocity = sidevec/Hum.WalkSpeed
		local forwardvelocity = forwardvec/Hum.WalkSpeed

		local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LLeg.CFrame.p,((CFrame.new(LLeg.Position,LLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
		local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RLeg.CFrame.p,((CFrame.new(RLeg.Position,RLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
		if(Mode=='Troubadour' and IsVaporwave(getMode'Troubadour'.Music))then
			vaporwaveMode=true
			text.Text=''
			WingAnim='NebG3'
		else
			if(Mode=='Troubadour')then
				text.Text='Troubadour'
				WingAnim=getMode'Troubadour'.WingAnim
			end
			vaporwaveMode=false
		end

		if(Mode~='Lust' and WingAnim and WingAnims[WingAnim])then
			WingAnims[WingAnim]()
		elseif(Mode=='Lust')then
			if(State=='Idle')then
				WingAnims.LustFrench()
			else
				WingAnims.NebG3(1)	
			end
		elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
			local gay={unpack(WingAnim)};
			table.remove(gay,1)
			WingAnims[WingAnim[1]](unpack(gay))
		else
			WingAnims.NebG1()
		end

		if(Mode=='Troubadour' and NeutralAnims)then
			WingSine=WingSine+(0.1+music.PlaybackLoudness/300)
		else
			WingSine=WingSine+1
		end
		
				if(Mode~='Lightning Cannon' and WingAnim and WingAnims[WingAnim])then
		WingAnims[WingAnim]()
	elseif(Mode=='Lightning Cannon')then
		if(State=='Idle')then
			WingAnims.LC1()
		else
			WingAnims.EMPTY(1)	
		end
	elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
		local gay={unpack(WingAnim)};
		table.remove(gay,1)
		WingAnims[WingAnim[1]](unpack(gay))
	else
		WingAnims.NebG5()
	end

		if(music)then
			if(Mode=='Lightning Cannon')then
				local clr = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1))
				local clr2 = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/950,0,1))
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
			end
		end

		if(Mode=='The Big Black')then
			local pos = Head.Position
			local dist = (camera.CFrame.p-pos).magnitude
			local DropDist = 1
			local IneffectiveDist = 15
			local modifier = dist < DropDist and 1 or dist < IneffectiveDist and (0 - 1) / (IneffectiveDist - DropDist) * (dist - DropDist) + 1 or 0
		end

		if(State == 'Idle')then
			if(Mode=='POWER')then
				local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,15,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
																    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Neon orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='Destiny')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='PULSAR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(25-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Looped Error')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+2*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/32),-0.2)*CF.A(0.9,M.R(-5),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/32),-0)*CF.A(0.9,M.R(-5),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='APCOCLYPTIC')then
				local Alpha = .1
				
								    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/64)),M.R(5),0.5),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(130+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),-0.5),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
			elseif(Mode=='GENOCIDE')then
				local Alpha = .1
				
																								    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	
		if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.3+0*M.C(Sine/32),0)*CF.A(M.R(-50+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.8,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.8,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='PESTILENCE')then
				local Alpha = .1
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(90+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-100-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(100+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='BURNING BRAIN')then
				local Alpha = .1
														     local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0.5+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(200+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.6)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.0-.05*M.C(Sine/32),-0)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ACE-OF-SPADES')then
												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
										    
										    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
					
					BrickColor.new("")
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,7+.5*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(20,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='DESTRUCTION')then
						     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='???')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-25-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(-0.6,M.R(-5),-0.05),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),0.05),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='TIME WARP')then
				local Alpha = .1
				if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-0+10*M.S(Sine/32)),M.R(-0+999*M.C(Sine/80)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

							elseif(Mode=='Nefarious')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/20),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.3)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

											elseif(Mode=='Atomic Collisions')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.4,M.R(-20),0.08),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
											elseif(Mode=='Lightning Cannon')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+2*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(-380-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.1*M.C(Sine/32),-0.3)*CF.A(-0.2,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-20),0.08),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(0,M.R(5+20*M.C(Sine/1)),M.R(-20-20*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(0,M.R(-5),-0.05),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(0,M.R(-5),0.05),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ECHO')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.1*M.C(Sine/10),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+0.4*M.S(Sine/10),0)*CF.A(-0.5,M.R(5+20*M.C(Sine/1)),M.R(-10-20*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+0.4*M.S(Sine/10),0)*CF.A(-0.5,M.R(5-20*M.C(Sine/1)),M.R(10+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(M.R(-18),0,M.R(-1)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(M.R(-18),0,M.R(1)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='THE VOID')then
				local Alpha = .1
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
															elseif(Mode=='FORCE')then
				local Alpha = .1
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
															elseif(Mode=='HYBRID')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
											elseif(Mode=='CLOCKWISE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
											elseif(Mode=='SPEED OF LIGHT')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(0+10*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+0.2*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(160+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.3,.3,-0.5)*CF.A(M.R(30.5+3.5*M.S(Sine/24)),M.R(15),M.R(-8.3)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.5)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='YING-YANG')then
				local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.2,0.2,0.2);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.2,0.2,0.2);
				}	
				

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5+10*M.C(Sine/32)),M.R(40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5-10*M.C(Sine/32)),M.R(-40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-75),0,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='INFINITE')then
				local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				

			elseif(Mode=='Splits')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.6+0*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1.4,-6,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1.4,6,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
				
				
			elseif(Mode=='Sub-Normal')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				
								    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-0-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end

			elseif(Mode=='Normal')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-0-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
							elseif(Mode=='god slayer')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='CMD:_____')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
							elseif(Mode=='CaTAstOphIc')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
elseif(Mode=='Overclocked')then

GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-336+350*M.S(Sine/80)),M.R(-335+330*M.C(Sine/80)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,0,-M.R(0+5*M.C(Sine/1))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.01*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-85-10*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.01*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(85+10*M.C(Sine/32))),Alpha)
			end
					if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-6),M.R(25),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(6),0,0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end

				
			elseif(Mode=='S P A C E T I M E')then
				local Alpha = .1
								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+0.4*M.C(Sine/32),0)*CF.A(M.R(20+3*M.S(Sine/64)),0,0.14),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
				
							elseif(Mode=='')then
				local Alpha = .1
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+0.4*M.C(Sine/32),0)*CF.A(M.R(20+3*M.S(Sine/64)),0,0.14),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(4+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
					RH.C0 = RH.C0:lerp(CF.N(0.4,-1,-0.8)*CF.A(M.R(-63.8+7.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='F0RG0TT3N')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-150+5*M.C(Sine/32)),M.R(-75-2*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='PUNISHED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.1,-0+.3*M.S(Sine/32),-0)*CF.A(M.R(175),M.R(-0),M.R(25-4*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.3*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-4*M.C(Sine/32)),M.R(-25-4*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
							elseif(Mode=='INEVITABLE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/64)),M.R(5),-10.),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(180+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(-1.5,M.R(-5),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
							elseif(Mode=='L')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='PLATFORM')then
							    
											    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,8,0),
Size = Vector3.new(.5,0,0.5),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(85+10*M.S(Sine/64)),M.R(5),0),Alpha)  
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-190-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(190+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1.2,M.R(-5),-0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.6,M.R(-5),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='EXCALIBUR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.0*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='EXCALIBUR X')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

							elseif(Mode=='OMEGA')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='SYSTEM_32')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-60),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-60),0,M.R(5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='bored')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+0*M.C(Sine/32),-0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='Deleterious')then
							    
							    										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.7*M.C(Sine/32),-0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Liar X')then
																									    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}	    
										    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.3,.3,-0.5)*CF.A(M.R(30.5+3.5*M.S(Sine/24)),M.R(15),M.R(-8.3)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.5)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='HYPNOTIC')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+5*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ARCADE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='ILLUSION')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(5,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='I N S A N E')then
							    
							    
							    				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.9,3,0.9),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
							    
							    																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
												    																																		GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='PSYCHO')then
										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
							    
							    																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
												    																																		GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Volcanic')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(-50-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='DIMENSIONAL')then
				local Alpha = .1
				if(NeutralAnims)then
				    				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
												GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(-50-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Inferno')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    
												    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Neon orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='FUTURE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lilac'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(-40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='CRAZED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Navy blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Hydro')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2*M.C(Sine/32),0)*CF.A(M.R(-40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.05*M.C(Sine/32),-1)*CF.A(150,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(100,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='ENDLESS SILENCE')then
				local Alpha = .1
				if(NeutralAnims)then	
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,12+2*M.C(Sine/32),0)*CF.A(M.R(-35+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-155-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='SHATTERED')then
							    
							    				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-80,80),-4,(math.random(-80,80))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,90,0),
Size = Vector3.new(.5,100,0.5),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.7*M.C(Sine/32),-0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
											elseif(Mode=='disintegrated')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.7*M.C(Sine/32),-0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='CURED')then
				local Alpha = .1
				
										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,2,0),
Size = Vector3.new(0.7,0,0.7),
EndSize = Vector3.new(15,15,15),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-140-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(140+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.5,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Relax')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(80+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,0.4+.05*M.S(Sine/32),0.3)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-230-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0.4+.05*M.S(Sine/32),0.3)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(230+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Euclidiean')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(60+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-3),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-3),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			elseif(Mode=='Calamity')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='80s')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='WORMHOLE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.1,-0+.05*M.S(Sine/32),-0)*CF.A(M.R(175),M.R(-0),M.R(25-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,0.7-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.3)*CF.A(-0.6,M.R(-5),-0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='UNMERCIFUL')then
local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.2*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.2)*CF.A(-0.2,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='WITHERED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='90s')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(50+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
				
				
											elseif(Mode=='R E M E M B E R E D')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(70-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
				
			elseif(Mode=='DESTROYED')then
				local Alpha = .1
									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-20+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
				

							elseif(Mode=='GREATSWORD')then
				local Alpha = .1
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Catastrophe')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.01*M.C(Sine/32),-0.4)*CF.A(-0.5,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Cataclysm')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(5,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.01*M.C(Sine/32),-0.4)*CF.A(-0.5,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Radioactivity')then
				local Alpha = .1
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Camo'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Camo'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0.6)*CF.A(M.R(40+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-210-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Mythical')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+5*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,0+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(225+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.01*M.C(Sine/32),-0.4)*CF.A(-0.5,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='L0st')then
				GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(1,0.3,1);
				}		


				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.2+.03*M.S(Sine/32),0)*CF.A(M.R(165),M.R(20-12.6*M.C(Sine/32)),M.R(-35-1.5*M.C(Sine/32))),Alpha)
				end

				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Toxicities')then
				GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(1,0.3,1);
				}		


				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.2+.03*M.S(Sine/32),0)*CF.A(M.R(165),M.R(20-12.6*M.C(Sine/32)),M.R(-35-1.5*M.C(Sine/32))),Alpha)
				end

				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

			elseif(Mode=='Fearless')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			elseif(Mode=='ERROR_404')then
				local Alpha = .1
				if(NeutralAnims)then	
				    				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				    
				    				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-0-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
						elseif(Mode=='BYE BYE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/1)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/1)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
			
			elseif(Mode=='SINGULARITY')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(150-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(35+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			elseif(Mode=='MENTALLY INSANE')then
								    
								    				 local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			
			
						elseif(Mode=='COMPLETELY LOST')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-5-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(5+10*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),0,M.R(-3)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),0,M.R(3)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
			elseif(Mode=='')then
			
GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(1,0.3,1);
				}

local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2.05*M.C(Sine/32),0)*CF.A(M.R(-2+5*M.S(Sine/58)),M.R(-15+5*M.C(Sine/42)),0),Alpha)
				if(M.RNG(1,25)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(35),M.R(-10))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.7,0.1+.03*M.S(Sine/32),0)*CF.A(0,M.R(20+12.6*M.C(Sine/32)),M.R(-210-2.4*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,0.1+.03*M.S(Sine/32),0)*CF.A(M.R(175),M.R(20-12.6*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-5),M.R(0),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(5),0,0),Alpha)
				else
					LH.C0 = LH.C0:lerp(RHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
			elseif(Mode=='MURDEROUS')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(-7)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(7)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			end
		elseif(State == 'Walk')then
				if(Mode=='DESTROYED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
			elseif(Mode=='80s')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='EXCALIBUR')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='')then
			local wsVal = 5
			local Alpha = .4
			if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/10),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(1.7,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='god slayer')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end
								elseif(Mode=='BYE BYE')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/32)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/32)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-10)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(10)),Alpha)
				end
								elseif(Mode=='ENDLESS SILENCE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				    														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='disintegrated')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='Overclocked')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-336+350*M.S(Sine/80)),M.R(-335+330*M.C(Sine/80)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,0,-M.R(0+5*M.C(Sine/1))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.01*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-85-10*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.01*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(85+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-6),M.R(25),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(6),0,0),Alpha)
				end
								elseif(Mode=='SHATTERED')then
								    
								    							    				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-80,80),-4,(math.random(-80,80))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,90,0),
Size = Vector3.new(.5,100,0.5),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='ERROR_404')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='CURED')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
								elseif(Mode=='UNMERCIFUL')then
											    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),1+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='Relax')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='PSYCHO')then
								    
								    										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
								    
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='POWER')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
					}
					
																	    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
					
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																elseif(Mode=='INFINITE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
					
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
																				elseif(Mode=='DIMENSIONAL')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
												GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				    
					
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
							elseif(Mode=='SINGULARITY')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(50+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
																elseif(Mode=='90s')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='FORCE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='PULSAR')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Looped Error')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='APCOCLYPTIC')then
				local Alpha = .1
												    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='GENOCIDE')then
				local Alpha = .1
																								    
																				    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='PESTILENCE')then
				local Alpha = .1
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(60+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),0.4),Alpha)
				end
				
																				elseif(Mode=='BURNING BRAIN')then
				local Alpha = .1
				
										     local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='ACE-OF-SPADES')then
																				    
																				    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='WORMHOLE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='???')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='TIME WARP')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-0+10*M.S(Sine/32)),M.R(-0+999*M.C(Sine/80)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
				end
				
																elseif(Mode=='Deleterious')then
																			    
					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
				
																				elseif(Mode=='GREATSWORD')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Nefarious')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Atomic Collisions')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Lightning Cannon')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.1*M.C(Sine/32),-0.3)*CF.A(-0.2,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-20),0.08),Alpha)
					else
				end
				
																				elseif(Mode=='MENTALLY INSANE')then
 local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='R E M E M B E R E D')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(70-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
																				elseif(Mode=='SPEED OF LIGHT')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='PLATFORM')then
																				    
																				    											    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,8,0),
Size = Vector3.new(.5,0,0.5),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+0*M.C(Sine/32),0)*CF.A(M.R(70+10*M.S(Sine/64)),M.R(5),0),Alpha)  
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-190-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(190+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1.5,M.R(-5),-0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.6,M.R(-5),0.0),Alpha)
				end
				
																				elseif(Mode=='EXCALIBUR X')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='F0RG0TT3N')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0+.05*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-150+5*M.C(Sine/32)),M.R(-75-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='WITHERED')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+0*M.C(Sine/32),0)*CF.A(M.R(-40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),0),Alpha)
				end
				
																				elseif(Mode=='SYSTEM_32')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='ARCADE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='FUTURE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Euclidiean')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='CRAZED')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='Liar X')then
																    

				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='bored')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+0*M.C(Sine/32),-0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
																elseif(Mode=='Inferno')then
																    
																    				    
												    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Neon orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
																    
																    				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																				elseif(Mode=='Volcanic')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='Hydro')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='COMPLETELY LOST')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='DESTRUCTION')then
				local Alpha = .1
				
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				elseif(Mode=='Sub-Normal')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='ILLUSION')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='HYPNOTIC')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
				end
				elseif(Mode=='Normal')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				elseif(Mode=='S P A C E T I M E')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    

				    
				    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='I N S A N E')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    							    																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
												    																																		GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
												elseif(Mode=='HYBRID')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='Fearless')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			elseif(Mode=='Radioactivity')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
					RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			else

				local wsVal = 4
				local Alpha = .2
				if(Mode=='MURDEROUS')then Change=.3 elseif(Mode=='The Big Black' or Mode=='Legendary')then Change=1 else Change=.5 end
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0)*CF.A(M.R(0+55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(0-55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
				end
				if(legAnims)then 
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
					local footstepIds = {141491460,141491460}
					if(lhit and lhit.CanCollide and footstepSounds[lhit.Material])then
						if(lhit.Material==Enum.Material.Sand and lhit.Color.r*255>=160 and lhit.Color.g*255>=160 and lhit.Color.b*255>=160)then
							footstepIds[1] = footstepSounds[Enum.Material.Snow]
						else
							footstepIds[1] = footstepSounds[lhit.Material]
						end
					end

					if(rhit and rhit.CanCollide and footstepSounds[rhit.Material])then
						if(rhit.Material==Enum.Material.Sand and rhit.Color.r*255>=160 and rhit.Color.g*255>=160 and rhit.Color.b*255>=160)then
							footstepIds[2] = footstepSounds[Enum.Material.Snow]
						else
							footstepIds[2] = footstepSounds[rhit.Material]
						end
					end


					if(M.C(Sine/wsVal)/2>=.2 and footsound==0 and lhit)then
						local step = Part(Effects,lhit.Color,lhit.Material,V3.N(1,.1,1),CF.N(lpos),true,false)
						step.Transparency=(footstepIds[1]==footstepSounds[Enum.Material.Snow] and 0 or 1)
						local snd = Soond(step,footstepIds[1],M.RNG(80,100)/100,3,false,true,true)
						footsound=1
						S.Debris:AddItem(step,snd.TimeLength+2)
					elseif(M.C(Sine/wsVal)/2<=-.2 and footsound==1 and rhit)then
						local step = Part(Effects,rhit.Color,rhit.Material,V3.N(1,.1,1),CF.N(rpos),true,false)
						step.Transparency=(footstepIds[2]==footstepSounds[Enum.Material.Snow] and 0 or 1)
						local snd = Soond(step,footstepIds[2],M.RNG(80,100)/100,3,false,true,true)
						footsound=0
						S.Debris:AddItem(step,snd.TimeLength+2)
					end
				end
			end
		elseif(State == 'Jump')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			end
		elseif(State == 'Fall')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			end
		elseif(State == 'Paralyzed')then
			local Alpha = .1
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0,Alpha)
				RS.C0 = RS.C0:lerp(RSC0,Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
		elseif(State == 'Sit')then

		end
		if(data.User==data.Local)then
			local syncStuff={
				NeutralAnims;
				legAnims;
				{NK.C0,RJ.C0,RH.C0,RS.C0,LH.C0,LS.C0};
				{NK.C1,RJ.C1,RH.C1,RS.C1,LH.C1,LS.C1};
				Sine;
				movement;
				walking;	
				Change;
				--// OPTIONAL SYNC \\--
				MusicMode;
				(music and music.TimePosition or 0);
				(music and music.Pitch or 1);
				WingSine;
				getMode('Troubadour');
				Mode;
				hue;
			}
		end
	end
	
	--End Of Script -- v5 Of SGw
end)

Section:NewButton("Achromatic free", "ButtonInfo", function()
    print("Clicked")
script = game:GetObjects("rbxassetid://5857033951")[1]
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/0n3Du5SM'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

local reqfireallclients = false
Players = game:GetService("Players")
Me = game:GetService("Players").LocalPlayer
hi = script.NGR:Clone()
hi.Owner.Value = Me
hi.Parent = Me.Character
--hi.Disabled = false
script = hi

local Player = game:GetService("Players").LocalPlayer

repeat wait() until Player.Character
local scriptName = script.Name
local stopped=false
local remotes = {}
local req = {}
function remotes:FireServer(...)

end
function req:FireAllClients(...)
	if reqfireallclients then reqfireallclients(...) end
end
function WaitForChildOfClass(where,class,timeout)
	local start = tick();
	local ret;
	repeat ret=where:FindFirstChildOfClass(class) wait() until ret or tick()-start>=(timeout or 15)
	if(not ret)then warn("timeout") repeat wait()until nil else return ret end
end

local GUID = {}
do
	GUID.IDs = {};
	function GUID:new(len)
		local id;
		if(not len)then
			id = (tostring(function() end))
			id = id:gsub("function: ","")
		else
			local function genID(len)
				local newID = ""
				for i = 1,len do
					newID = newID..string.char(math.random(48,90))
				end
				return newID
			end
			repeat id = genID(len) until not GUID.IDs[id]
			local oid = id;
			id = {Trash=function() GUID.IDs[oid]=nil; end;Get=function() return oid; end}
			GUID.IDs[oid]=true;
		end
		return id
	end
end

local instanceID = GUID:new()

local Replicated = script:WaitForChild'Replication':Clone();
script.Replication:Destroy()




local m = Player:GetMouse()
local UsIS = game:GetService("UserInputService")

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local CF={N=CFrame.new,A=CFrame.Angles}

local Head = Player.Character:WaitForChild'Head'
local Torso = Player.Character:WaitForChild'Torso'
local LArm = Player.Character:WaitForChild'Left Arm'
local RArm = Player.Character:WaitForChild'Right Arm'
local LLeg = Player.Character:WaitForChild'Left Leg'
local RLeg = Player.Character:WaitForChild'Right Leg'
local Root = Player.Character:WaitForChild'HumanoidRootPart'
local targetnnn = nil
function newMotor(P0,P1,C0,C1)
	return NewInstance('Motor',P0,{Part0=P0,Part1=P1,C0=C0,C1=C1})
end

local welds = {}
local vars = {}
local Hit = {}


table.insert(welds,newMotor(Torso,Head,CF.N(0,1.5,0),CF.N()))
table.insert(welds,newMotor(Root,Torso,CF.N(),CF.N()))
table.insert(welds,newMotor(Torso,RLeg,CF.N(.5,-1,0),CF.N(0,1,0)))
table.insert(welds,newMotor(Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0)))
table.insert(welds,newMotor(Torso,LLeg,CF.N(-.5,-1,0),CF.N(0,1,0)))
table.insert(welds,newMotor(Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0)))

vars.WeldDefaults={}
for i = 1,#welds do
	local v=welds[i]
	vars.WeldDefaults[i]=v.C0
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end


function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 
	local DamageColor = data.DamageColor or BrickColor.new'Really red'
	local HitSound = data.HitSound;
	local HitPitch = data.HitPitch;

	local DB = data.Debounce or .2;

	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;

	local DamageEffects = data.DamageFX or {}
	local DeathEffect = DamageEffects.DeathEffect

	assert(Who,"Specify someone to damage!")	

	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local DoneDamage = math.random(MinDam,MaxDam) * (math.random(1,100) <= CritChance and CritMultiplier or 1)

	local canHit = true
	if(Humanoid)then
		for _, p in next, Hit do
			if p[1] == Humanoid then
				if(time() - p[2] <= DB) then
					canHit = false
				else
					Hit[_] = nil
				end
			end
		end
		if(canHit)then
			table.insert(Hit,{Humanoid,time()})
			local HitTorso = GetTorso(Who)
			local player = game:service'Players':GetPlayerFromCharacter(Who)
			if(Player.UserId == 5719877 or not player or player.UserId ~= 5719877 and player.UserId ~= 61573184 and player.UserId ~= 19081129)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					--Humanoid.Health = 0;
					--Who:BreakJoints();
					if(DeathEffect)then --req:FireAllClients(DeathEffect,Who,Humanoid) 
						
					end

				else
					local  c = Instance.new("ObjectValue",Humanoid)
					c.Name = "creator"
					c.Value = Player
					game:service'Debris':AddItem(c,0.35)	
					if(HitSound)then
						local s = NewInstance('Sound',HitTorso,{SoundId='rbxassetid://'..HitSound,Pitch=HitPitch or math.random(85,110)/100,Volume=1.5})
						s:Play()
						s.Ended:connect(function()
							s:destroy()
						end)
					end
					if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
						targetnnn = Who
						req:FireAllClients('ShowDamage',(Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+Vector3.new(0,1.5,0)+Vector3.new(math.random(-2,2),0,math.random(-2,2))),DoneDamage,1.5,typeof(DamageColor)=='Color3' and DamageColor or DamageColor.Color)
					end
					if(Humanoid.Health > 0 and Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathEffect)then --remotes:WaitForChild'Pusher':FireAllClients(DeathEffect,Who,Humanoid) 
							
						end end
					--Humanoid.Health = Humanoid.Health - DoneDamage
				end
			end
		end
	end		--]]
end
spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
	
			if targetnnn ~= nil then

				--print(targetnnn) print(targetnnn.Parent)
				othertarget = targetnnn:FindFirstChild("Torso") or targetnnn:FindFirstChild("UpperTorso")
				if not othertarget then return end
				print(othertarget)
				fling = true
			    GlobalFunctions.fling(othertarget,0.5)
				wait(0.1)
				targetnnn = nil
				fling = false
			end
	

	end
end)

name = "Pennis"
	local ch = Player.Character
	local RemoteFolder = Instance.new("Folder",Player.Character)
	RemoteFolder.Name=name..'Remotes'
	local Pull = Instance.new("RemoteFunction",RemoteFolder)
	Pull.Name = 'Puller'
	
	PullOnServerInvoke = function(request,...)
		--if(stopped)then return end
		if(request=='Welds')then
			return welds
		elseif(request=='Character')then
			return ch
		elseif(vars[request])then
			--return vars[request]
		end
	end
	function req:Pull(...)
		PullOnServerInvoke(...)
	end
	local Push = Instance.new("RemoteEvent",RemoteFolder)
	Push.Name = 'Pusher'
	PushOnServerEvent = (function(request,...)
		local varargs={...}
		--if(stopped)then return end
		if(request=='MouseEventCall')then
			local event = table.remove(varargs,1)
			if(m[event])then
				--Push:FireAllClients(event,unpack(varargs))
				--m:TrigEvent(event,unpack(varargs))
			end
		elseif(request=='MouseUpdate')then
			--m.Target = varargs[1].Target
			--m.Hit = varargs[1].Hit
			--Push:FireAllClients("UpdatePos",m.Target,m.Hit)
		elseif(request=='Damage')then
			DealDamage(...)
		elseif(request=='Kill')then
			--varargs[1]:BreakJoints()
		elseif(request=='Broadcast')then
			req:FireAllClients(unpack(varargs))
		elseif(request=='SetVariable')then
			if(varargs[1])then
				vars[varargs[1]]=varargs[2]
			end
		elseif(request=='SetVariableAndBroadcast')then
			vars[varargs[1]]=varargs[2]
			--Push:FireAllClients(unpack(varargs))
		elseif(request=='Drag')then
			--hitto,CFrame.new(Handle.Position)
			varargs[1].CFrame = varargs[2]
		end
	end)
	function req:Push(...)
		PushOnServerEvent(...)
	end	
	


-- MODIFIABLE STUFF --



-- STOP MODIFIABLE STUFF --
local signals = {} -- for l8r (stop commands, etc)
local scripts = {}


local Hum;
repeat wait() Hum=Player.Character:FindFirstChildOfClass'Humanoid' until Hum
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop(0);
end

pcall(game.Destroy,Player.Character:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')

function GiveScript(who)
	local pgui = WaitForChildOfClass(who,'PlayerGui')
	local scr = Replicated:Clone();
	scr.Name=instanceID
	scr.Parent = pgui script = scr end

--[[	scripts[who]=scr
	if(scr:FindFirstChild'Owner')then scr:WaitForChild'Owner'.Value = Player end
	scr.Disabled = false
	local signal;
	signal = pgui.DescendantRemoving:connect(function(o)
		wait()
		if(stopped)then BreakSignal(signal) return end
		if(scr.Parent~=pgui and not scr.Disabled)then
			local reparenting = pcall(function() scr.Parent=pgui end)
			if(not reparenting)then
				scr.Disabled=true
				BreakSignal(signal)
				scr:destroy()
				GiveScript(who)
				return
			end
		end
	end)
	signals[who.Name]=signal
end

function stop()
	warn("Stopped "..scriptName)
	stopped=true
	for _,v in next, signals do
		BreakSignal(v)
	end
	remotes:WaitForChild'Pusher':FireAllClients("stop")
	remotes:destroy()
	for _,v in next, scripts do
		v.Disabled=true
		v:destroy()
	end
	script:Destroy()
end
function connect(v)
	if(stopped)then return end
	if(v==Player and not v.Character:FindFirstChild(instanceID.."Remotes"))then
		SetupRemotes(instanceID)
	end
	v.CharacterAppearanceLoaded:connect(function()
		if(v==Player and not v.Character:FindFirstChild(instanceID.."Remotes"))then
			--SetupRemotes(instanceID)
			stop()
		end
		GiveScript(v)
	end)
	if(v.Character)then GiveScript(v) end
	if(v==Player)then
		v.Chatted:connect(function(c)
			if(c:lower()=="stopscript-")then
				stop()
			end
		end)
	end
end--]]
GiveScript(Player)
--[[for _,v in next, game:service'Players':players() do
	connect(v)
end

game:service'Players'.PlayerAdded:connect(connect)
game:service'Players'.PlayerRemoving:connect(function(p)
	if(p==Player)then
		stop()
	end
end)--]]
print("Finish")

script.WingPiece.qPerfectionWeld:Destroy()

do
	local NEVER_BREAK_JOINTS = false

	local function CallOnChildren(Instance, FunctionToCall)
		FunctionToCall(Instance)

		for _, Child in next, Instance:GetChildren() do
			CallOnChildren(Child, FunctionToCall)
		end
	end

	local function GetBricks(StartInstance)
		local List = {}
		CallOnChildren(StartInstance, function(Item)
			if Item:IsA("BasePart") then
				List[#List+1] = Item;
			end
		end)

		return List
	end

	local function Modify(Instance, Values)
		assert(type(Values) == "table", "Values is not a table");

		for Index, Value in next, Values do
			if type(Index) == "number" then
				Value.Parent = Instance
			else
				Instance[Index] = Value
			end
		end
		return Instance
	end

	local function Make(ClassType, Properties)
		return Modify(Instance.new(ClassType), Properties)
	end

	local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
	local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

	local function HasWheelJoint(Part)
		for _, SurfaceName in pairs(Surfaces) do
			for _, HingSurfaceName in pairs(HingSurfaces) do
				if Part[SurfaceName].Name == HingSurfaceName then
					return true
				end
			end
		end

		return false
	end

	local function ShouldBreakJoints(Part)
		if NEVER_BREAK_JOINTS then
			return false
		end

		if HasWheelJoint(Part) then
			return false
		end

		local Connected = Part:GetConnectedParts()

		if #Connected == 1 then
			return false
		end

		for _, Item in pairs(Connected) do
			if HasWheelJoint(Item) then
				return false
			elseif not Item:IsDescendantOf(script.Parent) then
				return false
			end
		end

		return true
	end

	local function WeldTogether(Part0, Part1, JointType, WeldParent)

		JointType = JointType or "Weld"
		local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

		local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
		Modify(NewWeld, {
			Name = "qCFrameWeldThingy";
			Part0  = Part0;
			Part1  = Part1;
			C0     = CFrame.new();--Part0.CFrame:inverse();
			C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
			Parent = Part1;
		})

		if not RelativeValue then
			RelativeValue = Make("CFrameValue", {
				Parent     = Part1;
				Name       = "qRelativeCFrameWeldValue";
				Archivable = true;
				Value      = NewWeld.C1;
			})
		end

		return NewWeld
	end

	local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)

		for _, Part in pairs(Parts) do
			if ShouldBreakJoints(Part) then
				Part:BreakJoints()
			end
		end

		for _, Part in pairs(Parts) do
			if Part ~= MainPart then
				WeldTogether(MainPart, Part, JointType, MainPart)
			end
		end

		if not DoNotUnanchor then
			for _, Part in pairs(Parts) do
				Part.Anchored = false
			end
			MainPart.Anchored = false
		end
	end

	local function PerfectionWeld()	
		local Parts = GetBricks(script.WingPiece)
		WeldParts(Parts, script.WingPiece.Main, "Weld", false)
	end
	PerfectionWeld()
end

local data = { User = game:GetService("Players").LocalPlayer, Local = game:GetService("Players").LocalPlayer}
--local req = data.Requests

if (data.User==data.Local) then
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Icon = "http://www.roblox.com/asset/?id=5027189307";
		Title = "Script : J07f's And Toxic's CR-Glitcher";
		Text = "User : "..data.User.Name;
		Duration = 5;
	})
end

--// Shortcut Variables \\--
--[[if game.ReplicatedStorage:FindFirstChild("LoadLibrabry") then
else
script.LoadLibrary.Parent = game.ReplicatedStorage
end--]]
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService
print(req:Pull("Character"))
--local Player = data.User
local Char = Player.Character
local Mouse = data.Local:GetMouse();
local Hum = Char:FindFirstChildOfClass'Humanoid'
local Torso = Char.Torso
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Head = Char.Head
angles=CFrame.Angles
euler=CFrame.fromEulerAnglesXYZ
local necko = CF.N(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RootCF = euler(-1.57,0,3.14)
local Sine = 0;
local Change = 1
local Attack=false
local NeutralAnims=true
local timePos=30;
local walking=true;
local legAnims=true;
local movement = 8
local footsound=0;
local WalkSpeed=16;
local Combo=0;
local Mode='Iniquitous'
local vaporwaveMode=false;
local WingAnim='NebG1'
local music;
local hue = 0;
local WingSine=0;
local MusicMode=1;
local visSong = 1702473314;
local EffectFolder = script:WaitForChild'FXFolder'
local Folda = script:FindFirstChild'Effects'
Folda.Parent = nil
local PrimaryColor = Color3.new(1,1,1)
local ClickTimer = 0;
local ClickAttack = 1;
local camshaker = script:WaitForChild'CameraShaker'
local camshakeins = camshaker.CameraShakeInstance
local camera = workspace.CurrentCamera
local LastSphere = time();
local VaporwaveSongs={
	2231500330;
	654094806;
	743334292;
	334283059;
	2082142910;
}

function MakeForm(PART, TYPE)
	if TYPE == "Cyl" then
		local MSH = IN("CylinderMesh", PART)
	elseif TYPE == "Ball" then
		local MSH = IN("SpecialMesh", PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IN("SpecialMesh", PART)
		MSH.MeshType = "Wedge"
	end
end
BRICKC = BrickColor.new
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IN("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
UD2 = UDim2.new
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IN("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IN(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function WWeld(a, b, acf)
    local we = Instance.new("Weld", a)
    we.Part0 = a
    we.Part1 = b
if acf ~= nil then
    we.C0 = acf
end
return we
end

local HALO = script:WaitForChild("Halo")
HALO.Parent = Char
local HaloWeld = WWeld(HALO,Head,CFrame.new(0,-1.2,0)*CFrame.Angles(math.rad(-12),math.rad(0),math.rad(0)))
HALO.Anchored = false
local BASECOLOR = HALO.Color
local PRT1 = HALO.aa4
PRT1.Size = V3.N(0.05, 0.1, 0.4) * (HALO.Size.Y * 10)
PRT1.Color = BASECOLOR
local WATCH1 = WWeld(HALO,PRT1,CFrame.new(0, 0, -(PRT1.Size.Z / 3 + 0.2))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)))
HALO.a1.Anchored = false
local PRT2 = HALO.aa5
PRT2.Size = V3.N(0.05, 0.1, 0.26666666666666666) * (HALO.Size.Y * 10)
PRT2.Color = BASECOLOR
local WATCH2 = WWeld(HALO,PRT2,CFrame.new(0, 0, -(PRT2.Size.Z / 3 + 0.2))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)))
HALO.a2.Anchored = false
local PRT = HALO.HAL
PRT.Size = V3.N(0.15,0.1,0.15) * (HALO.Size.Y * 10)
PRT.Color = BASECOLOR
MakeForm(PRT,"Cyl")
local ad = WWeld(HALO,PRT,CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)))
HALO.HAL.Anchored = false

function SetTween(SPart,CFr,MoveStyle2,outorin2,AnimTime)
local MoveStyle = Enum.EasingStyle[MoveStyle2]
local outorin = Enum.EasingDirection[outorin2]


local dahspeed=1
if Attack == true then
	dahspeed=3 --speedstuff --5
end

if SPart.Name=="Bullet" then
dahspeed=1	
end

local tweeningInformation = TweenInfo.new(
	AnimTime/dahspeed,	
	MoveStyle,
	outorin,
	0,
	false,
	0
)
local MoveCF = CFr
local tweenanim = game:GetService("TweenService"):Create(SPart,tweeningInformation,MoveCF)
tweenanim:Play()
end

local WingPiece = script:WaitForChild'WingPiece'
WingPiece.Parent=nil
local WingAnims={}
local Playlist={
	Default=1702473314;
	ScrapBoy=1215691669;
	Defeated=860594509;
	Annihilate=2116461106;
	DashAndDodge=2699922745;
	ZenWavy=2231500330;
	Beachwalk=334283059;
	Pyrowalk=2082142910;
	Vapor90s=654094806;
}

--[[
Achromatic - The Big Black - Lost Soul
Iniquitous
Mythical - Legendary
Ruined - Th1rt3en
Atramentous - Vanta Black
Subzero - Frostbite
Troubadour
Infectious - Radioactive
Love - Lust
]]

local Create = LoadLibrary("RbxUtility").Create

--2699922745
local val = math.random(1,255)
local color = Color3.fromRGB(val,val,val)

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
local NK,RJ,RH,RS,LH,LS=unpack(welds)

local NKC0,RJC0,RHC0,RSC0,LHC0,LSC0=unpack(vars.WeldDefaults)
--[[local NK,RJ,RH,RS,LH,LS=welds[1],welds[2],welds[3],welds[4],welds[5],welds[6]

local NKC0,RJC0,RHC0,RSC0,LHC0,LSC0=vars.WeldDefaults[1],vars.WeldDefaults[2],vars.WeldDefaults[3],vars.WeldDefaults[4],vars.WeldDefaults[5],vars.WeldDefaults[6]
if(req.Recievers.sync)then req:DelReciever("sync")end
if(req.Recievers.playMusic)then req:DelReciever("playMusic")end
if(req.Recievers.effect)then req:DelReciever("effect")end
if(req.Recievers.stop)then req:DelReciever("stop")end
if(req.Recievers.ShowDamage)then req:DelReciever("ShowDamage")end--]]

function makeMusic(id,pit,timePos)
	local sound = Torso:FindFirstChild("song") or Char:FindFirstChild(script.Name.."song")
	local parent = (MusicMode==2 and Char or Torso)
	if(not sound)then 
		sound = NewInstance("Sound",parent,{Name=script.Name.."song",Volume=(MusicMode==3 and 0 or 1),Pitch=(pit or 1),Looped=true})
		NewInstance("EqualizerSoundEffect",sound,{HighGain=0,MidGain=2,LowGain=10})
	end
	if(id=='stop')then
		if(sound)then
			sound:Stop()
		end
	else
		local timePos = typeof(timePos)=='number' and timePos or sound.TimePosition
		sound.Volume = (MusicMode==3 and 0 or 1)
		sound.Name = "song"
		sound.MaxDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
		sound.EmitterSize = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
		sound.Looped=true
		sound.SoundId = "rbxassetid://"..id
		sound.Pitch=(pit or 1)
		sound:Play()
		sound.TimePosition = timePos
	end
	return sound;
end
reqfireallclients = function(tyn,...)
	if tyn == "playMusic" then
	if AddRecieverplayMusic then AddRecieverplayMusic(...) end
	end
	if tyn == "Camshake" then
	if AddRecieverCamshake then AddRecieverCamshake(...) end
	end
	if tyn == "ShowDamage" then
	if AddRecieverShowDamage then AddRecieverShowDamage(...) end
	end
	if tyn == "SoundPart" then
	if AddRecieverSoundPart then AddRecieverSoundPart(...) end
	end
	if tyn == "Sound" then
	if AddRecieverSound then AddRecieverSound(...) end
	end
	if tyn == "Effect" then
	if AddRecieverEffect then AddRecieverEffect(...) end
	end
	if tyn == "Effect2" then
	if AddRecieverEffect2 then AddRecieverEffect2(...) end
	end
	if tyn == "stop" then
	if AddRecieverstop then AddRecieverstop(...) end
	end
	if tyn == "ChangeMode" then
	if AddRecieverChangeMode then AddRecieverChangeMode(...) end
	end
	if tyn == "sync" then
	if AddRecieversync then AddRecieversync(...) end
	end
	if tyn == "Chat" then
	if AddRecieverChat then AddRecieverChat(...) end
	end
	if tyn == "effect" then
	if AddRecievereffect then AddRecievereffect(...) end
	end
end

AddRecieverplayMusic = function(id,pitch,timePos)
	if(data.Local~=data.User)then
		makeMusic(id,pitch,timePos)
	end
end


function playMusic(id,pitch,timePos)
	if(data.Local==data.User)then
		--req:Push("Broadcast","playMusic",id,pitch,timePos)
		return makeMusic(id,pitch,timePos)
	end
end

for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop(0);
end

-- SCRIPT STUFF --
local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
--// Artificial HB \\--

local ArtificialHB = script:FindFirstChild'Heartbeat' or IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

local tf = 0
local allowframeloss = true
local tossremainder = true
local lastframe = tick()
local frame = 1/Frame_Speed
ArtificialHB:Fire()

game:GetService("RunService").Stepped:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

-------- RAINBOW LEAVE IT TO ME
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
while wait() do
    for i = 0, 254/5 do
        swait()
        g = g + 5
    end
    for i = 0, 254/5 do
        swait()
        r = r - 5
    end
    for i = 0, 254/5 do
        swait()
        b = b + 5
    end
    for i = 0, 254/5 do
        swait()
        g = g - 5
    end
    for i = 0, 254/5 do
        swait()
        r = r + 5
    end
    for i = 0, 254/5 do
        swait()
        b = b - 5
    end
end
end))

local val = math.random(1,255)
local color = Color3.fromRGB(val,val,val)
local CLOCKLOOP = 0
local CLOCKSPEED = 1
local VALUE1 = false
local VALUE2 = false

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		CLOCKLOOP = CLOCKLOOP - 1 * CLOCKSPEED
		local Animation_Speed = 3
		WATCH1.C0 = WATCH1.C0:lerp(CF.N(0, 0, 0) * CF.A(M.R(0), M.R(CLOCKLOOP * 5), M.R(0)), 1 / Animation_Speed)
		WATCH2.C0 = WATCH2.C0:lerp(CF.N(0, 0, 0) * CF.A(M.R(0), M.R(CLOCKLOOP * 5 / 2), M.R(0)), 1 / Animation_Speed)
		if CLOCKLOOP <= -149 and VALUE1 == false then
			CLOCKLOOP = 0
		end
	end
end))

local modeInfo={
	{Name="Achromatic",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(.5,.5,.5);Music=2533527428,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Iniquitous",Walkspeed=16,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.2,.2,.2);Music=2656505560,LeftWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Divinity",Walkspeed=16,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.2,.2,.2);Music=2656505560,LeftWing={0,BrickColor.new'Bright yellow0'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Bright yellow'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Mythical",Walkspeed=16,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.N(.6,.0,.9);Music=556122490,LeftWing={0,BrickColor.new'Alder'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Alder'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Ruined",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(0,0,0);Music=2297862957,LeftWing={0,Color3.fromRGB(190,104,98),Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='Aprins'};
	{Name="Atramentous",Walkspeed=14,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.1,.1,.1);Music=924339757,LeftWing={0,BrickColor.new'Dark stone grey'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim={'NebG3',2}};
	{Name="Subzero",Walkspeed=10,moveVal=6,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(0,190,190);Music=144121562,LeftWing={0,BrickColor.new'Pastel light blue'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pastel light blue'.Color,Enum.Material.Neon};WingAnim='NebG1'};	
	{Name="Troubadour",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(.5,.5,.5);Music=visSong,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Infectious",Walkspeed=16,moveVal=8,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(98,37,209);Music=927739239,LeftWing={0,BrickColor.new'Dark indigo'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Dark indigo'.Color,Enum.Material.Neon};WingAnim='NebG1'};	
	{Name="FANTASTIC NINJA",Walkspeed=16,moveVal=8,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(17,17,17);Music=1832210197,LeftWing={0,BrickColor.new'New Yeller'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='StarG'};	
	{Name="Love",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(255,152,220);Music=1030177093,LeftWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Solitude",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(1,1,1);Music=1564523997,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Sin",Walkspeed=16,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(0,0,0);Music=2557672037,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Really red'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Purity",Walkspeed=16,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=Color3.new(0,1,1);Music=1539245059,LeftWing={0,BrickColor.new'Toothpaste'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Toothpaste'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Justice",Walkspeed=64,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.5,.5,.5);Music=1102271169,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim={'NebG2',10}};
	{Name="Radioactive",Walkspeed=64,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.5,.5,.5);Music=411040482,LeftWing={0,BrickColor.new'Lime green'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Lime green'.Color,Enum.Material.Neon};WingAnim={'NebG2',10}};
	{Name="CALAMITY",Walkspeed=64,moveVal=6,Font=Enum.Font.Gotham,StrokeColor=Color3.new(0.25,0,1);Music=1359036559,LeftWing={0,BrickColor.new'Bright violet'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Bright violet'.Color,Enum.Material.Neon};WingAnim='NebG1'};	
	{Name="Glitchy",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=color;Music=195916147,LeftWing={0,color,Enum.Material.Neon};RightWing={0,color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="RAINBOW",Walkspeed=64,moveVal=20,Font=Enum.Font.Arcade,StrokeColor=Color3.new(r/255,g/255,b/255);Music=147930134,LeftWing={0,Color3.new(r/255,g/255,b/255),Enum.Material.Neon};RightWing={0,Color3.new(r/255,g/255,b/255),Enum.Material.Neon};WingAnim='StarG'};
	{Name="Time",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=BrickColor.new("Artichoke").Color;Music=2083683898,LeftWing={0,BrickColor.new("Artichoke").Color,Enum.Material.Neon};RightWing={0,BrickColor.new("Artichoke").Color,Enum.Material.Neon};WingAnim='NebG1'};

	--MAJORS--
	{Name="The Big Black",Walkspeed=64,moveVal=20,Font=Enum.Font.Arcade,StrokeColor=C3.N(.2,.2,.2);Music=183142252,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Dark stone grey'.Color,Enum.Material.Neon};WingAnim={'NebG3',10}};
	{Name="Legendary",Walkspeed=64,moveVal=20,Font=Enum.Font.Gotham,StrokeColor=C3.N(.4,.4,0);Music=468018712,LeftWing={0,BrickColor.new'Gold'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Gold'.Color,Enum.Material.Neon};WingAnim={'NebG2',10}};
	{Name="Lust",Walkspeed=64,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.N(1,0,1);Music=391089144,LeftWing={0,BrickColor.new'Hot pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Hot pink'.Color,Enum.Material.Neon};WingAnim='LustFrench'};

}

function clerp(a,b,t)
    return a:lerp(b,t)
end

--// Effects \\--

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)
	
	tween:Play()
end


--[[local camShake = camshaker.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
	camera.CFrame = camera.CFrame * shakeCf
end)

camShake:Start()--]]

function StartShake(Settings)
	--[[Settings.DropDist = Settings.DropDist or 10;
	Settings.IneffectiveDist = Settings.IneffectiveDist or 100;
	Settings.Duration = Settings.Duration or 1;
	local instance = camshakeins.new(Settings.Intensity or 5,Settings.Speed or 10,Settings.FadeIn or .1,0)
	instance.RotationInfluence=Settings.Rotation or Vector3.new(1,1,5)
	instance.PositionInfluence=Settings.Position or Vector3.new(1,1,1)
		
	--camShake:ShakeSustain(instance)
	local start = time();
	if(typeof(Settings.Origin)=='CFrame')then Settings.Origin = Settings.Origin.p end
	if(Settings.Origin and (typeof(Settings.Origin)=='Vector3' or typeof(Settings.Origin)=='Instance' and Settings.Origin:IsA'BasePart'))then
		local pos = (typeof(Settings.Origin)=='Instance' and Settings.Origin.Position or Settings.Origin)
		local dist = (camera.CFrame.p-pos).magnitude
		local modifier = dist < Settings.DropDist and 1 or dist < Settings.IneffectiveDist and (0 - 1) / (Settings.IneffectiveDist - Settings.DropDist) * (dist - Settings.DropDist) + 1 or 0
		instance:SetScaleMagnitude(modifier)
		coroutine.wrap(function()
			repeat wait()
				local pos = (typeof(Settings.Origin)=='Instance' and Settings.Origin.Position or Settings.Origin)
				local dist = (camera.CFrame.p-pos).magnitude
				local modifier = dist < Settings.DropDist and 1 or dist < Settings.IneffectiveDist and (0 - 1) / (Settings.IneffectiveDist - Settings.DropDist) * (dist - Settings.DropDist) + 1 or 0
				instance:SetScaleMagnitude(modifier)
			until instance:GetState()==camshakeins.CameraShakeState.Inactive
		end)()
	end
	coroutine.wrap(function()
		repeat swait() until time()-start>=Settings.Duration
		instance:StartFadeOut(Settings.FadeOut or .5)
	end)()]]
	return true
end


AddRecieverCamshake = function(shakedata)
	if(data.User~=data.Local and (not shakedata.Player or shakedata.Player==Player))then
		StartShake(shakedata)
	end
end

function Camshake(shakedata)
	StartShake(shakedata)
end
--[[function Camshake(shakedata)
	if(data.User==data.Local)then
		if(not shakedata.Player or shakedata.Player==data.Local)then StartShake(shakedata) end
		req:Push("Broadcast","Camshake",shakedata)
	end
end--]]
if(workspace:FindFirstChild(script.Name..'Effects'))then
	workspace[script.Name..'Effects']:destroy()
end

local Effects=NewInstance("Folder",Char)
Effects.Name=script.Name..'Effects'


function ShowDamage(Pos, Text, Time, Color)
	local Pos = Pos or V3.N(0, 0, 0)
	local Text = tostring(Text or "")
	local Time = Time or 2
	local Color = Color or C3.N(1, 0, 1)
	local EffectPart = Part(Effects,Color,Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CFrame.new(Pos),true,false)
	EffectPart.Transparency=1
	local BillboardGui = NewInstance("BillboardGui",EffectPart,{
		Size = UDim2.new(3,0,3,0),
		Adornee = EffectPart,
	})
	
	local TextLabel = NewInstance("TextLabel",BillboardGui,{
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		TextColor3 = Color,
		TextScaled = true,
		Font = Enum.Font.ArialBold, 
	})
	S.Debris:AddItem(EffectPart, Time+.5)
	delay(0, function()
		local rot=math.random(-10,10)/15
		local raise=.2
		local Frames = Time/Frame_Speed
		for i=0,1.1,.02 do
			swait()
			TextLabel.Rotation=TextLabel.Rotation+rot
			raise=raise-.008
			EffectPart.Position = EffectPart.Position + Vector3.new(0, raise, 0)
			TextLabel.TextTransparency=i
			TextLabel.TextStrokeTransparency=i
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end

AddRecieverShowDamage = ShowDamage


local baseSound = IN("Sound")

function Soond(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
	
function SoondPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound,soundPart
end

function SoundPart(...)
	if(data.User==data.Local)then
		--req:Push("Broadcast","SoundPart",...)
		return SoondPart(...)
	end
end

function Sound(...)
	if(data.User==data.Local)then
		--req:Push("Broadcast","Sound",...)
		return Soond(...)
	end
end
AddRecieverSoundPart = function(...)
	if(data.User~=data.Local)then
		SoondPart(...)
	end
end
	
AddRecieverSound = function(...)
	if(data.User~=data.Local)then
		Soond(...)
	end
end
	
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

function GotEffect(data)
	-- just for easy reference
	local color = data.Color or Color3.new(.7,.7,.7);
	local endcolor = data.EndColor or nil;
	local mat = data.Material or Enum.Material.SmoothPlastic;
	local cframe = data.CFrame or CFrame.new();
	local endpos = data.EndPos or nil;
	local meshdata = data.Mesh or {}
	local sounddata = data.Sound or {}
	local size = data.Size or Vector3.new(1,1,1)
	local endsize = data.EndSize or Vector3.new(6,6,6)
	local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
	local transparency = data.Transparency or NumberRange.new(0,1)
	local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
	local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
	local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
	local lifetime = data.Lifetime or 1;
	local system = data.FXSystem;
	local setpart = typeof(data.Part)=='string' and EffectFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil
	
	local S,PM;
	
	local P = setpart or Part(Effects,color,mat,Vector3.new(1,1,1),cframe,true,false)
	
	if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
		if(meshdata == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8),Vector3.new(0, 0, -2.3))
		elseif(meshdata == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Cylinder')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://471113192','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
		elseif(meshdata == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
		elseif(meshdata == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
		elseif(meshdata == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
		elseif(typeof(meshdata) == 'table')then
			local Type = meshdata.Type or Enum.MeshType.Brick
			local ID = meshdata.ID or '';
			local Tex = meshdata.Texture or '';
			local Offset = meshdata.Offset or Vector3.new(0,0,0)
			PM = Mesh(P,Type,ID,Tex,size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',size)
		end
	end
	local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
	local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1
	if(data.Part == "CylWav")then
		for i,v in pairs(P:GetDescendants()) do
			if v:IsA("MeshPart") then
				v.Transparency = startTrans
			end
		end
	end
	P.Material = mat
	P.CFrame = cframe
	P.Color = (typeof(color)=='BrickColor' and color.Color or color)
	P.Anchored = true
	P.CanCollide = false
	P.Transparency = startTrans
	P.Parent = Effects
	local random = Random.new();
	game:service'Debris':AddItem(P,lifetime+3)
	
	
	-- actual effect stuff
	local mult = 1;
	if(PM)then
		if(PM.MeshId == 'rbxassetid://20329976')then
			PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
		elseif(PM.MeshId == 'rbxassetid://4770583')then
			mult = 2
		elseif(PM.MeshId == 'rbxassetid://168892432')then
			mult = .25
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		end
	end	
	coroutine.wrap(function()
		if(system == 'Legacy' or system == 1 or system == nil)then
			local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*Frame_Speed
			for i = 0, frames do
				local div = (i/frames)
				P.Transparency=(startTrans+(endTrans-startTrans)*div)
				if(data.Part == "CylWav")then
				  for i,v in pairs(P:GetDescendants()) do
				    if v:IsA("MeshPart") then
				       v.Transparency = (startTrans+(endTrans-startTrans)*div)
				    end
				  end
				end
				if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end
				
				local RotCF=CFrame.Angles(0,0,0)
				
				if(rotinc == 'random')then
					RotCF=CFrame.Angles(math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)))
				elseif(typeof(rotinc) == 'table')then
					RotCF=CFrame.Angles(unpack(rotinc))
				end
				
				if(PM and PM.MeshId == 'rbxassetid://20329976')then
					PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
				end
				
				if(endpos and typeof(endpos) == 'CFrame')then
					P.CFrame=cframe:lerp(endpos,div)*RotCF
				elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
					local force = acceleration.Force;
					if(typeof(force)=='CFrame')then
						force=force.p;
					end
					if(typeof(force)=='Vector3')then
						if(acceleration.LookAt)then
							P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
						else
							P.CFrame=(P.CFrame+force)*RotCF
						end
					end
				else
					P.CFrame=P.CFrame*RotCF
				end
				
				if(endcolor and typeof(endcolor) == 'Color3')then
					P.Color = color:lerp(endcolor,div)
				end
				swait()
			end
			P:destroy()
		elseif(system == 'Experimental' or system == 2)then
			local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
			local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
			if(style == Enum.EasingStyle.Elastic)then
				info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
			elseif(style == Enum.EasingStyle.Bounce)then
				info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
			end
			local tweenPart = game:service'TweenService':Create(P,info2,{
				CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CFrame.Angles(unpack(endrot)),
				Color=typeof(endcolor) == 'Color3' and endcolor or color,
				Transparency=endTrans,
			})
			local off = Vector3.new(0,0,0)
			if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end
			
			local tweenMesh = game:service'TweenService':Create(PM,info,{
				Scale=endsize*mult,
				Offset=off,
			})
			tweenPart:Play()
			tweenMesh:Play()
		end
	end)()
end

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)
	
	tween:Play()
end

--local EasingFunctions = require(script.Tweens)

local EffectInfo={}
function LMDEffect(data)
	local color = data.Color or Color3.new(1,1,1);
	local transparency = data.Transparency or {0,1}
	local lifetime = data.Lifetime or 1
	local cframe = data.CFrame or CFrame.new(0,10,0)
	local acceleration = data.Acceleration or Vector3.new(0,0,0)
	local endpos = data.EndPos or nil
	local rotation = data.Rotation or {0,0,0}
	local meshData = data.Mesh or {Type=Enum.MeshType.Brick}
	local size = data.Size or Vector3.new(1,1,1)
	local material = data.Material or Enum.Material.Neon
	local setpart = typeof(data.Part)=='string' and Folda:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil
	local endSize = data.EndSize or nil
	local drag = data.Drag or 0
	local sizeTween = data.TweenSize;
	local moveTween = data.TweenPos;
	local transTween = data.TweenTrans;
	local accelTween = data.TweenAccel;
	local parent = data.Parent or Effects
	if(endSize and typeof(size)=='Vector3')then size={size,endSize} end
	
	if(typeof(size)=='Vector3')then
		size={size,size}
	end
	
	if(typeof(transparency)=='number')then
		transparency={transparency,transparency}
	end
	
	if(typeof(color)=='BrickColor')then
		color=color.Color
	end
	
	local PM;
	
	local part = setpart or Part(parent,color,material,V3.N(1,1,1),cframe,true,false)
	if(not part:IsA'MeshPart' and not part:IsA'UnionOperation')then
		local scale = size[1]
		if(meshData == "Blast")then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://20329976','',scale,Vector3.new(0,0,-scale.X/8))
		elseif(meshData == 'Ring')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://559831844','',scale,Vector3.new(0,0,0))
		elseif(meshData == 'Slash1')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(scale.X/10,.001,scale.Z/10),Vector3.new(0,0,0))
		elseif(meshData == 'Slash2')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(scale.X/1000,scale.Y/100,scale.Z/100),Vector3.new(0,0,0))
		elseif(meshData == 'Tornado1')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://443529437','',scale/10,Vector3.new(0,0,0))
		elseif(meshData == 'Tornado2')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://168892432','',scale/4,Vector3.new(0,0,0))
		elseif(meshData == 'Skull')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://4770583','',scale*2,Vector3.new(0,0,0))
		elseif(meshData == 'Crystal')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://9756362','',scale,Vector3.new(0,0,0))
		elseif(meshData == 'Cloud')then
			PM = Mesh(part,Enum.MeshType.FileMesh,'rbxassetid://1095708','',scale,Vector3.new(0,0,0))
		elseif(typeof(meshData) == 'table' or typeof(meshData) == 'Instance')then
			local Type = meshData.MeshType or meshData.Type or Enum.MeshType.Brick
			local ID = meshData.MeshId or meshData.Mesh or '';
			local Tex = meshData.TextureId or meshData.Texture or '';
			local Offset = meshData.Offset or Vector3.new(0,0,0)
			PM = Mesh(part,Type,ID,Tex,scale,Offset)
		elseif(not part:FindFirstChildOfClass('DataModelMesh'))then
			PM = Mesh(part,Enum.MeshType.Brick,'','',scale)
		else
			PM = part:FindFirstChildOfClass('DataModelMesh')
		end
	end
	
	part.Material = material
	part.CFrame = cframe
	part.Color = color
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = transparency[1]
	part.Size = (PM and V3.N(1,1,1) or size[1])
	part.Parent = parent
	
	local start = tick()
	local t0 = tick()
	local t01 = tick()
	local lastTrans='Nil';
	local lastSize='Nil';
	local lastColor='Nil';
	local info = {start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,PM,rotation,acceleration,endpos,cframe,drag,acceleration}
	table.insert(EffectInfo,info)
end

coroutine.wrap(function()
	while true do
		swait()
		for i,v in next, EffectInfo do
			local start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,mesh,rotation,acceleration,endpos,cframe,drag,startacc=unpack(v)
			local elapsed = tick()-start
			local left = elapsed/lifetime
			local dt = tick()-t0
			t0 = tick()
			if(mesh)then
				mesh.Scale = size[1]:lerp(size[2],(sizeTween and sizeTween(elapsed,0,1,lifetime) or left))
			else
				part.Size = size[1]:lerp(size[2],(sizeTween and sizeTween(elapsed,0,1,lifetime) or left))
			end
			part.Transparency = numLerp(transparency[1],transparency[2],(transTween and transTween(elapsed,0,1,lifetime) or left))
			
			local newRot={0,0,0}
			if(rotation=='random')then
				newRot={M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360))}
			elseif(typeof(rotation)=='table')then
				local x,y,z=M.R(rotation[1]),M.R(rotation[2]),M.R(rotation[3])
				if(rotation[1]==0)then x=0 end
				if(rotation[2]==0)then y=0 end
				if(rotation[3]==0)then z=0 end
				newRot={x,y,z}
			end
			
			local accelMult=(accelTween and 1-accelTween(elapsed,0,1,lifetime) or 1)

			local accel=(acceleration*dt)
			if(endpos)then
				part.CFrame = cframe:lerp(endpos,(moveTween and moveTween(elapsed,0,1,lifetime) or left))
			elseif(accel and (accel.x~=0 or accel.y~=0 or accel.z~=0))then
				part.CFrame = part.CFrame*CF.A(unpack(newRot))+(accel*accelMult)
			elseif(newRot and (newRot[1]~=0 or newRot[2]~=0 or newRot[3]~=0))then
				part.CFrame = part.CFrame*CF.A(unpack(newRot))
			end
			if(drag>0)then
				acceleration=acceleration-V3.N(
					0.05*startacc.x/(drag/1.5),
					0.05*startacc.y/(drag/1.5),
					0.05*startacc.z/(drag/1.5)
				)
			end
			if(elapsed>lifetime)then
				part:destroy()
				EffectInfo[i]=nil
			else
				EffectInfo[i]={start,lifetime,t0,transTween,sizeTween,moveTween,accelTween,color,transparency,size,part,mesh,rotation,acceleration,endpos,cframe,drag,startacc}
			end
		end
	end
end)()

function Effect(edata)
	if(data.User==data.Local)then
		--req:Push("Broadcast","Effect",edata)
		GotEffect(edata)
	end
end

AddRecieverEffect = function(edata)
	if(data.User~=data.Local)then
		GotEffect(edata)
	end
end

function Effect2(edata)
	if(data.User==data.Local)then
		--req:Push("Broadcast","Effect2",edata)
		LMDEffect(edata)
	end
end

AddRecieverEffect2 = function(edata)
	if(data.User~=data.Local)then
		LMDEffect(edata)
	end
end

function Trail(data)
	coroutine.wrap(function()
		data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
		data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
		local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
		data.EndPos=nil
		local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
		trailPart.Transparency=1
		local start = data.CFrame
		for i = 1, data.Frames do
			trailPart.CFrame = start:lerp(ep,i/data.Frames)
			data.CFrame = trailPart.CFrame
			Effect(data)
			swait()
		end	
	end)()
end

function ClientTrail(data)
	coroutine.wrap(function()
		data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
		data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
		local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
		data.EndPos=nil
		local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
		trailPart.Transparency=1
		local start = data.CFrame
		for i = 1, data.Frames do
			trailPart.CFrame = start:lerp(ep,i/data.Frames)
			data.CFrame = trailPart.CFrame
			GotEffect(data)
			swait()
		end	
	end)()
end

AddRecieverstop = function()
	script:destroy()
	script.Disabled=false
	error("done")
end


if(Char:FindFirstChild('NGRWings'..script.Name))then
	Char['NGRWings'..script.Name]:destroy()
end

for _,v in next, Char:children() do
	if(v.Name:lower():find'wings')then
		v:destroy()
	end
end
--[[
-gh 4391384843,3822880197,4047554959,4094878701,3409612660,3940375351
]]
local wingModel = Instance.new("Model",Char)
wingModel.Name="NGRWings"..script.Name
local rightWing = NewInstance("Model",wingModel,{Name='Right'})
local leftWing = NewInstance("Model",wingModel,{Name='Left'})
local International = {}
local InternationalAttach = {}
for _,v in pairs(Char:GetChildren()) do
	if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") or v.Name:find("InternationalFedora") or v.Name:find("International Fedora") then
		table.insert(International,v)
		--print(v)
	end
end
--[[for i = 1,#International do
	local v=International[i]
	print(v)
end--]]
local LWP1 = WingPiece:Clone();
LWP1.Parent = leftWing
LWP1.Name = "LWP1"
local LWP2 = WingPiece:Clone();
LWP2.Parent = leftWing
LWP2.Name = "LWP2"
local LWP3 = WingPiece:Clone();
LWP3.Parent = leftWing
LWP3.Name = "LWP3"
local RWP1 = WingPiece:Clone();
RWP1.Parent = rightWing
RWP1.Name = "RWP1"
local RWP2 = WingPiece:Clone();
RWP2.Parent = rightWing
RWP2.Name = "RWP2"
local RWP3 = WingPiece:Clone();
RWP3.Parent = rightWing
RWP3.Name = "RWP3"
local LWP1W=Weld(LWP1.PrimaryPart,Torso,CF.N(2,-2,-1)*CF.A(0,0,0))
local LWP2W=Weld(LWP2.PrimaryPart,Torso,CF.N(4.25,-1,-1)*CF.A(0,0,M.R(15)))
local LWP3W=Weld(LWP3.PrimaryPart,Torso,CF.N(6.5,.5,-1)*CF.A(0,0,M.R(30)))
local RWP1W=Weld(RWP1.PrimaryPart,Torso,CF.N(-2,-2,-1)*CF.A(0,0,0))
local RWP2W=Weld(RWP2.PrimaryPart,Torso,CF.N(-4.25,-1,-1)*CF.A(0,0,M.R(-15)))
local RWP3W=Weld(RWP3.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
for _,v in pairs(leftWing:GetChildren()) do
	if v:IsA("Model") then
		PrimaryPart = v.PrimaryPart
		table.insert(InternationalAttach,PrimaryPart)
	end
end
for _,v in pairs(rightWing:GetChildren()) do
	if v:IsA("Model") then
		PrimaryPart = v.PrimaryPart
		table.insert(InternationalAttach,PrimaryPart)
	end
end
for i = 1,#InternationalAttach do
	local vn=InternationalAttach[i]
	local hatvariable = gp(vn, "att1_Handle", "Attachment")
	if hatvariable then return end
    local v=International[i]
	local hat = gp(gp(gp(cnnnnn, v.Name, "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
	local hatmesh = gp(gp(cnnnnn.Model, v.Name, "Accessory"), "Handle", "BasePart")
	local hatmesh = hatmesh:FindFirstChild("SpecialMesh") or hatmesh:FindFirstChild("Mesh")
	if hatvariable then return end
	hat.Parent = vn
	hatmesh:Destroy()
	for _,v in pairs(vn.Parent:GetDescendants()) do
		if v:IsA("Part") or v:IsA("MeshPart") then
			v.Transparency = 1
		end
	end
	print("---") print(vn.Parent) print("Attached") print(v) print("---")

end
local bbg=Head:FindFirstChild'Nametag' or NewInstance("BillboardGui",Head,{
	Adornee=Head;
	Name='Nametag';
	Size=UDim2.new(4,0,1.2,0);
	StudsOffset=V3.N(-8,5.3,0);
})
local text=bbg:FindFirstChild'TextLabel' or NewInstance("TextLabel",bbg,{
	Size=UDim2.new(5,0,3.5,0);
	TextScaled=true;
	BackgroundTransparency=1;
	TextStrokeTransparency=0;
	Font=Enum.Font.Arcade;
	TextColor3=C3.N(1,1,1);
	Text='Achromatic'
})

function getMode(modeName)
	for i,v in next, modeInfo do
		if(v.Name==modeName)then
			return v
		end
	end
	return modeInfo[1]
end

function IsVaporwave(song)
	for i = 1,#VaporwaveSongs do
		if(VaporwaveSongs[i]==song)then
			return true
		end
	end
	return false
end

local blush = NewInstance('Decal',Head,{Transparency=1,Texture='rbxassetid://0',Color3=(Player.UserId==5719877 and C3.N(.45,0,1) or C3.N(1,0,0))})

function changeMudo(modeName)
	local info = getMode(modeName)
	Mode=info.Name
	WalkSpeed=info.Walkspeed
	movement=info.moveVal
	music=makeMusic(info.Music or 0,info.Pitch or 1,info.TimePos or music and music.TimePosition or 0)
	WingAnim=info.WingAnim or 'NebG1'
	text.Text = info.Name
	text.TextColor3 = info.LeftWing[2]
	text.TextStrokeColor3 = info.StrokeColor
	text.Font=info.Font;
	if(Mode=='Love' or Mode=='Lust')then
		blush.Transparency=0
		blush.Texture='rbxassetid://2664127437'
	else
		blush.Transparency=1
		blush.Texture='rbxassetid://0'
	end
	for _,v in next,leftWing:GetDescendants() do
		if(v:IsA'BasePart' and v.Name~='Main')then
			--v.Transparency=info.LeftWing[1]
			v.Color=info.LeftWing[2]
			v.Material=info.LeftWing[3]
		elseif(v:IsA'Trail')then
			--v.Transparency=NumberSequence.new(info.LeftWing[1],1)
			v.Color=ColorSequence.new(info.LeftWing[2])	
		end
	end
	
	for _,v in next,rightWing:GetDescendants() do
		if(v:IsA'BasePart' and v.Name~='Main')then
			--v.Transparency=info.RightWing[1]
			v.Color=info.RightWing[2]
			v.Material=info.RightWing[3]
		elseif(v:IsA'Trail')then
			--v.Transparency=NumberSequence.new(info.RightWing[1],1)
			v.Color=ColorSequence.new(info.RightWing[2])	
		end
	end
	
	PrimaryColor = info.PrimaryColor or info.LeftWing[2]
end

function changeMode(modeName)
	if(data.User==data.Local)then
		changeMudo(modeName)
		--req:Push("Broadcast","ChangeMode",modeName)	
	end
end	

AddRecieverChangeMode = function(name)
	if(data.User~=data.Local)then
		changeMudo(name)
	end
end

function syncStuff(data)
	local neut,legwelds,c0s,c1s,sine,mov,walk,inc,musicmode,tpos,pit,wingsin,visSett,mode,newhue=unpack(data)
	local head0,torso0,rleg0,rarm0,lleg0,larm0=unpack(c0s)
	local head1,torso1,rleg1,rarm1,lleg1,larm1=unpack(c1s)
	legAnims=legwelds
	NeutralAnims=neut
	if(not neut)then
		NK.C0=head0
		RJ.C0=torso0
		RH.C0=rleg0
		RS.C0=rarm0
		LH.C0=lleg0
		LS.C0=larm0
		
		NK.C1=head1
		RJ.C1=torso1
		RH.C1=rleg1
		RS.C1=rarm1
		LH.C1=lleg1
		LS.C1=larm1
	end
	if(Mode~=mode)then
		changeMudo(mode)
	end
	movement=mov
	walking=walk
	Change=inc
	print(MusicMode,musicmode)
	if(musicmode~=MusicMode and music)then
		MusicMode=musicmode
		if(MusicMode==1)then
			music:Pause()
			music.Volume=1
			music.Parent=Torso
			music:Resume()
		elseif(MusicMode==2)then
			music:Pause()
			music.Volume=1
			music.Parent=Char
			music:Resume()
		elseif(MusicMode==3)then
			music.Volume = 0
		end
	end
	if(Sine-sine>.8 or Sine-sine<-.8)then
		Sine=sine
	end
	if(hue-newhue>.8 or hue-newhue<-.8)then
		hue=newhue
	end
	if(WingSine-wingsin>.8 or WingSine-wingsin<-.8)then
		WingSine=wingsin
	end
	if(music and (music.TimePosition-tpos>.8 or music.TimePosition-tpos<-.8))then
		music.TimePosition=tpos
	end
	if(music and pit)then
		music.Pitch = pit
	end
	if(Mode=='Troubadour' and music.SoundId~='rbxassetid://'..visSett.Music)then
		music.SoundId='rbxassetid://'..visSett.Music
	end
	getMode('Troubadour').Music = visSett.Music
	getMode('Troubadour').Pitch = visSett.Pitch
end
	
--if(req:FireAllClients("sync"))then syncStuff(req:FireAllClients("sync")) else changeMudo('Achromatic') end

AddRecieversync = function(syncdata)if(data.User~=data.Local)then syncStuff(syncdata) end end

local footstepSounds = {
	[Enum.Material.Grass]=510933218;
	[Enum.Material.Metal]=1263161138;
	[Enum.Material.CorrodedMetal]=1263161138;
	[Enum.Material.DiamondPlate]=1263161138;
	[Enum.Material.Wood]=2452053757;
	[Enum.Material.WoodPlanks]=2452053757;
	[Enum.Material.Sand]=134456884;
	[Enum.Material.Snow]=2452051182;
}


function Vaporwaveify(s)
	local function wide(a)
		if a<'!' or a>'~' then return a end
		if a==' ' then return '  ' end 
		a = a:byte()+160
		if a<256 then return string.char(239,188,a-64) end
		return string.char(239,189,a-128)
	end
	return(s:gsub(".",wide))
end



function Choot(text)
	--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,0,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Antique,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
	--else
	--	Chat2(text)
	--end
end

function Chat(text)
	if(data.User==data.Local)then
		Choot(text)
		--req:Push("Broadcast","Chat",text)
	end	
end

AddRecieverChat = function(text)
	if(data.User~=data.Local)then
		Choot(text)
	end
end

--function DealDamage(...)
	--req:Push("Damage",...)
--end

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end
function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent:FindFirstChildOfClass'Humanoid'])then
			local callTable = {Who=v.Parent}
			hit[v.Parent:FindFirstChildOfClass'Humanoid'] = true
			for _,v in next, options do callTable[_] = v end
			DealDamage(callTable)
		end
	end
	return hit
end


function Click1()
	Attack=true
	NeutralAnims=false
	legAnims=false
	local orig = WalkSpeed
	WalkSpeed=4
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-44.6),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.8,-1,-0.3)*CF.A(M.R(-17.4),M.R(44.4),M.R(7.1)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.4,-1,0)*CF.A(M.R(1.6),M.R(-13.1),M.R(7)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.3)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.1)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(44.6),M.R(0)),Alpha)
	end
	for i = 0, 1, 0.1 do
		swait()
		AOEDamage(RArm.CFrame.p,2,{
			DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
			MinimumDamage=5;
			MaximumDamage=15;
		})
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,-0.7)*CF.A(M.R(0),M.R(50.5),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.6)*CF.A(M.R(-26),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.6,-1.1,-0.1)*CF.A(M.R(20.2),M.R(-47.6),M.R(15.2)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-20.4)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(50.5)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-50.5),M.R(0)),Alpha)
	end
	WalkSpeed=orig
	legAnims=true
	Attack=false
	NeutralAnims=true
end

function SwordSummon()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=4
	legAnims=false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		Effect{
			Lifetime=.25;
			Mesh={Type=Enum.MeshType.Sphere};
			CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
			Color=PrimaryColor;
			Transparency={.5,1};
			Material=Enum.Material.Neon;
			Size=Vector3.new(.6,1,.6);
			EndSize=Vector3.new(.1,3,.1);
		}
		RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,-0.1)*CF.A(M.R(-12.4),M.R(-15.7),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.5)*CF.A(M.R(16.2),M.R(15.2),M.R(-0.8)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-28.5),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.5,0)*CF.A(M.R(27.2),M.R(-3.8),M.R(-5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.3,0.6,0)*CF.A(M.R(-33.8),M.R(-18.1),M.R(24.8)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(13.4),M.R(15.3),M.R(-3.6)),Alpha)
	end
	for i = 0, 5 do
		delay(.05*i,function()
			local pos = Root.CFrame*CF.N(0,-2,-2-i*4)*CF.A(M.R(80),0,0)
			local pos2 = Root.CFrame*CF.N(0,-3,-2-i*4)
			Camshake({
			    Duration=.2;
				FadeOut=.2;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=pos2;
			})
			AOEDamage(pos.p,5,{
				DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
				MinimumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/10 or 10);
				MaximumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/8 or 35);
			})
			SoundPart(178452221,1,2,false,true,true,pos)
			Effect{
				Lifetime=.4;
				Part='Sword',
				--Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(0.8,2.5,6.8);
				EndSize=V3.N(0.8,2.5,16);
			}
			Effect{
				Lifetime=.4;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos2;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(4,.1,4);
				EndSize=V3.N(6,.1,6);
			}
			Effect{
				Lifetime=.1;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(7,7,7);
				EndSize=V3.N(12,12,12);
			}
			for i = 1, 5 do
				Effect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=pos;
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(1,1,1);
					EndSize=V3.N(1,1,1);
					Acceleration={Force=V3.N(M.RNG(-75,75)/100,M.RNG(-75,75)/100,M.RNG(-75,75)/100)};
				}
			end
		end)
	end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

function Bombs()
	Attack=true
	NeutralAnims=false
	legAnims=false
	local orig = WalkSpeed
	WalkSpeed=0
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(19.1)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(-21.3)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
	end
	coroutine.wrap(function()
		for i = 0, 2 do
			Camshake({
			    Duration=.2;
				FadeOut=.2;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(206083252,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
			Effect{
				Lifetime=.4;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4);
				Size=V3.N(1,1,1);
				EndSize=V3.N(10,10,10);
			}
			Effect{
				Lifetime=.4;
				Part='Ring';
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
				Size=V3.N(4,4,.2);
				EndSize=V3.N(13,13,.2);
			}
			Effect{
				Lifetime=.4;
				Part='Ring';
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
				Size=V3.N(4,4,.2);
				EndSize=V3.N(13,13,.2);
			}
			swait(4)
		end
	end)()
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,0.7)*CF.A(M.R(18.2),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,-0.4)*CF.A(M.R(-33.4),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-0.9,-0.2)*CF.A(M.R(-6.7),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.4,0.1)*CF.A(M.R(90.7),M.R(-2.5),M.R(-50)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.2)*CF.A(M.R(89.5),M.R(2.6),M.R(50)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
	end
	WalkSpeed=orig
	legAnims=true
	Attack=false
	NeutralAnims=true
end

function JusticeSkyBeams()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	for i = 1, 110 do
		swait()
		local Alpha = .3
		local pos = Root.CFrame * CFrame.new(math.random(-150,150),0,math.random(-150,150))
		RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,0.7)*CF.A(M.R(18.2),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,-0.4)*CF.A(M.R(-33.4),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-0.9,-0.2)*CF.A(M.R(-6.7),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.4,0.1)*CF.A(M.R(90.7),M.R(-2.5),M.R(-50)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.2)*CF.A(M.R(89.5),M.R(2.6),M.R(50)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		SoundPart(206083252,.8,2,false,true,true,pos)
		Effect{
			Lifetime=.4;
			Part='CylWav';
			Color=PrimaryColor;
			Material=Enum.Material.Neon;
			CFrame=Root.CFrame * CFrame.new(math.random(-150,150),0,math.random(-150,150));
			RotInc={0,M.RNG(-90,90),0};
			Size=V3.N(0.05,0.05,0.05);
			EndSize=V3.N(0.05,0.05,0.05);
		}
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end



function ClickCombo()
	ClickTimer=180
	if(Combo==1)then
		Click1()
		Combo=2
	elseif(Combo==2)then
		SwordSummon()
		Combo=3
	elseif(Combo==3)then
		Bombs()
		Combo=1
	end
end

local MAINRUINCOLOR = BrickColor.new("Really black")
local origcolor = BrickColor.new("Pastel light blue")
local cam = game.Workspace.CurrentCamera
local rainbowmode = false
local chaosmode = false
local glitchymode = false
Camera = cam
local CamInterrupt = false
cam.CameraType = "Custom"
necko=CF.N(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=CF.N(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

function CameraShake(Times, Power, PlayerTarget)
coroutine.resume(coroutine.create(function()
FV = Instance.new("BoolValue", PlayerTarget)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Hum.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Hum.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end  
end
Hum.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end))
end

function CameraEnshaking(Length,Intensity)
coroutine.resume(coroutine.create(function()
      local intensity = 1*Intensity
      local rotM = 0.01*Intensity
for i = 0, Length, 0.1 do
swait()
intensity = intensity - 0.05*Intensity/Length
rotM = rotM - 0.0005*Intensity/Length
      Hum.CameraOffset = V3.N(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)))
      cam.CFrame = cam.CFrame * CF.N(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity))) * CFrame.fromEulerAnglesXYZ(math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM)
end
Hum.CameraOffset = V3.N(0, 0, 0)
end))
end
CamShake=function(Part,Distan,Power,Times)
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v:FindFirstChildOfClass'Humanoid'
if Noob~=nil then
coroutine.resume(coroutine.create(function()
FV = Instance.new("BoolValue", Noob)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Hum.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Hum.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end  
end
Hum.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end))
CameraShake(Times, Power, Noob)
end
end
end
end
end
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(Char.Torso.Position, Vector3.new(Mouse.Hit.p.x, Char.Torso.Position.y, Mouse.Hit.p.z)),
    Vector3.new(Mouse.Hit.p.x, Mouse.Hit.p.y, Mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(Char.Torso.Position, Vector3.new(Mouse.Hit.p.x, Mouse.Hit.p.y, Mouse.Hit.p.z)),
    Vector3.new(Mouse.Hit.p.x, Mouse.Hit.p.y, Mouse.Hit.p.z)
  }
end

local Create = LoadLibrary("RbxUtility").Create
 
function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

CFuncs = { 
    ["Part"] = {
        Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
            local Part = Create("Part"){
                Parent = Parent,
                Reflectance = Reflectance,
                Transparency = Transparency,
                CanCollide = false,
                Locked = true,
                BrickColor = BrickColor.new(tostring(BColor)),
                Name = Name,
                Size = Size,
                Material = Material,
            }
            RemoveOutlines(Part)
            return Part
        end;
    };
   
    ["Mesh"] = {
        Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
            local Msh = Create(Mesh){
                Parent = Part,
                Offset = OffSet,
                Scale = Scale,
            }
            if Mesh == "SpecialMesh" then
                Msh.MeshType = MeshType
                Msh.MeshId = MeshId
            end
            return Msh
        end;
    };
   
    ["Mesh"] = {
        Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
            local Msh = Create(Mesh){
                Parent = Part,
                Offset = OffSet,
                Scale = Scale,
            }
            if Mesh == "SpecialMesh" then
                Msh.MeshType = MeshType
                Msh.MeshId = MeshId
            end
            return Msh
        end;
    };
   
    ["Weld"] = {
        Create = function(Parent, Part0, Part1, C0, C1)
            local Weld = Create("Weld"){
                Parent = Parent,
                Part0 = Part0,
                Part1 = Part1,
                C0 = C0,
                C1 = C1,
            }
            return Weld
        end;
    };
 
    ["Sound"] = {
        Create = function(id, par, vol, pit)
            return coroutine.wrap(function()
                local S = Create("Sound"){
                    Volume = vol,
                                        Name = "EffectSoundo",
                    Pitch = pit or 1,
                    SoundId = id,
                    Parent = par or workspace,
                }
                S:Play()
                S.Ended:connect(function()
                    S:Destroy()
                end)
                return S;
            end)()
        end;
    };
 
["LongSound"] = {
        Create = function(id, par, vol, pit)
            coroutine.resume(coroutine.create(function()
                local S = Create("Sound"){
                    Volume = vol,
                    Pitch = pit or 1,
                    SoundId = id,
                    Parent = par or workspace,
                }
                wait()
                S:play()
                game:GetService("Debris"):AddItem(S, 30)
            end))
        end;
    };
   
    ["ParticleEmitter"] = {
        Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
            local fp = Create("ParticleEmitter"){
                Parent = Parent,
                Color = ColorSequence.new(Color1, Color2),
                LightEmission = LightEmission,
                Size = Size,
                Texture = Texture,
                Transparency = Transparency,
                ZOffset = ZOffset,
                Acceleration = Accel,
                Drag = Drag,
                LockedToPart = LockedToPart,
                VelocityInheritance = VelocityInheritance,
                EmissionDirection = EmissionDirection,
                Enabled = Enabled,
                Lifetime = LifeTime,
                Rate = Rate,
                Rotation = Rotation,
                RotSpeed = RotSpeed,
                Speed = Speed,
                VelocitySpread = VelocitySpread,
            }
            return fp
        end;
    };
 
    CreateTemplate = {
   
    };
}

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
    end
  end
  if h ~= nil and hit.Parent.Name ~= Char.Name and hit.Parent:FindFirstChild("Head") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = Player,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      HitHealth = h.Health
      h.Health = h.Health - Damage
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        print("gained kill")
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
      hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(1)
        HHumanoid.PlatformStand = false
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Head
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Leech" then
      local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
      if hum ~= nil then
        for i = 0, 2 do
          Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
        Hum.Health = Hum.Health + 10
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent:FindFirstChildOfClass'Humanoid'
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(5)
        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
      Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
        Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Spike" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Freeze" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        swait(1.5)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, Root, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function RsphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function NsphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function RainbowWip()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
local rngb = Instance.new("Part", Char)
        rngb.Anchored = true
        rngb.BrickColor = origcolor
        rngb.CanCollide = false
        rngb.FormFactor = 3
        rngb.Name = "Ring"
        rngb.Material = "Neon"
        rngb.Size = Vector3.new(1, 0.05, 1)
        rngb.Transparency = 1
        rngb.TopSurface = 0
        rngb.BottomSurface = 0
        local rngmb = Instance.new("SpecialMesh", rngb)
        rngmb.MeshType = "Brick"
rngmb.Name = "SizeMesh"
rngmb.Scale = V3.N(0,1,0)
 
local orb = rngb:Clone()
orb.Parent = Char
orb.Transparency = 0
orb.BrickColor = BrickColor.new("White")
orb.Size = V3.N(1,1,1)
local orbmish = orb.SizeMesh
orbmish.Scale = V3.N(0,0,0)
orbmish.MeshType = "Sphere"
 
local orbe = rngb:Clone()
orbe.Parent = Char
orbe.Transparency = 0.5
orbe.BrickColor = BrickColor.new("New Yeller")
orbe.Size = V3.N(1,1,1)
local orbmish2 = orbe.SizeMesh
orbmish2.Scale = V3.N(0,0,0)
orbmish2.MeshType = "Sphere"
orbe.Color = Color3.new(r/255,g/255,b/255)
 
Hum.AutoRotate = false
rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
for i = 0,5,0.1 do
swait()
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            orbe.Color = color
        end
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
swait()
local Alpha = .3
RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
Root.CFrame = FaceMouse()[1]
end
orbe.Transparency = 1
orb.Transparency = 1
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*5
CFuncs["Sound"].Create("rbxassetid://294188875", Char, 1, 1)
local a = Instance.new("Part",Char)
    a.Name = "Direction"   
    a.Anchored = true
    a.BrickColor = BrickColor.new("White")
a.Material = "Neon"
a.Transparency = 0
a.Shape = "Cylinder"
    a.CanCollide = false
local a2 = Instance.new("Part",Char)
    a2.Name = "Direction"  
    a2.Anchored = true
    a2.BrickColor = BrickColor.new("New Yeller")
a2.Color = Color3.new(r/255,g/255,b/255)
a2.Material = "Neon"
a2.Transparency = 0.5
a2.Shape = "Cylinder"
    a2.CanCollide = false
local ba = Instance.new("Part",Char)
    ba.Name = "HitDirect"  
    ba.Anchored = true
    ba.BrickColor = BrickColor.new("Cool yellow")
ba.Material = "Neon"
ba.Transparency = 1
    ba.CanCollide = false
    local ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
    local ignore = Char
    local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
    a.BottomSurface = 10
    a.TopSurface = 10
    a2.BottomSurface = 10
    a2.TopSurface = 10
    local distance = (orb.CFrame.p - position).magnitude
    a.Size = Vector3.new(distance, 1, 1)
    a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
    a2.Size = Vector3.new(distance, 1, 1)
    a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
game:GetService("Debris"):AddItem(a, 20)
game:GetService("Debris"):AddItem(a2, 20)
game:GetService("Debris"):AddItem(ba, 20)
local msh = Instance.new("SpecialMesh",a)
msh.MeshType = "Cylinder"
msh.Scale = V3.N(1,5*5,5*5)
local msh2 = Instance.new("SpecialMesh",a2)
msh2.MeshType = "Cylinder"
msh2.Scale = V3.N(1,6*5,6*5)
 
for i = 0,10,0.1 do
swait()
CameraEnshaking(1,5)
a2.Color = Color3.new(r/255,g/255,b/255)
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
if typrot == 1 then
rotation = rotation + 2.5
elseif typrot == 2 then
rotation = rotation - 2.5
end
Root.CFrame = FaceMouse()[1]
a.Size = Vector3.new(distance, 1, 1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
a2.Size = Vector3.new(distance, 1, 1)
a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
msh.Scale = msh.Scale - V3.N(0,0.05*1,0.05*1)
msh2.Scale = msh2.Scale - V3.N(0,0.06*1,0.06*1)
RsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,Color3.new(r/255,g/255,b/255),0)
RsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,Color3.new(r/255,g/255,b/255),0)
MagniDamage(ba, 1, 5,25, 0, "Normal")
end
a:Destroy()
a2:Destroy()
ba:Destroy()
orb:Destroy()
orbe:Destroy()
legAnims=true
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end

local FANTASTICNINJAMODE1 = false
local FANTASTICNINJAMODE2 = false
local FANTASTICNINJAMODE3 = false
local FANTASTICNINJAMODE4 = false
local FANTASTICNINJAMODE5 = false

function NinjasWip()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
local NINJAval = math.random(1,255)
local NINJAclr = Color3.fromRGB(NINJAval,NINJAval,0)
local rngb = Instance.new("Part", Char)
        rngb.Anchored = true
        rngb.Color = NINJAclr
        rngb.CanCollide = false
        rngb.FormFactor = 3
        rngb.Name = "Ring"
        rngb.Material = "Neon"
        rngb.Size = Vector3.new(1, 0.05, 1)
        rngb.Transparency = 1
        rngb.TopSurface = 0
        rngb.BottomSurface = 0
        local rngmb = Instance.new("SpecialMesh", rngb)
        rngmb.MeshType = "Brick"
rngmb.Name = "SizeMesh"
rngmb.Scale = V3.N(0,1,0)
local orb = rngb:Clone()
orb.Parent = Char
orb.Transparency = 0
orb.Color = NINJAclr
orb.Size = V3.N(1,1,1)
local orbmish = orb.SizeMesh
orbmish.Scale = V3.N(0,0,0)
orbmish.MeshType = "Sphere"
local orbe = rngb:Clone()
orbe.Parent = Char
orbe.Transparency = 0
orbe.Size = V3.N(1,1,1)
local orbmish2 = orbe.SizeMesh
orbmish2.Scale = V3.N(0,0,0)
orbmish2.MeshType = "Sphere"
orbe.Color = NINJAclr
Hum.AutoRotate = false
rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
for i = 0,5,0.1 do
swait()
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
swait()
local Alpha = .3
RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
Root.CFrame = FaceMouse()[1]
end
orbe.Transparency = 1
orb.Transparency = 1
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*5
CFuncs["Sound"].Create("rbxassetid://294188875", Char, 1, 1)
local a = Instance.new("Part",Char)
    a.Name = "Direction"   
    a.Anchored = true
    a.Color = NINJAclr
a.Material = "Neon"
a.Transparency = 0
a.Shape = "Cylinder"
    a.CanCollide = false
local a2 = Instance.new("Part",Char)
    a2.Name = "Direction"  
    a2.Anchored = true
    a2.Color = NINJAclr
a2.Color = NINJAclr
a2.Material = "Neon"
a2.Transparency = 0.5
a2.Shape = "Cylinder"
    a2.CanCollide = false
local ba = Instance.new("Part",Char)
    ba.Name = "HitDirect"  
    ba.Anchored = true
    ba.Color = NINJAclr
ba.Material = "Neon"
ba.Transparency = 1
    ba.CanCollide = false
    local ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
    local ignore = Char
    local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
    a.BottomSurface = 10
    a.TopSurface = 10
    a2.BottomSurface = 10
    a2.TopSurface = 10
    local distance = (orb.CFrame.p - position).magnitude
    a.Size = Vector3.new(distance, 1, 1)
    a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
    a2.Size = Vector3.new(distance, 1, 1)
    a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
game:GetService("Debris"):AddItem(a, 20)
game:GetService("Debris"):AddItem(a2, 20)
game:GetService("Debris"):AddItem(ba, 20)
local msh = Instance.new("SpecialMesh",a)
msh.MeshType = "Cylinder"
msh.Scale = V3.N(1,5*5,5*5)
local msh2 = Instance.new("SpecialMesh",a2)
msh2.MeshType = "Cylinder"
msh2.Scale = V3.N(1,6*5,6*5)
 
for i = 0,10,0.1 do
swait()
CameraEnshaking(1,5)
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
if typrot == 1 then
rotation = rotation + 2.5
elseif typrot == 2 then
rotation = rotation - 2.5
end
Root.CFrame = FaceMouse()[1]
a.Size = Vector3.new(distance, 1, 1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
a2.Size = Vector3.new(distance, 1, 1)
a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
msh.Scale = msh.Scale - V3.N(0,0.05*1,0.05*1)
msh2.Scale = msh2.Scale - V3.N(0,0.06*1,0.06*1)
NsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,Color3.fromRGB(NINJAval,NINJAval,0),0)
NsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,Color3.fromRGB(NINJAval,NINJAval,0),0)
MagniDamage(ba, 1, 5,25, 0, "Normal")
end
a:Destroy()
a2:Destroy()
ba:Destroy()
orb:Destroy()
orbe:Destroy()
legAnims=true
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end

function Wip()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
local NINJAclr = Color3.fromRGB(0,0,0)
local rngb = Instance.new("Part", Char)
        rngb.Anchored = true
        rngb.Color = NINJAclr
        rngb.CanCollide = false
        rngb.FormFactor = 3
        rngb.Name = "Ring"
        rngb.Material = "Neon"
        rngb.Size = Vector3.new(1, 0.05, 1)
        rngb.Transparency = 1
        rngb.TopSurface = 0
        rngb.BottomSurface = 0
        local rngmb = Instance.new("SpecialMesh", rngb)
        rngmb.MeshType = "Brick"
rngmb.Name = "SizeMesh"
rngmb.Scale = V3.N(0,1,0)
 
local orb = rngb:Clone()
orb.Parent = Char
orb.Transparency = 0
orb.Color = NINJAclr
orb.Size = V3.N(1,1,1)
local orbmish = orb.SizeMesh
orbmish.Scale = V3.N(0,0,0)
orbmish.MeshType = "Sphere"
 
local orbe = rngb:Clone()
orbe.Parent = Char
orbe.Transparency = 0
orbe.Size = V3.N(1,1,1)
local orbmish2 = orbe.SizeMesh
orbmish2.Scale = V3.N(0,0,0)
orbmish2.MeshType = "Sphere"
orbe.Color = NINJAclr
 
Hum.AutoRotate = false
rngb:Destroy()
--[[CFuncs["Sound"].Create("rbxassetid://136007472", orb, 1.5, 1)
local scaled = 1
for i = 0,5,0.1 do
swait()
scaled = scaled - 0.02
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
orbmish.Scale = orbmish.Scale + vt(scaled/1.5,scaled/1.5,scaled/1.5)
orbmish2.Scale = orbmish2.Scale + vt(scaled*1.1/1.5,scaled*1.1/1.5,scaled*1.1/1.5)
orb.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
orbe.CFrame = root.CFrame*CFrame.new(0,0.5,0) + root.CFrame.lookVector*11.5
sphereMKCharge(2.5,-0.5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,25)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-0.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(10),math.rad(0)),.3)
RootPart.CFrame = FaceMouse()[1]
end]]--
for i = 0,5,0.1 do
swait()
if rainbowmode == true then
orbe.Color = Color3.new(r/255,g/255,b/255)
end
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            orbe.Color = color
        end
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*11.5
swait()
local Alpha = .3
RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
Root.CFrame = FaceMouse()[1]
end
orbe.Transparency = 1
orb.Transparency = 1
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*5
CFuncs["Sound"].Create("rbxassetid://294188875", Char, 1, 1)
local a = Instance.new("Part",Char)
    a.Name = "Direction"   
    a.Anchored = true
    a.Color = NINJAclr
a.Material = "Neon"
a.Transparency = 0
a.Shape = "Cylinder"
    a.CanCollide = false
local a2 = Instance.new("Part",Char)
    a2.Name = "Direction"  
    a2.Anchored = true
    a2.Color = NINJAclr
a2.Color = NINJAclr
a2.Material = "Neon"
a2.Transparency = 0.5
a2.Shape = "Cylinder"
    a2.CanCollide = false
local ba = Instance.new("Part",Char)
    ba.Name = "HitDirect"  
    ba.Anchored = true
    ba.Color = NINJAclr
ba.Material = "Neon"
ba.Transparency = 1
    ba.CanCollide = false
    local ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
    local ignore = Char
    local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
    a.BottomSurface = 10
    a.TopSurface = 10
    a2.BottomSurface = 10
    a2.TopSurface = 10
    local distance = (orb.CFrame.p - position).magnitude
    a.Size = Vector3.new(distance, 1, 1)
    a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
    a2.Size = Vector3.new(distance, 1, 1)
    a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
game:GetService("Debris"):AddItem(a, 20)
game:GetService("Debris"):AddItem(a2, 20)
game:GetService("Debris"):AddItem(ba, 20)
local msh = Instance.new("SpecialMesh",a)
msh.MeshType = "Cylinder"
msh.Scale = V3.N(1,5*5,5*5)
local msh2 = Instance.new("SpecialMesh",a2)
msh2.MeshType = "Cylinder"
msh2.Scale = V3.N(1,6*5,6*5)
 
for i = 0,10,0.1 do
swait()
CameraEnshaking(1,5)
a2.Color = NINJAclr
orb.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
orbe.CFrame = Root.CFrame*CFrame.new(0,0.5,0) + Root.CFrame.lookVector*4
ray = Ray.new(
        orb.CFrame.p,                           -- origin
        (Mouse.Hit.p - orb.CFrame.p).unit * 1000 -- direction
    )
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
if typrot == 1 then
rotation = rotation + 2.5
elseif typrot == 2 then
rotation = rotation - 2.5
end
Root.CFrame = FaceMouse()[1]
a.Size = Vector3.new(distance, 1, 1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
a2.Size = Vector3.new(distance, 1, 1)
a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
a2.CFrame = a2.CFrame*CFrame.Angles(0,math.rad(90),0)
msh.Scale = msh.Scale - V3.N(0,0.05*1,0.05*1)
msh2.Scale = msh2.Scale - V3.N(0,0.06*1,0.06*1)
RsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,NINJAclr,0)
RsphereMK(5,1.5,"Add",ba.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),15,15,25,-0.15,NINJAclr,0)
MagniDamage(ba, 1, 5,25, 0, "Normal")
end
a:Destroy()
a2:Destroy()
ba:Destroy()
orb:Destroy()
orbe:Destroy()
legAnims=true
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end

function sphere(bonuspeed,type,pos,scale,value,color,heart,invert,notaffectbychaosrainbow)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
   
 
if(heart)then
    rngm.MeshType = Enum.MeshType.FileMesh
    rngm.MeshId = "rbxassetid://105992239"
    rngm.Offset = Vector3.new(0,0,-.25)
end
rngm.Scale = scale
if rainbowmode == true and not notaffectbychaosrainbow then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true and not notaffectbychaosrainbow then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true and not notaffectbychaosrainbow then
rng.BrickColor = BrickColor.random()
end
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            rng.Color = color
        end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
if(invert)then
    if(heart)then
        rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
    else
        rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
    end
else
    if(heart)then
        rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
    else
        rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
    end
end
rng.CFrame = pos
end
rng:Destroy()
end))
end

function orb_spawn_norm(positted,timer,color,MagniBoost,min,max,volEx,ShakePower,volSummon)
local orb = Instance.new("Part", Char)
        orb.Anchored = true
        orb.BrickColor = color
        orb.CanCollide = false
        orb.FormFactor = 3
        orb.Name = "Ring"
        orb.Material = "Neon"
        orb.Size = Vector3.new(1, 1, 1)
        orb.Transparency = 0
        orb.TopSurface = 0
        orb.BottomSurface = 0
        local orbm = Instance.new("SpecialMesh", orb)
        orbm.MeshType = "Sphere"
orb.CFrame = positted
orbm.Name = "SizeMesh"
orbm.Scale = V3.N(1,1,1)
coroutine.wrap(function()
    while orb and orb.Parent do
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            orb.Color = color
        end
        swait()
    end
end)()
CFuncs["Sound"].Create("rbxassetid://183763506", orb, volSummon, 1)
sphere(2.5,"Add",orb.CFrame,V3.N(1,1,1),0.05,orb.BrickColor)
--[[for i = 0, 2 do
sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
end]]--
coroutine.resume(coroutine.create(function()
wait(timer)
CameraEnshaking(3,ShakePower)
orb.Transparency = 1
MagniDamage(orb, 3.5*MagniBoost, min,max, 0, "Normal")
sphere(5,"Add",orb.CFrame,V3.N(1,1,1),0.1*MagniBoost,orb.BrickColor)
--[[for i = 0, 4 do
sphereMK(5,0.15*MagniBoost,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
end]]--
CFuncs["Sound"].Create("rbxassetid://192410089", orb, volEx, 0.7)
wait(3)
orb:Destroy()
end))
end

function orb_spawn(positted,timer)
local orb = Instance.new("Part", Char)
        orb.Anchored = true
        orb.BrickColor = BrickColor.new("White")
 
        orb.CanCollide = false
        orb.FormFactor = 3
        orb.Name = "Ring"
        orb.Material = "Neon"
        orb.Size = Vector3.new(1, 1, 1)
        orb.Transparency = 0
        orb.TopSurface = 0
        orb.BottomSurface = 0
        local orbm = Instance.new("SpecialMesh", orb)
        orbm.MeshType = "Sphere"
orb.CFrame = positted
orbm.Name = "SizeMesh"
orbm.Scale = V3.N(1,1,1)
CFuncs["Sound"].Create("rbxassetid://183763506", orb, 1.5, 1)
sphere(2.5,"Add",orb.CFrame,V3.N(1,1,1),0.025,orb.BrickColor)
coroutine.wrap(function()
    while orb and orb.Parent do
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            orb.Color = color
        end
        swait()
    end
end)()
for i = 0, 2 do
sphereMK(5,0.15,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.5,1.5,7.5,-0.015,orb.BrickColor,0)
end
 
coroutine.resume(coroutine.create(function()
wait(timer)
CameraEnshaking(3,2)
orb.Transparency = 1
MagniDamage(orb, 17.5, 10,50, 0, "Normal")
sphere(5,"Add",orb.CFrame,V3.N(1,1,1),0.5,orb.BrickColor)
for i = 0, 4 do
sphereMK(5,0.65,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,orb.BrickColor,0)
end
CFuncs["Sound"].Create("rbxassetid://192410089", orb, 2, 0.7)
wait(3)
orb:Destroy()
end))
end

function scatteryourinnerglitch()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
local rot = 0
local randomrotations = math.random(1,2)
local lookv = 2.5
local power = 5
sphere(1,"Add",Root.CFrame,V3.N(1,100000,1),0.5,BrickColor.new("Royal purple"))
sphere(1,"Add",Root.CFrame,V3.N(1,1,1),0.75,BrickColor.new("Royal purple"))
for i = 0, 9 do
sphereMK(1,1.5,"Add",Root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),10,10,45,-0.1,BrickColor.new("Royal purple"),0)
end
local hite = Instance.new("Part", Char)
        hite.Anchored = true
        hite.CanCollide = false
        hite.FormFactor = 3
        hite.Name = "Ring"
        hite.Material = "Neon"
        hite.Size = Vector3.new(1, 1, 1)
        hite.Transparency = 1
        hite.TopSurface = 0
        hite.BottomSurface = 0
hite.CFrame = Root.CFrame*CFrame.new(0,-2.5,0)
local rem = Instance.new("Part", Char)
        rem.Anchored = true
        rem.CanCollide = false
        rem.FormFactor = 3
        rem.Name = "Ring"
        rem.Material = "Neon"
        rem.Size = Vector3.new(1, 1, 1)
        rem.Transparency = 1
        rem.TopSurface = 0
        rem.BottomSurface = 0
rem.CFrame = hite.CFrame
local rem2 = rem:Clone()
rem2.Parent = Char
rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
local rem3 = rem:Clone()
rem3.Parent = Char
rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
local rem4 = rem:Clone()
rem4.Parent = Char
rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
hite:Destroy()
coroutine.resume(coroutine.create(function()
for i = 0, 24 do
swait(1)
if randomrotations == 1 then
rot = rot + 1
elseif randomrotations == 2 then
rot = rot - 1
end
power = power + 0.5
lookv = lookv + 7.5
rem.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(rot),0)
rem2.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(90),0)
rem3.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(180),0)
rem4.CFrame = rem.CFrame*CFrame.Angles(0,math.rad(270),0)
orb_spawn_norm(rem.CFrame + rem.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
orb_spawn_norm(rem2.CFrame + rem2.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
orb_spawn_norm(rem3.CFrame + rem3.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
orb_spawn_norm(rem4.CFrame + rem4.CFrame.lookVector*lookv,3,BrickColor.new("Royal purple"),power,25,75,10,power/5,7.5)
end
end))
Attack = false
end
function yinyangi()
Attack = true
for i = 0, 2, 0.1 do
swait()
end
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = Root.CFrame.lookVector*175
bv.Parent = Root
for Rotations = 0, 9 do
 
for i = 0, 1, 0.5 do
swait()
bv.velocity = Root.CFrame.lookVector*175
end
 
orb_spawn(RArm.CFrame*CFrame.new(0,-1,0),2.5)
for i = 0, 1, 0.5 do
swait()
bv.velocity = Root.CFrame.lookVector*175
end
 
orb_spawn(RArm.CFrame*CFrame.new(0,-1,0),2.5)
for i = 0, 1, 0.5 do
swait()
bv.velocity = Root.CFrame.lookVector*175
end
 
orb_spawn(RArm.CFrame*CFrame.new(0,-1,0),2.5)
for i = 0, 1, 0.5 do
swait()
bv.velocity = Root.CFrame.lookVector*175
end
 
orb_spawn(RArm.CFrame*CFrame.new(0,-1,0),2.5)
end
bv:Destroy()
legAnims=true
local orig=WalkSpeed
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end

function FindNearestHead(Position, Distance, SinglePlayer)
    if SinglePlayer then
        return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
    end
    local List = {}
    for i, v in pairs(workspace:GetChildren()) do
        if v:IsA("Model") then
            if v:findFirstChild("Head") then
                if v ~= Char then
                    if (v.Head.Position - Position).magnitude <= Distance then
                        table.insert(List, v)
                    end
                end
            end
        end
    end
    return List
end

function dmgstart(dmg,what)
    hitcon = what.Touched:connect(function(hit)
        local hum = hit.Parent:FindFirstChild("Humanoid")
        if hum and not hum:IsDescendantOf(Char) then
            hum:TakeDamage(dmg)
        end
    end)
end
 
function dmgstop()
    hitcon:disconnect()
end

function dmg(dude)
if dude.Name ~= Char then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
local torso = dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso'
for i = 1, 10 do
    sphereMK(1.5,2,"Add",torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1,1,25,-.01,BrickColor.new("White"),0,true)
end
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", Char, 0.5, 0.3)
 
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://284205403"
bld.Color = ColorSequence.new(Color3.new(1,1,1))
bld.Rate = 50
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
v.Color = Color3.new(1,1,1)
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.02
end
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
bld.Speed = NumberRange.new(1,5)
bld.Acceleration = V3.N(0,10,0)
wait(0.5)
bld.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end
end

function Stompie()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
for i = 0, 2, 0.1 do
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.1,0)*CF.A(M.R(25),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.75,-.5),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-25),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-25),0,M.R(-15)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-25),0,M.R(15)),Alpha)
			swait()
end
CFuncs["Sound"].Create("rbxassetid://438666141", Root, 7.5,1)
CFuncs["Sound"].Create("rbxassetid://1208650519", Root, 7.5, 1)
CameraEnshaking(4,12)
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 52.5)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
sphere(5,"Add",Root.CFrame*CFrame.new(0,-2.9,0),V3.N(0,0,0),1,BrickColor.random())
sphere(10,"Add",Root.CFrame*CFrame.new(0,-2.9,0),V3.N(0,0,0),2,BrickColor.random())
sphere(1,"Add",Root.CFrame*CFrame.new(0,-2.9,0),V3.N(100,0.1,100),0.01,BrickColor.random())
		local PlayerSize = 1
		local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)
		repeat swait() hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char) until hitfloor
		Sound(Root,438666141,1,7.5,false,true,true)
for i = 0, 2, 0.1 do
swait()
sphereMK(2.5,0.75,"Add",Root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
sphereMK(2.5,0.75,"Add",Root.CFrame*CFrame.new(math.random(-52.5,52.5),-5,math.random(-52.5,52.5))*CFrame.Angles(math.rad(90 + math.rad(math.random(-45,45))),math.rad(math.random(-45,45)),math.rad(math.random(-45,45))),2.5,2.5,25,-0.025,BrickColor.random(),0)
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.1,0)*CF.A(M.R(-25),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0,-.5)*CF.A(M.R(25),0,0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(25),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-25),0,M.R(-15)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-25),0,M.R(15)),Alpha)
			swait()
end
legAnims=true
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,heart,invert)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
if(heart)then
    rngm.MeshType = Enum.MeshType.FileMesh
    rngm.MeshId = "rbxassetid://105992239"
    rngm.Offset = Vector3.new(0,0,-.25)
end
rngm.Scale = V3.N(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
        if glitchymode then
            local val = math.random(1,255)
            local color = Color3.fromRGB(val,val,val)
            rng.Color = color
        end
speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
if(invert)then rng.CFrame = rng.CFrame - rng.CFrame.lookVector*speeder*bonuspeed else rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed end
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function InsaneStompie()
Attack = true
NeutralAnims = false
local orig=WalkSpeed
WalkSpeed=4
legAnims=false
for i = 0, 8, 0.1 do
swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.1,0)*CF.A(M.R(25),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.75,-.5),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-25),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-25),0,M.R(-15)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-25),0,M.R(15)),Alpha)
			swait()end
CFuncs["Sound"].Create("rbxassetid://438666141", Root, 7.5,1)
CFuncs["Sound"].Create("rbxassetid://1208650519", Root, 7.5, 1)
CameraEnshaking(8,24)
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 105)) do
if v:FindFirstChild('Head') then
dmg(v)
end
	end
local HCF = Root.CFrame * CF.N(0,-0.1,0) * CF.A(0,0,0)
Effect({
Color = color,
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF,
Size = Vector3.new(V3.N(200,0.1,200)),
EndSize = Vector3.new(V3.N(0.05,0.1,0.05)),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
CFuncs["Sound"].Create("rbxassetid://907329669", Root, 10, 1)
		local PlayerSize = 1
		local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)
		repeat swait() hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char) until hitfloor
for i = 0, 2, 0.1 do
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-.1,0)*CF.A(M.R(-25),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0,-.5)*CF.A(M.R(25),0,0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(25),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-25),0,M.R(-15)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-25),0,M.R(15)),Alpha)
			swait()
end
legAnims=true
WalkSpeed=orig
NeutralAnims = true
Hum.AutoRotate = true
Attack = false
end
	
function VaporTaunt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"You need to chill out.."
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
		RJ.C0 = RJ.C0:lerp(CF.N(-0.1,-0.1-.1*M.S(Sine/36),0.6)*CF.A(M.R(55.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.6,-1.2,-0.1)*CF.A(M.R(56.3+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.9,-1.2,-0.2)*CF.A(M.R(25+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.2)*CF.A(M.R(61-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-38.9-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
	end

UIS.InputBegan:connect(function(io,gpe)
	if(gpe or Attack or data.User~=data.Local)then return end
	--MODES
	if(io.KeyCode == Enum.KeyCode.One and Mode~='Glitchy')then 
		changeMode'Glitchy'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Two and Mode~='Iniquitous')then 
		changeMode'Iniquitous'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Three and Mode~='Mythical')then 
		changeMode'Mythical'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Four and Mode~='Ruined')then 
		changeMode'Ruined'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Five and Mode~='Atramentous')then 
		changeMode'Atramentous'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Six and Mode~='Subzero')then 
		changeMode'Subzero'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Seven and Mode~='Troubadour')then 
		changeMode'Troubadour'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Eight and Mode~='Legendary')then 
		changeMode'Legendary'
		Torso.song.PlaybackSpeed = 0.85
	elseif(io.KeyCode == Enum.KeyCode.Nine and Mode~='Love')then 
		changeMode'Love'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Glitchy')then 
		changeMode'The Big Black'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='The Big Black')then 
		changeMode'Radioactive'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Mythical')then 
		changeMode'FANTASTIC NINJA'
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Iniquitous')then 
		changeMode'Solitude'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Ruined')then 
		changeMode'Sin'
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Subzero')then 
		changeMode'Purity'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Atramentous')then 
		changeMode'Justice'
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Troubadour')then 
		changeMode'RAINBOW'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Legendary')then 
		changeMode'CALAMITY'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.C and Mode~='Purity')then 
		changeMode'Purity'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.V and Mode~='Radioactive')then 
		changeMode'Radioactive'
		Torso.song.PlaybackSpeed = 1
	elseif(io.KeyCode == Enum.KeyCode.Zero and Mode~='Time')then 
		changeMode'Time'
		Torso.song.PlaybackSpeed = 1.2
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='RAINBOW')then 
		RainbowWip()
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='FANTASTIC NINJA')then 
		NinjasWip()
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='The Big Black')then 
		Wip()
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='Glitchy')then 
		scatteryourinnerglitch()
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='Ruined')then 
		Stompie()
	elseif(io.KeyCode == Enum.KeyCode.Z and Mode=='Justice')then 
		InsaneStompie()
	elseif(io.KeyCode == Enum.KeyCode.X and Mode=='Justice')then 
		JusticeSkyBeams()
	elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Love')then 
		changeMode'Lust'
	--TOGGLE MUSIC
	elseif(io.KeyCode == Enum.KeyCode.M and getMode(Mode))then 
		MusicMode=MusicMode+1
		if(MusicMode>3)then MusicMode=1 end
		if(MusicMode==1)then
			music:Pause()
			music.Volume=1
			music.Parent=Torso
			music:Resume()
		elseif(MusicMode==2)then
			music:Pause()
			music.Volume=1
			music.Parent=Char
			music:Resume()
		elseif(MusicMode==3)then
			music.Volume = 0
		end
	elseif(io.KeyCode==Enum.KeyCode.B)then
		--TAUNTS
		if(vaporwaveMode and Mode=='Troubadour')then
			VaporTaunt()
		end
	end
	if(vaporwaveMode)then return end
	--ATTACKS
	if(io.UserInputType==Enum.UserInputType.MouseButton1)then
		ClickCombo()
	end
end)

WingAnims.StarG=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1-1*M.C(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1-.025*M.S(WingSine/32))*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1-.05*M.S(WingSine/32))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1-.1*M.S(WingSine/32))*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
end

WingAnims.Glacial=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(60)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(120)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-60)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-120)),.2)
end

WingAnims.Spin1=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
end

WingAnims.Enchanter=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0-0.125*M.C(WingSine/99),4-0.25*M.C(WingSine/93),0.75-0.1*M.C(WingSine/115))*CF.A(M.R(175-5*M.C(WingSine/115)),M.R(0),M.R(0+2.5*M.C(WingSine/95))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1.5-0.25*M.C(WingSine/78),3.5-0.25*M.C(WingSine/63),0.75-0.1*M.C(WingSine/125))*CF.A(M.R(175-5*M.C(WingSine/121)),M.R(0),M.R(45-5*M.C(WingSine/65))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(-1.5-0.25*M.C(WingSine/86),3.5-0.25*M.C(WingSine/73),0.75-0.1*M.C(WingSine/118))*CF.A(M.R(175-5*M.C(WingSine/118)),M.R(0),M.R(-45+5*M.C(WingSine/58))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0-0.125*M.C(WingSine/76),-2-0.25*M.C(WingSine/66),-1)*CF.A(M.R(5-5*M.C(WingSine/104)),M.R(0),M.R(0-2.5*M.C(WingSine/87))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-2-0.25*M.C(WingSine/94),0-0.25*M.C(WingSine/79),-1)*CF.A(M.R(5-5*M.C(WingSine/111)),M.R(0),M.R(-45+5*M.C(WingSine/54))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(2-0.25*M.C(WingSine/81),0-0.25*M.C(WingSine/74),-1)*CF.A(M.R(5-5*M.C(WingSine/109)),M.R(0),M.R(45-5*M.C(WingSine/61))),.2)
end

WingAnims.OldEnchanter=function()
	RWP1W.C0=RWP1W.C0:lerp(CF.N(-5.25,3+ 1 * M.C(WingSine / 23.5),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(135+ 10 * M.C(WingSine / 47))),.3)
	RWP2W.C0=RWP2W.C0:lerp(CF.N(0,-10 + 0.75 * M.C(WingSine / 34),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0),M.R(0 + 10 * M.C(WingSine / 47))),.3)
	RWP3W.C0=RWP3W.C0:lerp(CF.N(5.25,3+ 1 * M.C(WingSine / 23.5),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(-135+ 10 * M.C(WingSine / 47))),.3)
	LWP1W.C0=LWP1W.C0:lerp(CF.N(-3.75,-2,0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(-135+ 10 * M.C(WingSine / 47))),.3)
	LWP2W.C0=LWP2W.C0:lerp(CF.N(0,1 + 0.75 * M.C(WingSine / 34),0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0),M.R(180 + 10 * M.C(WingSine / 47))),.3)
	LWP3W.C0=LWP3W.C0:lerp(CF.N(3.75,-2,0)*CF.A(M.R(0),M.R(0),M.R(0))*CF.A(M.R(0),M.R(0+ 20 * M.C(WingSine / 47)),M.R(135+ 10 * M.C(WingSine / 47))),.3)
end
WingAnims.Spin2=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,2,-1.5+1.3*M.C(WingSine/100))*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,2.5,1.5-1.3*M.C(WingSine/100))*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
end

WingAnims.Glitchy=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine+M.RNG(-300,300)/10)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine+M.RNG(-300,300)/10)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine+M.RNG(-300,300)/10)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine+M.RNG(-300,300)/10)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine+M.RNG(-300,300)/10)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0+M.RNG(-300,300)/100,1.5+M.RNG(-300,300)/100,-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine+M.RNG(-300,300)/10)),.8)
end

WingAnims.Ambustume=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2 + 0.3 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-2.5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-2 + 0.2 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,-2 + 0.1 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0-10*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2 + 0.3 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+2.5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-2 + 0.2 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,-2 + 0.1 * M.C(WingSine/32),-1)*CF.A(M.R(0),0,M.R(0+10*M.C(WingSine/32))),.2)
end

WingAnims.Chaotic=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4-0.5*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(0)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(-1.5,3.5-1*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(15-6*M.S(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(1.5,3.5-1*M.C(WingSine/32),1.5)*CF.A(M.R(180),M.R(0),M.R(-15+6*M.S(WingSine/32))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,-2-0.5*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(0)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1.5,-1.5-1*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(15-6*M.S(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.5,-1.5-1*M.C(WingSine/32),-1.5)*CF.A(M.R(0),M.R(0),M.R(-15+6*M.S(WingSine/32))),.2)
end

WingAnims.Spin3=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine)),.8)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine)),.8)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1+1*M.C(WingSine/100),-1.5)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine)),.8)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine)),.8)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine)),.8)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5-1.5*M.C(WingSine/100),-1)*CF.A(M.R(0),M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine)),.8)
end

WingAnims.StarG=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
end

WingAnims.StarJ=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/64)),0,M.R(0+5*M.C(WingSine/64))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/64)),0,M.R(15+7.5*M.C(WingSine/64))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/64)),0,M.R(30+9*M.C(WingSine/64))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/64)),0,M.R(0-5*M.C(WingSine/64))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/64))*CF.A(M.R(10+15*M.C(WingSine/64)),0,M.R(-15-7.5*M.C(WingSine/64))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/64)),0,M.R(-30-9*M.C(WingSine/64))),.2)
end

WingAnims.Cytus=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15*M.C(WingSine/32),1.5+.35*M.S(WingSine/32),-1)*CF.A(0,0,M.R(60+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1*M.C(WingSine/32),1.5+.25*M.C(WingSine/32),-1)*CF.A(0,0,M.R(90+2.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),1.5-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(120-5*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15*M.C(WingSine/32),1.5-.15*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-60-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1*M.C(WingSine/32),1.5+.3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-90-2.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),1.5+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-120+5*M.C(WingSine/32))),.2)
end

WingAnims.Aprins=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(90+5000*M.C(WingSine/400))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(120+5000*M.C(WingSine/400))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(-90+5000*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120+5000*M.C(WingSine/400))),.2)
end

WingAnims.NebG1=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(60)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(120)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-60)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-120)),.2)
end

WingAnims.NebG2=function(div)
	div=div or 25
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+2000*M.R(WingSine/div))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+2000*M.R(WingSine/div))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120+2000*M.R(WingSine/div))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-2000*M.R(WingSine/div))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120-2000*M.R(WingSine/div))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120-2000*M.R(WingSine/div))),.2)
end

WingAnims.NebG3=function(mult)
	mult=mult or 1
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine*mult)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine*mult)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine*mult)),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine*mult)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine*mult)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine*mult)),.2)
end

WingAnims.LustFrench=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
end

if(data.User==data.Local)then
	Player.Chatted:connect(function(m)
		if(m:sub(1,3) == "/e")then m=m:sub(4) end
		if(m:sub(1,5) == "play/")then
			getMode('Troubadour').Music=Playlist[m:sub(6)] or tonumber(m:sub(6)) or 0
			music.SoundId="rbxassetid://"..getMode('Troubadour').Music;
		elseif(m:sub(1,5) == "tpos/")then
			music.TimePosition = tonumber(m:sub(6)) or 0
		elseif(m:sub(1,6) == "pitch/")then
			music.Pitch = tonumber(m:sub(7)) or 0
			getMode('Troubadour').Pitch=music.Pitch
		end
	end)
end

--[[local bigblackglitching = camshakeins.new(5,10,0,0)
bigblackglitching.RotationInfluence=Vector3.new(0,0,5)
bigblackglitching.PositionInfluence=Vector3.new(.2,.2,.2)
bigblackglitching:SetScaleMagnitude(0)--]]

function Effect(data)
	if(data.User==data.Local)then
		--req:Push("Broadcast","effect",data)
		GotEffect(data)
	end
end

AddRecievereffect = function(data)
	if(data.User~=data.Local)then
		GotEffect(data)
	end
end

function sphereMKa(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

--camShake:ShakeSustain(bigblackglitching)

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if (Mode=='Mythical') then
			
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if (Mode=='Justice') then
local HCF = Root.CFrame * CF.N(math.random(-10,10),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
local HCF2 = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-180,180)),M.R(math.random(-180,180)),M.R(math.random(-180,180)))
Effect({
Color = Color3.fromRGB(242, 243, 243),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF2,
EndPos = HCF2* CF.N(0,10,0),
Size = Vector3.new(0.1, 2, 0.1),
EndSize = Vector3.new(0.05, 2, 0.05),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
Effect({
Color = Color3.fromRGB(242, 243, 243),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.4, 3, 0.4),
EndSize = Vector3.new(0.3, 2, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.4,
})
Effect({
Color = Color3.fromRGB(242, 243, 243),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if (Mode=='Sin') then
local HCF = Root.CFrame * CF.N(math.random(-90,90),0,(math.random(-90,90))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1, 2, 0.1),
EndSize = Vector3.new(0.05, 2, 0.05),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
		end
	end
end))

function HeartMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
        rngm.MeshId = "rbxassetid://1717707957"
        rngm.TextureId = "http://www.roblox.com/asset/?id=269748808"
        rngm.VertexColor = Vector3.new(255,1.5,5)
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function HeartMK1(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
        rngm.MeshId = "rbxassetid://1717708486"
        rngm.TextureId = "http://www.roblox.com/asset/?id=269748808"
        rngm.VertexColor = Vector3.new(255,1.5,5)
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if (Mode=='RAINBOW') then
Effect({
Color = Color3.new(r/255,g/255,b/255),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame*CF.N(M.RNG(-15,15),-3,M.RNG(-15,15)),
EndPos = Root.CFrame*CF.N(M.RNG(-15,15),-3,M.RNG(-15,15)),
Size = Vector3.new(.5,.5,.5),
EndSize = Vector3.new(.5,25,.5),
Transparency = NumberRange.new(0,1),
Lifetime = 0.25,
})
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if (Mode=='Glitchy') then
local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = color,
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(2,7,2),
EndSize = Vector3.new(2,12,2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
		end
	end
end))

while true do
	swait()
	ClickTimer=math.max(ClickTimer-1,0)
	if(ClickTimer<=0 and Combo~=1)then
		print('reset')
		Combo=1
	end
	Sine=Sine+Change
	hue=hue+1
	if(hue>360)then hue=1 end
	local hitfloor,posfloor = workspace:FindPartOnRayWithIgnoreList(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), {Effects,Char})
	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y < -1 and "Fall" or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
	Hum.WalkSpeed = WalkSpeed
	local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local sidevelocity = sidevec/Hum.WalkSpeed
	local forwardvelocity = forwardvec/Hum.WalkSpeed
	
	local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LLeg.CFrame.p,((CFrame.new(LLeg.Position,LLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char})
	local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RLeg.CFrame.p,((CFrame.new(RLeg.Position,RLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char})
	if(Mode=='Troubadour' and IsVaporwave(getMode'Troubadour'.Music))then
		vaporwaveMode=true
		text.Text=''
		WingAnim='NebG3'
	else
		if(Mode=='Troubadour')then
			text.Text='Troubadour'
			WingAnim=getMode'Troubadour'.WingAnim
		end
		vaporwaveMode=false
	end
	
	if(Mode~='Lust' and WingAnim and WingAnims[WingAnim])then
		WingAnims[WingAnim]()
	elseif(Mode=='Lust')then
		if(State=='Idle')then
			WingAnims.LustFrench()
		else
			WingAnims.NebG3(1)	
		end
	elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
		local gay={unpack(WingAnim)};
		table.remove(gay,1)
		WingAnims[WingAnim[1]](unpack(gay))
	else
		WingAnims.NebG1()
	end
	
	if(Mode=='Troubadour' and NeutralAnims)then
		WingSine=WingSine+(0.1+music.PlaybackLoudness/300)
	else
		WingSine=WingSine+1
	end
	
	if(music)then
		if(Mode=='Troubadour')then
			local clr = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1))
			local clr2 = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/950,0,1))
			text.TextColor3 = clr
			PrimaryColor = clr2
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr2
				elseif(v:IsA'Trail')then
					v.Enabled = true
					v.Color = ColorSequence.new(clr2)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='RAINBOW')then
			local clr = Color3.new(r/255,g/255,b/255)
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr)
					v.Enabled = true
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='Glitchy')then
			local val = math.random(1,255)
			local clr = Color3.fromRGB(val,val,val)
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Ring" or v.Name == "Direction" or v.Name == "HitDirect") then
					v.Color = clr
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr)
					v.Enabled = true
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='Time')then
			local clr = BrickColor.new("Artichoke").Color
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Ring" or v.Name == "Direction" or v.Name == "HitDirect") then
					v.Color = clr
				end
			end			
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 0
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 0
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr)
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = true
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='FANTASTIC NINJA')then
			local val = math.random(1,255)
			local clr = Color3.fromRGB(val,val,0)
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Ring" or v.Name == "Direction" or v.Name == "HitDirect") then
					v.Color = clr
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr)
					v.Enabled = true
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='Ruined')then
			local clr = Color3.fromRGB(190,104,98)
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Ring" or v.Name == "Direction" or v.Name == "HitDirect") then
					v.Color = clr
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr)
					v.Enabled = true
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(music)then
		if(Mode=='Justice')then
			local clr = Color3.fromRGB(248,248,248)
			text.TextColor3 = clr
			text.TextStrokeColor3 = clr
			PrimaryColor = clr
			--[[for _,v in next, Char:GetDescendants() do
				if (v.Name == "Union") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Halo" or v.Name == "a1" or v.Name == "a2" or v.Name == "HAL") then
					v.Transparency = 5
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Ring" or v.Name == "Direction" or v.Name == "HitDirect") then
					v.Color = clr
				end
			end
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr
				elseif(v:IsA'Trail')then
					v.Enabled = true
					v.Color = ColorSequence.new(clr)
				elseif(v:IsA'ParticleEmitter')then
					v.Color = ColorSequence.new(clr)
				end
			end
			for _,v in next, Char:GetDescendants() do
				if (v.Name == "Trail2") then
					v.Enabled = false
				end
			end
			for _,v in next, Effects:GetDescendants() do
				if(v:IsA'Part')then
					v.Color = clr
				end
			end--]]
		end
	end
	
	if(Mode=='The Big Black') or (Mode=='Solitude') then
		local pos = Head.Position
		local dist = (camera.CFrame.p-pos).magnitude
		local DropDist = 1
		local IneffectiveDist = 15
		local modifier = dist < DropDist and 1 or dist < IneffectiveDist and (0 - 1) / (IneffectiveDist - DropDist) * (dist - DropDist) + 1 or 0

		--bigblackglitching:SetScaleMagnitude(modifier)
	else
		--bigblackglitching:SetScaleMagnitude(0)
	end
	
	if(Mode=='Troubadour' and data.User==data.Local)then
		Tween(camera,{FieldOfView=70-(music.PlaybackLoudness/20)},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)
	else
		Tween(camera,{FieldOfView=70},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)
	end
	
	if(State == 'Idle')then
		if(Mode=='Troubadour' and NeutralAnims and not vaporwaveMode)then Change = 0.1+music.PlaybackLoudness/200 else Change = 1 end
		if(Mode=='Achromatic') or (Mode=='Achromatic')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Iniquitous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
				if(M.RNG(1,45)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
				end
			end
		elseif(Mode=='Mythical')then
			local Alpha = .1
			if(NeutralAnims)then	
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Alder'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.3,2,.3);
					EndSize=Vector3.new(.1,1,.1);
				}
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-15),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,0+.05*M.S(Sine/32),-.5)*CF.A(M.R(15+1.5*M.C(Sine/51)),M.R(5+5*M.C(Sine/57)),M.R(85-5*M.C(Sine/46))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Ruined') or (Mode=='Glitchy') or (Mode=='Sin') then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-5+1*M.S(Sine/64)),M.R(-25),0),Alpha)
				if(M.RNG(1,25)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(35),M.R(-10))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-10),M.R(25),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(5),0,0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		--[[elseif(Mode=='Atramentous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.2+.4*M.C(Sine/39),.5+.2*M.C(Sine/32),0)*CF.A(M.R(-2+5*M.S(Sine/58)),M.R(-15+5*M.C(Sine/42)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-7-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,0,M.R(-15+5*M.S(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,0,M.R(15-5*M.S(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.5,-.2)*CF.A(0,0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end]]
		elseif(Mode=='Atramentous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(M.R(25),M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(-3)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(3)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Subzero') or (Mode=='Purity') or (Mode=='Time') or (Mode=='RAINBOW') then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(0,M.R(28),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-7-2.5*M.S(Sine/32)),M.R(-28),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-1)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(4),M.R(-28),M.R(8)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Troubadour')then
			if(vaporwaveMode)then
			  	local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2-.1*M.S(Sine/36),0.6)*CF.A(M.R(74.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
					LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
					RS.C0 = RS.C0:lerp(CF.N(1,0.9,-0.1)*CF.A(M.R(13.7-5*M.C(Sine/42)),M.R(7.7),M.R(-136.2)),Alpha)
					NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-16.6-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
					if(legAnims)then
						LH.C0 = LH.C0:lerp(CF.N(-0.7,-1,0)*CF.A(M.R(37.2+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
						RH.C0 = RH.C0:lerp(CF.N(0.8,-1.1,-0.1)*CF.A(M.R(5.9+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
					end
				elseif(legAnims)then
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			else
				local Alpha = .3
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/20)+(music.PlaybackLoudness/5000),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(35),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0+1*M.S(Sine/24)),M.R(-35),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.A(0,0,M.R(-15+10*M.C(Sine/20))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(75-(music.PlaybackLoudness/7.5)),M.R(5),M.R(35)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.05*M.C(Sine/20)-(music.PlaybackLoudness/5000),0)*CF.A(0,M.R(25),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.05*M.C(Sine/20)-(music.PlaybackLoudness/5000),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			end
		elseif(Mode=='Infectious') then
			local Alpha = .1
			if(NeutralAnims)then	
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark indigo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark indigo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-15),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.4)*CF.A(M.R(25),M.R(5-2.5*M.C(Sine/32)),M.R(-65+1.5*M.C(Sine/32))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='FANTASTIC NINJA') then
			local Alpha = .1
			local val = math.random(1,255)
			local clr = Color3.fromRGB(val,val,0)
			if(NeutralAnims)then	
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=clr;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=clr;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-15),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.4)*CF.A(M.R(25),M.R(5-2.5*M.C(Sine/32)),M.R(-65+1.5*M.C(Sine/32))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Love')then
			Change = 1
			local Alpha = .6
			if(NeutralAnims)then	
			  SetTween(RJ,{C0 = CF.N(0,0 + 0.1 * math.cos(Sine/26),0)*CF.A(math.rad(0),math.rad(0 - 3 * math.cos(Sine/26)),math.rad(0 - 10 * math.sin(Sine/26)))},"Quad","Out",Alpha)
			  SetTween(LS,{C0 = CF.N(-1.15,0.4,-0.5)*CF.A(math.rad(-6.5),math.rad(13.6 + 3 * math.sin(Sine/26)),math.rad(45.8))},"Quad","Out",Alpha)
			  SetTween(RS,{C0 = CF.N(1.15,0.4,-0.5)*CF.A(math.rad(-6.5),math.rad(-13.6 + 3 * math.sin(Sine/26)),math.rad(-45.8))},"Quad","Out",Alpha)
			  SetTween(NK,{C0 = CF.N(0,1.5,-0.1)*CF.A(math.rad(-7),math.rad(0 - 5 * math.sin(Sine/26)),math.rad(0  - 5 * math.cos(Sine/26)))},"Quad","Out",Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
			  SetTween(LH,{C0 = CF.N(0,0 - 0.1 * math.cos(Sine/26),0)*CF.A(math.rad(0),math.rad(0 + 3 * math.cos(Sine/26)),math.rad(0 + 10 * math.sin(Sine/26))) * CF.N(-0.5,-1,0)*CF.A(math.rad(0),math.rad(0),math.rad(5))},"Quad","Out",Alpha)
			  SetTween(RH,{C0 = CF.N(0,0 - 0.1 * math.cos(Sine/26),0)*CF.A(math.rad(0),math.rad(0 + 3 * math.cos(Sine/26)),math.rad(0 + 10 * math.sin(Sine/26))) * CF.N(0.5,-1,0)*CF.A(math.rad(0),math.rad(0),math.rad(-5))},"Quad","Out",Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='The Big Black') or (Mode=='Solitude') or (Mode=='CHAOS') then
			local Alpha = .1
			if(NeutralAnims)then
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/32),0.2)*CF.A(M.R(15.5),M.R(20.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.9,0.4,-0.7)*CF.A(M.R(121.8),M.R(14.6),M.R(84.8))*CF.A(M.R(0+3*M.S(Sine/32)),0,0),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.3,0.3,-0.1)*CF.A(M.R(40+5*M.C(Sine/44)),M.R(-11.6),M.R(65.5+2.5*M.C(Sine/36))),Alpha)
				if(M.RNG(1,45)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.2)*CF.A(M.R(-15.6),M.R(-20.1),M.R(-5.5))*CF.A(M.R(0+1.5*M.S(Sine/32)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.6,-1-.05*M.C(Sine/32),0.1)*CF.A(M.R(-27.6),M.R(0),M.R(13.8)),Alpha)
					RH.C0 = RH.C0:lerp(CF.N(0.6,-1.1-.05*M.C(Sine/32),-0.1)*CF.A(M.R(-16.5),M.R(-20),M.R(-5.8)),Alpha)
				end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
		elseif(Mode=='Legendary') or (Mode=='CALAMITY') or (Mode=='Radioactive') then
			local Alpha = .1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(CF.N(0,4.8+.2*M.C(Sine/24),0)*CF.A(M.R(30+5*M.S(Sine/24)),M.R(16.7),M.R(-9.4)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,1,0.2)*CF.A(M.R(173.3+1*M.S(Sine/28)),M.R(19.9+2*M.S(Sine/28)),M.R(38.7)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(0.7,0.3,-0.6)*CF.A(M.R(46.8+1*M.S(Sine/28)),M.R(6.4+2*M.S(Sine/28)),M.R(-79.6)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.5)*CF.A(M.R(-40-5*M.S(Sine/24)),M.R(-18.7),M.R(-3.7)),Alpha)
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(1.9+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
					RH.C0 = RH.C0:lerp(CF.N(0.4,-1,-0.8)*CF.A(M.R(-63.8+7.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
			elseif(Mode=='Lust')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(CF.N(0,0.7+.1*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(-90-2.5*M.S(Sine/36))),Alpha)
					LS.C0 = LS.C0:lerp(CF.N(-1.2,0.1,0.1)*CF.A(M.R(23),M.R(16.5),M.R(20.6)),Alpha)
					RS.C0 = RS.C0:lerp(CF.N(0.8,1,-0.4)*CF.A(M.R(-162),M.R(-11.2),M.R(-22.6)),Alpha)
					NK.C0 = NK.C0:lerp(CF.N(-0.2,1.4,0)*CF.A(M.R(0),M.R(0),M.R(48.9)),Alpha)
					if(legAnims)then
						LH.C0 = LH.C0:lerp(CF.N(-0.9,-1.1,-0.2)*CF.A(M.R(-19.3),M.R(6.5),M.R(54.3-7.5*M.S(Sine/36))),Alpha)
						RH.C0 = RH.C0:lerp(CF.N(0.4,-0.9,0)*CF.A(M.R(0),M.R(0),M.R(25.9-7.5*M.S(Sine/36))),Alpha)
					end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
			elseif(Mode=='Justice')then
				local Alpha = .1
				if(NeutralAnims)then
			RJ.C0 = RJ.C0:lerp(CF.N(0,4.8+.2*M.C(Sine/16),0)*CF.A(M.R(0),M.R(28.9),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-0.8,0.3+.1*M.S(Sine/16),-0.7)*CF.A(M.R(125.4+2.5*M.S(Sine/16)),M.R(7.9),M.R(81.3)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(0.9,0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(79.5+2.5*M.S(Sine/16)),M.R(2.9),M.R(-85.6)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-28.9),M.R(0)),Alpha)
				if(legAnims)then
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1+.1*M.S(Sine/16),-0.1)*CF.A(M.R(-4.4),M.R(11.9),M.R(-9.2)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.7,-0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(-28.3),M.R(-41.7),M.R(-9.7)),Alpha)
				end
			end
		end
	elseif(State == 'Walk')then
		if(Mode=='Radioactive') or (Mode=='CALAMITY')or (Mode=='Legendary') then
			local Alpha = .2
  			if(NeutralAnims)then
			RJ.C0 = RJ.C0:lerp(CF.N(0,4.8+.2*M.C(Sine/24),0)*CF.A(M.R(-35),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-0.8,0.3+.1*M.S(Sine/16),-0.7)*CF.A(M.R(125.4),M.R(7.9),M.R(81.3)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(0.9,0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(79.5),M.R(2.9),M.R(-85.6)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(35),M.R(0),M.R(0)),Alpha)
			end
			if(legAnims)then
			LH.C0 = LH.C0:lerp(CF.N(-.5,-1+.1*M.S(Sine/16),-0.1)*CF.A(M.R(-25.3),M.R(0),M.R(-4.7)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(.5,-0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(-25.3),M.R(0),M.R(4.7)),Alpha)
			end
		end
			if(Mode=='Love') then
		local wsVal = 4
		local Alpha = .2
if(Walking)then Change=.5 else Change=.7 end
if(NeutralAnims)then
			SetTween(RJ,{C0 = RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal)))},"Quad","Out",Alpha)
		    SetTween(LS,{C0 = CF.N(-1.1,0.4,-0.5)*CF.A(math.rad(-6.5),math.rad(13.6),math.rad(45.8))},"Quad","Out",Alpha)
		    SetTween(RS,{C0 = CF.N(1.2,0.3,-0.5)*CF.A(math.rad(-6.5),math.rad(-13.6),math.rad(-45.8))},"Quad","Out",Alpha)
					    SetTween(NK,{C0 = CF.N(0,1.5,-0.1)*CF.A(math.rad(-7),math.rad(0),math.rad(0))},"Quad","Out",Alpha)
					end
if(legAnims)then
			SetTween(LH,{C0 = LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2)))},"Quad","Out",Alpha)
			SetTween(RH,{C0 = RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2)))},"Quad","Out",Alpha)
				end
		end
			if(Mode=='Justice') then
		local wsVal = 4
		local Alpha = .2
if(Walking)then Change=.5 else Change=.7 end
if(NeutralAnims)then
			RJ.C0 = RJ.C0:lerp(CF.N(0,4.8+.2*M.C(Sine/16),0)*CF.A(M.R(-35),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-0.8,0.3+.1*M.S(Sine/16),-0.7)*CF.A(M.R(125.4),M.R(7.9),M.R(81.3)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(0.9,0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(79.5),M.R(2.9),M.R(-85.6)),Alpha)
						NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(35),M.R(0),M.R(0)),Alpha)
						end
if(legAnims)then
			LH.C0 = LH.C0:lerp(CF.N(-.5,-1+.1*M.S(Sine/16),-0.1)*CF.A(M.R(-25.3),M.R(0),M.R(-4.7)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(.5,-0.3+.1*M.S(Sine/16),-0.6)*CF.A(M.R(-25.3),M.R(0),M.R(4.7)),Alpha)
end
			else
			local wsVal = 4
			local Alpha = .2
			if(Mode=='Subzero')then Change=.3 elseif(Mode=='The Big Black' or Mode=='RAINBOW' or Mode=='Legendary') then Change=1 else Change=.5 end
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0)*CF.A(M.R(0+55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(0-55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				local footstepIds = {141491460,141491460}
				if(lhit and lhit.CanCollide and footstepSounds[lhit.Material])then
					if(lhit.Material==Enum.Material.Sand and lhit.Color.r*255>=160 and lhit.Color.g*255>=160 and lhit.Color.b*255>=160)then
						footstepIds[1] = footstepSounds[Enum.Material.Snow]
					else
						footstepIds[1] = footstepSounds[lhit.Material]
					end
				end
				
				if(rhit and rhit.CanCollide and footstepSounds[rhit.Material])then
					if(rhit.Material==Enum.Material.Sand and rhit.Color.r*255>=160 and rhit.Color.g*255>=160 and rhit.Color.b*255>=160)then
						footstepIds[2] = footstepSounds[Enum.Material.Snow]
					else
						footstepIds[2] = footstepSounds[rhit.Material]
					end
				end
		
				
				if(M.C(Sine/wsVal)/2>=.2 and footsound==0 and lhit)then
					local step = Part(Effects,lhit.Color,lhit.Material,V3.N(1,.1,1),CF.N(lpos),true,false)
					step.Transparency=(footstepIds[1]==footstepSounds[Enum.Material.Snow] and 0 or 1)
					local snd = Soond(step,footstepIds[1],M.RNG(80,100)/100,3,false,true,true)
					footsound=1
					S.Debris:AddItem(step,snd.TimeLength+2)
				elseif(M.C(Sine/wsVal)/2<=-.2 and footsound==1 and rhit)then
					local step = Part(Effects,rhit.Color,rhit.Material,V3.N(1,.1,1),CF.N(rpos),true,false)
					step.Transparency=(footstepIds[2]==footstepSounds[Enum.Material.Snow] and 0 or 1)
					local snd = Soond(step,footstepIds[2],M.RNG(80,100)/100,3,false,true,true)
					footsound=0
					S.Debris:AddItem(step,snd.TimeLength+2)
				end
			end
		end
	elseif(State == 'Jump')then
		local Alpha = .1
		local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		end
	elseif(State == 'Fall')then
		local Alpha = .1
		local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		end
	elseif(State == 'Paralyzed')then
		local Alpha = .1
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0,Alpha)
			RS.C0 = RS.C0:lerp(RSC0,Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0,Alpha)
			RH.C0 = RH.C0:lerp(RHC0,Alpha)
		end
	elseif(State == 'Sit')then
		
	end
		
	if(data.User==data.Local)then
		local syncStuff={
			NeutralAnims;
			legAnims;
			{NK.C0,RJ.C0,RH.C0,RS.C0,LH.C0,LS.C0};
			{NK.C1,RJ.C1,RH.C1,RS.C1,LH.C1,LS.C1};
			Sine;
			movement;
			walking;	
			Change;
			--// OPTIONAL SYNC \\--
			MusicMode;
			(music and music.TimePosition or 0);
			(music and music.Pitch or 1);
			WingSine;
			getMode('Troubadour');
			Mode;
			hue;
		}
		AddRecieversync = syncStuff
		--[[req:Push("SetVariableAndBroadcast","sync",syncStuff)--]]
	end	
end
end)

Section:NewButton("Studio Dummy v1 free", "ButtonInfo", function()
    print("Clicked")
game.Players.LocalPlayer.Character["Necklace"].Handle.Mesh:Destroy()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local CDDF = {}


for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end


script = game:GetObjects("rbxassetid://7358490432")[1]
script = script:FindFirstChildOfClass("Script")
script = script.Client["vitamin gummies"]
local ts,run,workspace = game:GetService("TweenService"),game:GetService("RunService"),game:GetService("Workspace")
local cn,euler,rad,v3,sin,cos,random = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,Vector3.new,math.sin,math.cos,math.random
local size = 1
function cn2(x,y,z)
	return cn(v3(x,y,z)*size)
end
function randomstring()
	local e = {}
	for i = 1,math.random(5,50) do
		table.insert(e,#e+1,utf8.char(math.random(10,100)))
	end
	return table.concat(e)
end
function debris(instance,delay)
	game:GetService("Debris"):AddItem(instance,delay)
end
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end
function change(instance,properties)
	pcall(function()
		for property, value in pairs(properties) do
			instance[property] = value
		end
	end)
end
function create(class,properties)
	local instance = Instance.new(class)
	change(instance,properties)
	return instance
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function wait2(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end



function raycast(origin, direction, range, ignore)
	return workspace:FindPartOnRay(Ray.new(origin, direction*range), ignore)
end
local terrain = workspace:FindFirstChildWhichIsA("Terrain")
wait2(0.2)
local plr,localplayer,materials,shapes = game:GetService("Players").LocalPlayer,game:GetService("Players").LocalPlayer,Enum.Material:GetEnumItems(),Enum.PartType:GetEnumItems()
local mouse,cam,truehum = localplayer:GetMouse(),workspace.CurrentCamera,localplayer.Character:FindFirstChildOfClass("Humanoid") or localplayer.Character:WaitForChild("Humanoid")
local event = {}
local OnClientEvent = false
function event:FireServer(...)
	if OnClientEvent then OnClientEvent(...) end
end
local hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,falling,partexclusion,flying = cn2(0,1.5,0),cn2(-1.5,0,0),cn2(1.5,0,0),cn2(-0.5,-2,0),cn2(0.5,-2,0),0,1/4,false,false,{},false
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset = hc0,cn(),lac0,rac0,llc0,rlc0
local h,t,la,ra,ll,rl,r,poscframe,ypos,moving,keys = playerss.Head,playerss.Torso,playerss["Left Arm"],playerss["Right Arm"],playerss["Left Leg"],playerss["Right Leg"],playerss.HumanoidRootPart,cn(),50,false,{w=false,a=false,s=false,d=false}
--r.face:Destroy()
--h.Parent,t.Parent,la.Parent,ra.Parent,ll.Parent,rl.Parent,r.Transparency = cam,cam,cam,cam,cam,cam,0.5
--h.Name,t.Name,la.Name,ra.Name,ll.Name,rl.Name = randomstring(),randomstring(),randomstring(),randomstring(),randomstring(),randomstring()

function resetchr()
	if localplayer == plr then
		for i, v in pairs(workspace:GetDescendants()) do
			if v:IsA("SpawnLocation") then
				local newpos = v.CFrame*cn(0,v.Size.Y/2+50,0)
				ypos = newpos.Y
				poscframe = v.CFrame*cn(0,v.Size.Y/2+50,0)
				return
			end
		end
		ypos = 50
		poscframe = cn(0,ypos,0)
	end
end
local bgm = create("Sound",{Parent=cam})
local bgmstarttime = tick()
cam.ChildRemoved:Connect(function(instance)
	if instance == bgm then
		local bgmchanged,bgmended,fixing = nil,nil,false
		bgm = create("Sound",{Parent = cam})
		bgmchanged = bgm.Changed:Connect(function(thing)
			if thing == "Volume" then return end
			if bgm.Parent == nil then bgmchanged:Disconnect() bgmended:Disconnect() return end
			if fixing then return end
			fixing = true
			bgm.SoundId = "rbxassetid://4636390363"
			bgm.Looped = true
			bgm.Pitch = 1
			bgm.Playing = true
			bgm.RollOffMaxDistance = 10000
			bgm.RollOffMinDistance = 10
			bgm.RollOffMode = Enum.RollOffMode.Inverse
			bgm.SoundGroup = nil
			bgm.Name = randomstring()
			if bgm.TimePosition ~= math.clamp(bgm.TimePosition,tick()-bgmstarttime-0.2,tick()-bgmstarttime+0.2) then
				bgm.TimePosition = tick()-bgmstarttime
			end
			fixing = false
		end)
		bgmended = bgm.Ended:Connect(function()
			bgmstarttime = tick()
			bgm.Name = "hi"
		end)
		bgm.Name = "hi"
	end
end)
bgm:Destroy()
local rotationvalue = Instance.new("CFrameValue",script)
rotationvalue.Name = randomstring()
local uis = game:GetService("UserInputService")

local function AlignHat(p1,p2,nomesh)
	pcall(function()
		p1:FindFirstChildOfClass("Weld"):Destroy()
		if nomesh then 
			p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end)
	--p1.AccessoryWeld:Destroy()
	A1 = Instance.new("Attachment", p1) 
	A2 = Instance.new("Attachment", p2)
	Mover = Instance.new("AlignPosition", p1)
	Mover.RigidityEnabled = false
	Mover.Attachment0 = A1
	Mover.Attachment1 = A2
	Mover.Responsiveness = 200
	Mover.MaxVelocity = math.huge
	Mover.MaxForce = math.huge
	Rotater = Instance.new("AlignOrientation", p1)
	Rotater.RigidityEnabled = false
	Rotater.Attachment0 = A1
	Rotater.Attachment1 = A2
	Rotater.Responsiveness = 200
	Rotater.MaxAngularVelocity = math.huge
	Rotater.MaxTorque = math.huge
end

local variablerandom = false
run:BindToRenderStep(plr.Name.."'s idk thing loeleolllllaaaaaaaaaa",600,function()
	sine = sine + 1
	if localplayer == plr then
		if not flying then
			local hit, hitpos = raycast(t.Position,cn(t.Position,t.Position-v3(0,1,0)).LookVector,9e18,cam)
			if hit then
				ypos = cn(0,ypos,0):Lerp(cn(0,hitpos.Y+7,0),0.05).Y
			else
				ypos = ypos - 3
				if ypos < workspace.FallenPartsDestroyHeight then
					resetchr()
				end
			end
		end
		local movedirection,pos,lv = v3(),poscframe.p,cam.CFrame.LookVector
		if keys.w then movedirection = movedirection + v3(0,0,-1) end
		if keys.a then movedirection = movedirection + v3(-1,0,0) end
		if keys.s then movedirection = movedirection + v3(0,0,1) end
		if keys.d then movedirection = movedirection + v3(1,0,0) end

		moving = movedirection ~= v3()
		local xrot,yrot,zrot = cn(poscframe.p,Vector3.new(poscframe.X+lv.X,poscframe.Y,poscframe.Z+lv.Z)):ToOrientation()
		if flying then
			
			poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
			poscframe = poscframe * cn(movedirection/2)
			ypos = poscframe.p.Y
		else
			--poscframe = cn(v3(e.X,ypos,e.Z)+truehum.MoveDirection/3) * euler(0,rad(rotation),0)
			local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,rad(math.deg(yrot)),0) * cn(movedirection/3)).p
			if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
				rotationvalue.Value = euler(0,rad(math.deg(yrot)),0)
			else
				if movedirection ~= v3() then
					local z = ts:Create(rotationvalue,TweenInfo.new(0.1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value=cn(v3(pos.X,ypos,pos.Z),moveto)})
					z:Play()
					delay(1/60,function()
						z:Cancel()
					end)
				end
			end
			local xrot2,yrot2,zrot2 = rotationvalue.Value:ToOrientation()
			poscframe = cn(moveto) * euler(0,rad(math.deg(yrot2)),0)
		end
		r.CFrame = poscframe
		event:FireServer("replicate",{poscframe,moving})
		
	end
	if not attack then
		if moving then
			laoffset = laoffset:Lerp(lac0*cn2(1.00899887,0.371999979,-0.424003601)*euler(rad(75),rad(-60),0),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(0.241001129,0.16899991,0.255996704)*euler(0,rad(-15),rad(75)),animspeed)
			lloffset = lloffset:Lerp(llc0,animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0,0.541000009,-0.31199646)*euler(rad(-30),0,0),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(50),0,0)*cn2(0,0.5,0),animspeed)
		else
			laoffset = laoffset:Lerp(lac0*cn2(-0.5,0.5,cos(sine/16)/5)*euler(0,rad(cos(sine/16)*15),rad(-90)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(0.171001434,0.220999956-cos(sine/16)/3,-0.624000549)*euler(rad(75-cos(sine/16)*15),0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(0,0,cos(sine/16)/2.5)*euler(rad(-cos(sine/16)*25),0,0),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0,0.541000009,-0.31199646+cos(sine/16)/2.5)*euler(rad(-30-cos(sine/16)*25),0,0),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(30-cos(sine/16)*15),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(cos(sine/18)*15),0,rad(sin(sine/36)*12.5))*cn2(0,0.5,0),animspeed)
		end
	end
	t.CFrame = r.CFrame * toffset
	h.CFrame,la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame = t.CFrame*hoffset,t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset
	

	
	
	--Railn.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)
 

	bgm.Volume = math.clamp(50/(t.Position-cam.CFrame.p).Magnitude/10,0,1)
end)

local orb1 = create("Part",{
	Parent = cam,
	Anchored = true,
	CanCollide = false,
	Material = materials[random(1,#materials)],
	BrickColor = BrickColor.Random(),
	Size = v3(0.5,0.5,0.5),
	CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
})
local dur = random(10,75)/300
local size1 = random(10,40)/25




local orb2 = create("Part",{
	Parent = cam,
	Anchored = true,
	CanCollide = false,
	Material = materials[random(1,#materials)],
	BrickColor = BrickColor.Random(),
	Shape = shapes[random(1,#shapes)],
	Transparency = 0.5,
	Size = v3(0.5,0.5,0.5),
	CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
})
table.insert(partexclusion,orb1)
table.insert(partexclusion,orb2)

run:BindToRenderStep(plr.Name.."'xddd",600,function()
	wait2()

	tween(orb1,{Size=v3(size1,size1,size1),Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360))},dur,Enum.EasingDirection.Out)
	orb1.CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
	--print("A")
	tween(orb2,{Size=v3(size1*2.5,size1*2.5,size1*2.5),Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360))},dur/2,Enum.EasingDirection.Out)
	orb2.CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
end)

pcall(function()
local Fire = workspace.non["Necklace"].Handle
AlignHat(Fire,orb1,false)
end)

local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	CDDF[DmgPer] = true; StateMover = false
	orb1.Attachment.Parent = bullet
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Attachment.Parent = orb1
	CDDF[DmgPer] = false; StateMover = true
end

local Mouse = plr:GetMouse()
Mouse.KeyDown:Connect(function(key)
	if attack and key == "z" then
		DamageFling(Mouse.Hit.p)
	end

end)

local cancollide = true
local atkfunction = {}
atkfunction.__index = atkfunction
function atkfunction:decal(decal,dur)
	tween(decal,{Color3=BrickColor.Random().Color,Transparency=1},dur,Enum.EasingDirection.Out)
end
function atkfunction:selectionbox(box,dur)
	tween(box,{Color3=BrickColor.Random().Color,SurfaceColor3=BrickColor.Random().Color,Transparency=1,SurfaceTransparency=1},dur,Enum.EasingDirection.Out)
end
function atkfunction:part(part)
	if table.find(partexclusion,part) then return end
	if part.Size.X > 20 or part.Size.Y > 30 or part.Size.Z > 30 then return end
	table.insert(partexclusion,part)
	if not part.Anchored then part:BreakJoints() end
	part.Anchored = true
	part.CanCollide = false
	part.Material = materials[random(1,#materials)]
	local dur = random(30,70)/100
	tween(part,{CFrame=part.CFrame*cn(random(-5,5),random(-5,5),random(-5,5))*euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360))),Transparency=1,Color=BrickColor.Random().Color,Size=v3()},dur,Enum.EasingDirection.Out)
	for i, v in pairs(part:GetChildren()) do
		if v:IsA("Decal") or v:IsA("Texture") then
			atkfunction:decal(v,dur)
		elseif v:IsA("SelectionBox") or v:IsA("SelectionSphere") then
			atkfunction:selectionbox(v,dur)
		end
	end
end
function atkfunction:hitbox(pos,range)
	
end
function atkfunction:nhitbox(pos,range)
	local hitbox = create("Part",{
		Parent = cam,
		Anchored = true,
		CanCollide = false,
		Material = Enum.Material.ForceField,
		BrickColor = BrickColor.Random(),
		Size = v3(range*2,range*2,range*2),
		Shape = Enum.PartType.Ball,
		Position = pos
	})
	table.insert(partexclusion,hitbox)
	tween(hitbox,{Transparency=1},0.5,Enum.EasingDirection.In)
	local yeah = run.RenderStepped:Connect(function()
		hitbox.BrickColor = BrickColor.Random()
	end)
	debris(hitbox,0.5)
	delay(0.5,function()
		yeah:Disconnect()
	end)
	for i, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") then
			if (v.Position-pos).Magnitude <= range then
				atkfunction:part(v)
			end
		end
	end
end
function atk1(mousepos)
	for i = 1,3,0.3 do
		laoffset = laoffset:Lerp(lac0*cn2(-0.137001038,0.184999943,-0.522003174)*euler(rad(45),0,rad(-30)),animspeed*0.75)
		raoffset = raoffset:Lerp(rac0*cn2(0.102996826,-0.0399999619,0.32900238)*euler(rad(-30.7),rad(8.66),rad(3.12)),animspeed*0.75)
		lloffset = lloffset:Lerp(llc0*cn2(0,0.64199996,-0.580001831-sin(sine/8)/5)*euler(rad(-12+sin(sine/8)*16),0,0),animspeed*0.75)
		rloffset = rloffset:Lerp(rlc0*cn2(0,0,-sin(sine/8)/5)*euler(rad(sin(sine/8)*16),0,0),animspeed*0.75)
		hoffset = hoffset:Lerp(hc0*cn2(0,-0.0149998665,-0.124000549)*euler(rad(-14),rad(30),0),animspeed*0.75)
		toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-cos(sine/16)*15),rad(-30),0),animspeed)
		wait2()
	end
	delay(0.1,function()
		local orb = create("Part",{
			Parent = cam,
			Anchored = true,
			CanCollide = false,
			Material = materials[random(1,#materials)],
			BrickColor = BrickColor.Random(),
			CFrame = rl.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		
		table.insert(partexclusion,orb)
		local dur = (rl.Position-mousepos).Magnitude/500
		tween(orb,{CFrame=cn(mousepos)*euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))},dur,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
		debris(orb,dur)
		delay(dur,function()
			atkfunction:hitbox(mousepos,5)
		end)
	end)
	for i = 1, 3, 0.6 do
		laoffset = laoffset:Lerp(lac0*cn2(-0.250999451,0.224999905,0.601997375)*euler(rad(-30.99),rad(35.33),rad(-46.86)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(-0.016998291,0.792000055,-0.972999573)*euler(rad(22.12),rad(147.65),rad(157.94)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(0,0.64199996,-0.580001831-sin(sine/8)/5)*euler(rad(-12+sin(sine/8)*16),0,0),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0,0,-sin(sine/8)/5)*euler(rad(sin(sine/8)*16),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(0,-0.0149998665,-0.124000549)*euler(rad(-14),rad(-30),0),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-cos(sine/16)*15),rad(30),0),animspeed)
		wait2()
	end
	attack = false
end
if localplayer == plr then
	cancollide = false
	local function setupchr(chr)
		truehum = chr:WaitForChild("Humanoid")
		cam.CameraSubject = h
	end
	setupchr(localplayer.Character)
	
	mouse.KeyDown:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = true
		elseif key == "r" then
			resetchr()
		elseif key == "f" then
			flying = not flying
		elseif key == "z" then
			if attack then return end
			attack = true
			atk1(mouse.Hit.p)
			event:FireServer("keydown",{"z",mouse.Hit.p})
		end
	end)
	mouse.KeyUp:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = false
		end
	end)
end
OnClientEvent = function(what,mode,data)
	if localplayer ~= plr then
		if mode == "replicate" then
			poscframe = data[1]
			tween(r,{CFrame=poscframe},0.1,Enum.EasingDirection.Out)
			moving = data[2]
		elseif mode == "keydown" then
			if data[1] == "z" then
				atk1(data[2])
			end
		end
	end
	
end
function checkmeshpartintegrity(part,_size)
	return (not part or part.Size ~= _size*size or part.Material ~= Enum.Material.SmoothPlastic or part.Reflectance ~= 0 or part.Transparency ~= 0 or part.Color ~= Color3.fromRGB(163,162,165) or not part.Anchored or part.CanCollide ~= cancollide or part.Archivable or part.Parent ~= cam or not part.Locked or part.CollisionGroupId ~= 0 or part.RenderFidelity ~= Enum.RenderFidelity.Precise or part.CollisionFidelity ~= Enum.CollisionFidelity.Default or part.TextureID ~= "" or part.DoubleSided or part.RootPriority ~= 0 or not part.CastShadow)
end

	if not h or h.Size ~= v3(2,1,1)*size or h.Material ~= Enum.Material.Plastic or h.Reflectance ~= 0 or h.Transparency ~= 0 or h.Color ~= Color3.fromRGB(163,162,165) or not h.Anchored or h.CanCollide ~= cancollide or h.Archivable or h.Parent ~= cam or not h.Locked or h.CollisionGroupId ~= 0 or h.Shape ~= Enum.PartType.Block or not h.CastShadow then
		
	h = playerss.Head
		
		if localplayer == plr then
			cam.CameraSubject = h
		end
	end
	if not table.find(partexclusion,h) then
		table.insert(partexclusion,h)
	end
	if not r or r.Size ~= v3(2,2,1)*size or r.Material ~= Enum.Material.Plastic or r.Reflectance ~= 0 or r.Transparency ~= 0.5 or h.Color ~= Color3.fromRGB(163,162,165) or not h.Anchored or h.CanCollide ~= cancollide or h.Archivable or h.Parent ~= cam or not h.Locked or h.CollisionGroupId ~= 0 or h.Shape ~= Enum.PartType.Block or not h.CastShadow then
		
	r = playerss.HumanoidRootPart
	end
	if not table.find(partexclusion,r) then
		table.insert(partexclusion,r)
	end
	if checkmeshpartintegrity(t,v3(2,2,1)) then
		
	t = playerss.Torso
	end
	if not table.find(partexclusion,t) then
		table.insert(partexclusion,t)
	end
	if checkmeshpartintegrity(la,v3(1,2,1)) then
		
	la = playerss["Left Arm"]
	end
	if not table.find(partexclusion,la) then
		table.insert(partexclusion,la)
	end
	if checkmeshpartintegrity(ra,v3(1,2,1)) then
		
	ra = playerss["Right Arm"]
	end
	if not table.find(partexclusion,ra) then
		table.insert(partexclusion,ra)
	end
	if checkmeshpartintegrity(ll,v3(1,2,1)) then
		
	ll = playerss["Left Leg"]
	end
	if not table.find(partexclusion,ll) then
		table.insert(partexclusion,ll)
	end
	if checkmeshpartintegrity(rl,v3(1,2,1)) then
		
	rl = playerss["Right Leg"]
	end
	if not table.find(partexclusion,rl) then
		table.insert(partexclusion,rl)
	end

resetchr()
end)

Section:NewButton("Parkour", "ButtonInfo", function()
    print("Clicked")
_G.Noclip = false
script = game:GetObjects("rbxassetid://8076509064")[1].Parkour
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()

local Player = game:GetService("Players").LocalPlayer
local Mouse,mouse,UserInputService
local localEffectsEvent
do

	local Event = {}
	local ins = Instance.new
	local v3 = Vector3.new
	local cf = CFrame.new

	local char = Player.Character
	local hum = char:FindFirstChildOfClass("Humanoid")
	local rut = char.HumanoidRootPart
	local h = char.Head

	function Event:FireClient(typen)
		if typen == "shak" then
			local part = ins("Part",char)
			part.Size = v3(0,0,0)
			part.CanCollide = false
			part.Anchored = true
			part.CFrame = workspace.CurrentCamera.CFrame * cf(0,.5,0)
			game:GetService("Debris"):AddItem(part,.35)

			local bool = ins("BoolValue",part)
			bool.Name = "Shaking"
			bool.Value = true

			local MaxDist = ins("NumberValue",bool)
			MaxDist.Name = "MaxDist"
			MaxDist.Value = 1000

			local Intensivity = ins("NumberValue",bool)
			Intensivity.Name = "Intensivity"
			Intensivity.Value = .65
		end
	end

	game:GetService("RunService").Heartbeat:Connect(function()
		if hum:FindFirstChild("Stunned") then
			workspace.CurrentCamera.CFrame = h.CFrame

		end
		for i,v in pairs(char:GetChildren()) do
			if v:IsA("BasePart") then
				v.LocalTransparencyModifier = 0
			end
		end
		if (workspace.CurrentCamera.CFrame.Position - h.Position).Magnitude <1.5 then
			h.LocalTransparencyModifier = 1
			for i,v in pairs(char:GetChildren()) do
				if v:IsA("Accessory") then
					v.Handle.LocalTransparencyModifier = 1
				end
			end
		else
			h.LocalTransparencyModifier = 0
			for i,v in pairs(char:GetChildren()) do
				if v:IsA("Accessory") then
					v.Handle.LocalTransparencyModifier = 0
				end
			end
		end
		hum.CameraOffset = hum.CameraOffset:Lerp((rut.CFrame*cf(0,1.5,0)):PointToObjectSpace(h.Position),.1)
	end)
	
	localEffectsEvent = Event
	
	
	local m = Player:GetMouse()
	local UIS = game:GetService("UserInputService")
	

	Mouse,mouse,UserInputService = m,m,UIS
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end


--this was made for vlad
script.Client.Disabled = false
--BasicFunctions
local ins = Instance.new
local v3 = Vector3.new
local cf = CFrame.new
local angles = CFrame.Angles
local rad = math.rad
local huge = math.huge
local cos = math.cos
local sin = math.sin
local tan = math.tan
local abs = math.abs
local ray = Ray.new
local random = math.random
local ud = UDim.new
local ud2 = UDim2.new
local c3 = Color3.new
local rgb = Color3.fromRGB
local bc = BrickColor.new

--Services
local plrs = game:GetService("Players")
local tweens = game:GetService("TweenService")
local debrs = game:GetService("Debris")
local runservice = game:GetService("RunService")
 
--Variables
local plr = Player
local plrg = plr.PlayerGui
local char = plr.Character
local h = char.Head
local t = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local rut = char.HumanoidRootPart
local hum = char:FindFirstChildOfClass("Humanoid")
local nec = t.Neck
local rutj = rut.RootJoint
local rs = t["Right Shoulder"]
local ls = t["Left Shoulder"]
local rh = t["Right Hip"]
local lh = t["Left Hip"]

necc0,necc1=cf(0,t.Size.Y/2,0),cf(0,-h.Size.Y/2,0)
rutjc0,rutjc1=cf(0,0,0),cf(0,0,0)
rsc0,rsc1=cf(t.Size.X/2,t.Size.Y/4,0),cf(-ra.Size.X/2,ra.Size.Y/4,0)
lsc0,lsc1=cf(-t.Size.X/2,t.Size.Y/4,0),cf(la.Size.X/2,la.Size.Y/4,0)
rhc0,rhc1=cf(t.Size.X/4,-t.Size.Y/2,0),cf(0,rl.Size.Y/2,0)
lhc0,lhc1=cf(-t.Size.X/4,-t.Size.Y/2,0),cf(0,ll.Size.Y/2,0)

local using = false
local canGrabLedge = false
local holding = false
local movingRight = false
local movingLeft = false
local moving = false
local canGrab = true
local dancin = false
local canWallClimb = false
local wallClimbDeb = false
local moveDir = 0
local ledgePos

local fallTime = 0
local stunned = false

local canDash = true

local lightEnabled = false

local anim = "idle"
local asset = "rbxassetid://"

local change = 1
local sine = 0
local dSine = -5000

local ws = 8
local jp = 35

local oldWS = ws
local oldJP = jp

--
local ignoreList = {char}

local stepsounds = {
Grass = asset.."1201103066",
Sand = asset.."1436385526",
Plastic = asset.."1569994049",
Stone = asset.."507863857", --379398649
Wood = asset.."1201103959",
Pebble = asset.."1201103211",
Ice = asset.."265653271",
Glass = asset.."145180170",
Metal = asset.."379482691"
}

local directions = {In = Enum.EasingDirection.In,
    Out = Enum.EasingDirection.Out,
    InOut = Enum.EasingDirection.InOut
}

local styles = {Linear = Enum.EasingStyle.Linear,
    Back = Enum.EasingStyle.Back,
    Bounce = Enum.EasingStyle.Bounce,
    Sine = Enum.EasingStyle.Sine,
    Quad = Enum.EasingStyle.Quad,
    Elastic = Enum.EasingStyle.Elastic,
    Quart = Enum.EasingStyle.Quart,
    Quint = Enum.EasingStyle.Quint
}

local ignoreList = {char}

local stepped = runservice.Heartbeat

--Removing joints/Animations
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end

if hum:FindFirstChildOfClass("Animator") then
	char.Humanoid.Animator:Destroy()
end

nec.Parent = nil
rutj.Parent = nil
rs.Parent = nil
ls.Parent = nil
rh.Parent = nil
lh.Parent = nil

--Joints
local nec = ins("Motor6D",t) nec.Name = "Neck" nec.Part0 = t nec.Part1 = h
local rutj = ins("Motor6D",rut) rutj.Name = "RootJoint" rutj.Part0 = t rutj.Part1 = rut
local rs = ins("Motor6D",t) rs.Name = "Right Shoulder" rs.Part0 = t rs.Part1 = ra
local ls = ins("Motor6D",t) ls.Name = "Left Shoulder" ls.Part0 = t ls.Part1 = la
local rh = ins("Motor6D",t) rh.Name = "Right Hip" rh.Part0 = t rh.Part1 = rl
local lh = ins("Motor6D",t) lh.Name = "Left Hip" lh.Part0 = t lh.Part1 = ll

--Setting CFrames
nec.C1 = necc1
nec.C0 = necc0
rs.C1 = rsc1
rs.C0 = rsc0
ls.C1 = lsc1
ls.C0 = lsc0
rh.C1 = rhc1
rh.C0 = rhc0
lh.C1 = lhc1
lh.C0 = lhc0
rutj.C1 = rutjc1
rutj.C0 = rutjc0

--Functions1
function createWeld(p1,p2,c0,c1)
	c0 = c0 or cf(0,0,0)
	c1 = c1 or cf(0,0,0)
	local weld = ins("Motor6D",p1)
	weld.Part0 = p1
	weld.Part1 = p2
	weld.C0 = c0
	weld.C1 = c1
	return weld
end

--Adds
local ff = ins("ForceField",char)
ff.Visible = false

local effects = ins("Model",char)
effects.Name = "Effects"

local shaker = script.DistShaker:Clone()

local lamp = script.Models.Lamp
lamp.Parent = char
local lWeld = createWeld(t,lamp.Handle,cf(-.975,-.75,-.25) * angles(rad(85),rad(85),rad(5)))

local ui = script.UIs.ParkourUI
ui.Parent = plrg

h.Size = v3(1,1,1)

--Functions2

function remove(instance,time)
	time = time or 0
	game:GetService("Debris"):AddItem(instance,time)
end

function swait()
	game:GetService("RunService").Stepped:Wait()
end

function rayc(spos,direc,ignore,dist)
    local rai = ray(spos,direc.Unit * dist)
    local rhit,rpos,rrot = workspace:FindPartOnRayWithIgnoreList(rai,ignore,false,false)
    return rhit,rpos,rrot
end

function sound(id,vol,pitch,parent,maxdist)
	local mdist = 30 or maxdist
	local newsound = Instance.new("Sound",parent)
	newsound.Volume = vol
	newsound.SoundId = "rbxassetid://"..id
	newsound.Pitch = pitch
	newsound:Play()
	coroutine.resume(coroutine.create(function()
		wait(.1)
		remove(newsound,newsound.TimeLength/newsound.Pitch)
	end))
	return newsound
end

function placesoundpart(rcf,id,vol,pitch,maxdist)
	pcall(function()
		local mdist = 30 or maxdist
		local spart = ins("Part",effects)
		spart.Anchored = true
		spart.CanCollide = false
		spart.Locked = true
		spart.Transparency = 1
		spart.CFrame = rcf
		local ssound = sound(id,vol,pitch,spart,mdist)
		remove(spart,ssound.TimeLength/ssound.Pitch)
	end)
end

local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
    local info = TweenInfo.new(
    leinght,
    easingstyle,
    easingdirec,
    0,
    false,
    0
    )
    local lerp = tweens:Create(part,info,tablee)
    lerp:Play()
end

local Effects = {
	Ring = function(pos,color,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
	end,
	SpinningRing = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * rotation
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	Sphere = function(pos,color,sSize,eSize,sTrans,eTrans,time)
		local sphere = ins("Part")
		sphere.Shape = "Ball"
		sphere.Size = v3(sSize,sSize,sSize)
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		remove(sphere,time)
		tlerp(sphere,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles.Linear,directions.Out)
	end,
	SpinningBlock = function(pos,color,sSize,eSize,sTrans,eTrans,cfRotation,time)
		local part = ins("Part")
		part.Size = v3(sSize,sSize,sSize)
		part.Transparency = sTrans
		part.CFrame = pos
		part.Color = color
		part.Parent = effects
		part.Anchored = true
		part.CanCollide = false
		part.Locked = true
		part.Material = "Neon"
		remove(part,time)
		tlerp(part,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				part.CFrame = part.CFrame * cfRotation
				wait(1/30)
			until not part.Parent
		end)()
	end,
	CustomSphere = function(pos,endPos,color,sSize,eSize,sTrans,eTrans,time)
		local sphere = ins("Part")
		sphere.Size = sSize
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		
		local mesh = ins("SpecialMesh",sphere)
		mesh.MeshType = "Sphere"
		
		remove(sphere,time)
		tlerp(sphere,{Size = eSize,Transparency = eTrans,CFrame = endPos},time,styles.Linear,directions.Out)
	end,
	Wind = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time)
		local ring = script.Wind:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles.Linear,directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * angles(rad(0),rad(rotation),rad(0))
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	CreateCamShake = function(part,maxDist,intensivity,time)
		maxDist = maxDist or 20
		intensivity = intensivity or 1
		time = time or .1
		
		local bool = ins("BoolValue",part)
		bool.Name = "Shaking"
		bool.Value = true
		
		local MaxDist = ins("NumberValue",bool)
		MaxDist.Name = "MaxDist"
		MaxDist.Value = maxDist
		
		local Intensivity = ins("NumberValue",bool)
		Intensivity.Name = "Intensivity"
		Intensivity.Value = intensivity
		
		remove(bool,time)
	end,
	SoundEffect = function(sound,effect)
		ins(effect.."SoundEffect",sound)
	end,
	Particles = function(part,type,dis)
		local parts
		if type:lower() == "blood" then
			parts = script.Effects.BloodParticles:Clone()
			parts.Parent = part
			if dis then
				parts.Enabled = false
			else
				parts.Enabled = true
			end
		elseif type:lower() == "bloodsplash" then
			parts = script.Effects.BloodSplash:Clone()
			parts.Parent = part
			if dis then
				parts.Enabled = false
			else
				parts.Enabled = true
			end
		end
		return parts
	end
}

function blood(pos,direc,forcev,scale,ignore)
	ignore = ignore or ins("Model")
	scale = scale or 1
	forcev = forcev or 25
	if not pos then
		return warn("No position set")
	end
	local p = ins("Part")
	p.Size = v3(.35,.35,.35) * scale
	p.CanCollide = true
	p.Transparency = 1
	p.Material = "Neon"
	p.Shape = "Ball"
	p.CFrame = pos
	p.Parent = effects
	p:BreakJoints()
	
	table.insert(ignoreList,p)
	
	local bps = Effects.Particles(p,"blood",false)
	bps.Size = NumberSequence.new(.2 * scale)
	bps:Emit(7)
	
	local force = ins("BodyVelocity",p)
	force.MaxForce = v3(huge,huge,huge)
	force.Velocity = (direc + v3(random(-10,10)/75,random(-10,10)/75,random(-10,10)/75)) * forcev
	
	remove(force,.15)
	
	local raySides = {
		v3(0,100,0),
		v3(0,-100,0),
		v3(0,0,100),
		v3(0,0,-100),
		v3(100,0,0),
		v3(-100,0,0),
		v3(100,100,0),
		v3(-100,100,0),
		v3(100,-100,0),
		v3(-100,-100,0),
		v3(0,100,100),
		v3(0,100,-100),
		v3(0,-100,100),
		v3(0,-100,-100),
		v3(100,100,100),
		v3(100,-100,100),
		v3(100,100,-100),
		v3(100,-100,-100),
		v3(-100,100,100),
		v3(-100,-100,100),
		v3(-100,100,-100),
		v3(-100,-100,-100),
		v3(100,100,-100),
		v3(-100,-100,100),
		v3(-100,100,-100),
		v3(100,-100,100)
	}
	local deb = false
	p.Touched:Connect(function(hit)
		if hit:IsDescendantOf(char) or hit:IsDescendantOf(ignore) or deb then return end
		deb = true
		bps.Enabled = false
		p.CanCollide = false
		p.Anchored = true
		local pPos = p.Position
		remove(p,2.5)
		
		local decSize = 3 * scale
		local reg = Region3.new(pPos - v3(decSize/2,decSize/2,decSize/2),pPos + v3(decSize/2,decSize/2,decSize/2))
		local foundParts = workspace:FindPartsInRegion3WithWhiteList(reg,ignoreList,100)
		
		local breakAfter = false
		
		for i,v in pairs(foundParts) do
			if v.Name == "BloodPuddle_v2" then
				local add = random(10,25)/100
				v.Size = v.Size + v3(add,0,add) * scale
				local pars = Effects.Particles(v,"blood",true)
				pars.LockedToPart = false
				pars.Size = NumberSequence.new(.2 * scale)
				pars.Speed = NumberRange.new(5)
				pars.Acceleration = v3(0,-10,0) * scale
				pars.SpreadAngle = Vector2.new(50,50) * scale
				pars.Lifetime = NumberRange.new(.2,.5)
				pars:Emit(3)
				breakAfter = true
			end
		end
		
		if breakAfter then
			return
		end
		
		for i,v in pairs(raySides) do
			local hitt,ppos,nId = rayc(pPos,(pPos + v) - pPos,ignoreList,5 * scale)
			if hitt then
				
				local decSize = 3 * scale
				local reg = Region3.new(pPos - v3(decSize/2,decSize/2,decSize/2),pPos + v3(decSize/2,decSize/2,decSize/2))
				local foundParts = workspace:FindPartsInRegion3WithWhiteList(reg,ignoreList,100)
				
				local breakAfter = false
				
				for i,v in pairs(foundParts) do
					if v.Name == "BloodPuddle_v2" then
						local add = random(10,25)/100
						v.Size = v.Size + v3(add,0,add) * scale
						local pars = Effects.Particles(v,"blood",true)
						pars.LockedToPart = false
						pars.Size = NumberSequence.new(.2 * scale)
						pars.Speed = NumberRange.new(5 * scale)
						pars.Acceleration = v3(0,-10,0) * scale
						pars.SpreadAngle = Vector2.new(50,50) * scale
						pars.Lifetime = NumberRange.new(.2,.5)
						pars:Emit(3)
						breakAfter = true
					end
				end
				
				if breakAfter then
					return
				end
				
				local size = random(75,125)/100
				local puddle = ins("Part")
				puddle.CanCollide = false
				puddle.Anchored = true
				puddle.Material = "SmoothPlastic"
				puddle.Color = bc("Maroon").Color
				puddle.Size = v3(size,.05,size) * scale
				puddle.CFrame = cf(ppos,ppos+nId) * angles(rad(-90),rad(0),rad(0))
				puddle.Name = "BloodPuddle_v2"
				puddle.Parent = effects
				
				if not hitt.Anchored then
					puddle.Anchored = false
					local we = ins("WeldConstraint",puddle)
					we.Part0 = hitt
					we.Part1 = puddle
				end
				
				ins("CylinderMesh",puddle)
				
				sound(685857471,.025 * scale,random(90,110)/100,puddle,.01)
				
				local pars = Effects.Particles(puddle,"blood",true)
				pars.LockedToPart = false
				pars.Size = NumberSequence.new(.2 * scale)
				pars.Speed = NumberRange.new(5 * scale)
				pars.Acceleration = v3(0,-10,0) * scale
				pars.SpreadAngle = Vector2.new(50,50) * scale
				pars.Lifetime = NumberRange.new(.2,.5)
				pars:Emit(20)
				
				coroutine.wrap(function()
					wait(random(450,900)/100)
					remove(puddle,2)
					tlerp(puddle,{Transparency = 1},2,styles.Quad,directions.In)
				end)()
				
				break
			end
		end
	end)
end

function createweld(part1,part2,v3c0,v3c1)
	local att1 = ins("Attachment",part1)
	local att2 = ins("Attachment",part2)
	att1.Position = v3c0
	att2.Position = v3c1
	local con = ins("BallSocketConstraint",part1)
	con.Attachment0 = att1
	con.Attachment1 = att2
	con.LimitsEnabled = true
	con.TwistLimitsEnabled = true
	con.TwistLowerAngle = 0
	con.TwistUpperAngle = 0
	con.UpperAngle = 0
	att1.Name = "dontremove"
	att2.Name = "dontremove"
	con.Name = "dontremove"
	return {att0 = att1,att1 = att2,constraint = con}
end

function createglue(parent1,parent2,name,part0,part1,c0,c1)
	local att1 = ins("Attachment")
	local att2 = ins("Attachment")
	local socket = ins("BallSocketConstraint")
	att1.Parent = parent1
	att2.Parent = parent2
	socket.Attachment0 = att1
	socket.Attachment1 = att2
	att1.Position = c0
	att2.Position = c1
	socket.Name = "dontremove"
	att1.Name = "dontremove"
	att2.Name = "dontremove"
	socket.Parent = parent2
	return att1,att2,socket
end

function createhitbox(part,parent)
	local hbpart = ins("Part")
	hbpart.Name = "HitboxRagdoll"
	hbpart.Locked = true
	hbpart.Transparency = 1
	hbpart.TopSurface = "Smooth"
	hbpart.BottomSurface = "Smooth"
	hbpart.Material = "Ice"
	if part.Name ~= "Head" then
		hbpart.Size = v3(part.Size.x/1.05,part.Size.y/1.2,part.Size.z/1.05)
		hbpart.CFrame = part.CFrame
		local att1 = ins("Attachment",part)
		local att2 = ins("Attachment",hbpart)
		att1.Position = v3(0,(-part.Size.y/2) + (hbpart.Size.y/2),0)
		local con = ins("BallSocketConstraint",part)
		con.Attachment0 = att1
		con.Attachment1 = att2
		con.LimitsEnabled = true
		con.TwistLimitsEnabled = true
		con.TwistLowerAngle = 0
		con.TwistUpperAngle = 0
		con.UpperAngle = 0
	else
		hbpart.Size = v3(part.Size.x,part.Size.y/2,part.Size.z)
		hbpart.CFrame = part.CFrame
		local att1 = ins("Attachment",part)
		local att2 = ins("Attachment",hbpart)
		local con = ins("BallSocketConstraint",part)
		con.Attachment0 = att1
		con.Attachment1 = att2
		con.LimitsEnabled = true
		con.TwistLimitsEnabled = true
		con.TwistLowerAngle = 0
		con.TwistUpperAngle = 0
		con.UpperAngle = 0
	end
	hbpart:BreakJoints()
	hbpart.Parent = parent
	return hbpart
end

function paralizer6(type,who,huma,rip)
pcall(function()
	if type == "body" then
		local torso = who:FindFirstChild("Torso")
		local righta = who:FindFirstChild("Right Arm")
		local lefta = who:FindFirstChild("Left Arm")
		local rightl = who:FindFirstChild("Right Leg")
		local leftl = who:FindFirstChild("Left Leg")
		local head = who:FindFirstChild("Head")
		local tag = ins("Glue",who) tag.Name = "deletmepls"
		if torso then
			local root = who:FindFirstChild("HumanoidRootPart")
			if root then
				root:Destroy()
			end
			huma.PlatformStand = true
			if head then
				if head:FindFirstChild("Ripped") then
					return
				end
				head:BreakJoints()
				head.Anchored = false
				createhitbox(head,torso)
				local att1,att2,sock = createglue(torso,head,"paralized",torso,leftl,v3(0,torso.Size.y/2,0),v3(0,-head.Size.y/2,0))
				att1.Orientation = v3(0, -90, 90)
				att2.Orientation = v3(0, -90, 90)
				sock.LimitsEnabled = true
				sock.TwistLimitsEnabled = true
				sock.UpperAngle = 80
				sock.TwistLowerAngle = -80
				sock.TwistUpperAngle = 80
				head.TopSurface = "Smooth"
				head.BottomSurface = "Smooth"
				head:MakeJoints()
			end
			if leftl then
				if not leftl:FindFirstChild("Ripped") then
					leftl:BreakJoints()
					leftl.Anchored = false
					local att1,att2,sock = createglue(torso,leftl,"paralized",torso,leftl,v3(-torso.Size.x/4,-torso.Size.y/2,0),v3(0,leftl.Size.y/2,0))
					att1.Orientation = v3(-0, -90, 90)
					att2.Orientation = v3(0, -90, 90)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 35
					sock.TwistUpperAngle = -45
					createhitbox(leftl,torso)
				end
			end
			if rightl then
				if not rightl:FindFirstChild("Ripped") then
					rightl:BreakJoints()
					rightl.Anchored = false
					local att1,att2,sock = createglue(torso,rightl,"paralized",torso,rightl,v3(torso.Size.x/4,-torso.Size.y/2,0),v3(0,rightl.Size.y/2,0))
					att1.Orientation = v3(-0, -90, 90)
					att2.Orientation = v3(0, -90, 90)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 45
					sock.TwistUpperAngle = -35
					createhitbox(rightl,torso)
				end
			end
			if righta then
				righta:BreakJoints()
				righta.Anchored = false
				if not righta:FindFirstChild("Ripped") then
					local att1,att2,sock = createglue(torso,righta,"paralized",torso,righta,v3((torso.Size.x/2) + (righta.Size.x/2),torso.Size.y/4,0),v3(0,righta.Size.y/4,0))
					att1.Orientation = v3(-90, 0, 0)
					att2.Orientation = v3(0, 180, -180)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 105
					sock.TwistUpperAngle = -110
				end
				createhitbox(righta,torso)
			end
			if lefta then
				lefta:BreakJoints()
				lefta.Anchored = false
				if not lefta:FindFirstChild("Ripped") then
					local att1,att2,sock = createglue(torso,lefta,"paralized",torso,lefta,v3((-torso.Size.x/2) - (lefta.Size.x/2),torso.Size.y/4,0),v3(0,lefta.Size.y/4,0))
					att1.Orientation = v3(-90, 180, 0)
					att2.Orientation = v3(0, -180, 0)
					sock.LimitsEnabled = true
					sock.TwistLimitsEnabled = true
					sock.UpperAngle = 100
					sock.TwistLowerAngle = 105
					sock.TwistUpperAngle = -90
				end
				createhitbox(lefta,torso)
			end
		else
			warn("Cant get the torso")
		end
	end
end)
end

function killr6(who)
pcall(function()
	local khum = who:FindFirstChildOfClass("Humanoid")
	if khum then
		khum.Health = 0
		khum.Name = "Dead hobo"
		who:BreakJoints()
		local khe = khum.Parent:FindFirstChild("Head")
		if khe.Size.x ~= khe.Size.z then
			khe.Size = v3(khe.Size.z,khe.Size.z,khe.Size.z)
		end
		for i,v in pairs(who:GetDescendants()) do
			if v:IsA("Accessory") or v:IsA("Hat") then
				local att1 = ins("Attachment",khe)
				local att2 = ins("Attachment",v.Handle)
				att1.Position = (v.Handle.Position-khe.Position)
				local con = ins("BallSocketConstraint",khe)
				con.Attachment0 = att1
				con.Attachment1 = att2
				con.LimitsEnabled = true
				con.TwistLimitsEnabled = true
				con.TwistLowerAngle = 0
				con.TwistUpperAngle = 0
				con.UpperAngle = 0
			end
			if v:IsA("Script") or v:IsA("LocalScript") or v.Name == "HitboxRagdoll" or v:IsA("Attachment") and v.Name ~= "dontremove" or v:IsA("BallSocketConstraint") and v.Name ~= "dontremove" then
				remove(v,0)
			end
			if v:IsA("Decal") then
			end
			if v:IsA("Part") or v:IsA("MeshPart") then
				v.Anchored = false
				v:BreakJoints()
			end
		end
		paralizer6("body",khum.Parent,khum)
	end
end)
end

function charDeath()
	killr6(char)
	for i,v in pairs(char:GetDescendants()) do
		if v:IsA("BillboardGui") or v:IsA("ForceField") then
			remove(v,0)
		end
	end
	if random(1,20) == 20 then
		sound(2847401060,1,1,t,1)
	end
	local fraem = ins("Frame",ui)
	fraem.Size = ud2(2,0,2,0)
	fraem.Position = ud2(0,0,-.5,0)
	fraem.BackgroundColor3 = c3(1,1,1)
	fraem.BackgroundTransparency = 0
	fraem.ZIndex = 1000
	remove(ui,6)
	wait(.1)
	tlerp(fraem,{BackgroundColor3 = c3(0,0,0)},.1,styles.Quart,directions.Out)
end

function stun(time,getUp,lockCamera)
	local help = {}
	
	hum.PlatformStand = true
	stunned = true
	
	local vel = ins("BodyVelocity",t)
	vel.MaxForce = v3(huge,huge,huge)
	vel.Velocity = v3(random(-25,25),random(35,70),random(-25,25))
	remove(vel,.01)
	
	local stunnd = ins("BoolValue")
	if lockCamera then
		stunnd.Parent = hum
		stunnd.Name = "Stunned"
	end
	
	--Right Leg
	local att1RL,att2RL,sockRL = createglue(t,rl,"paralized",t,rl,v3(t.Size.x/4,-t.Size.y/2,0),v3(0,rl.Size.y/2,0))
	att1RL.Orientation = v3(-0, -90, 90)
	att2RL.Orientation = v3(0, -90, 90)
	sockRL.LimitsEnabled = true
	sockRL.TwistLimitsEnabled = true
	sockRL.UpperAngle = 100
	sockRL.TwistLowerAngle = 45
	sockRL.TwistUpperAngle = -35
	local hbRL = createhitbox(rl,t)
	
	--Left Leg
	local att1LL,att2LL,sockLL = createglue(t,ll,"paralized",t,ll,v3(-t.Size.x/4,-t.Size.y/2,0),v3(0,ll.Size.y/2,0))
	att1LL.Orientation = v3(-0, -90, 90)
	att2LL.Orientation = v3(0, -90, 90)
	sockLL.LimitsEnabled = true
	sockLL.TwistLimitsEnabled = true
	sockLL.UpperAngle = 100
	sockLL.TwistLowerAngle = 35
	sockLL.TwistUpperAngle = -45
	local hbLL = createhitbox(ll,t)
	
	--Right Arm
	local att1RA,att2RA,sockRA = createglue(t,ra,"paralized",t,ra,v3((t.Size.x/2) + (ra.Size.x/2),t.Size.y/4,0),v3(0,ra.Size.y/4,0))
	att1RA.Orientation = v3(-90, 0, 0)
	att2RA.Orientation = v3(0, 180, -180)
	sockRA.LimitsEnabled = true
	sockRA.TwistLimitsEnabled = true
	sockRA.UpperAngle = 100
	sockRA.TwistLowerAngle = 105
	sockRA.TwistUpperAngle = -110
	local hbRA = createhitbox(ra,t)
	
	--Left Arm
	local att1LA,att2LA,sockLA = createglue(t,la,"paralized",t,la,v3((-t.Size.x/2) - (la.Size.x/2),t.Size.y/4,0),v3(0,la.Size.y/4,0))
	att1LA.Orientation = v3(-90, 180, 0)
	att2LA.Orientation = v3(0, -180, 0)
	sockLA.LimitsEnabled = true
	sockLA.TwistLimitsEnabled = true
	sockLA.UpperAngle = 100
	sockLA.TwistLowerAngle = 105
	sockLA.TwistUpperAngle = -90
	local hbLA = createhitbox(la,t)
	
	--Neck
	local att1NEC,att2NEC,sockNEC = createglue(t,h,"paralized",t,la,v3(0,t.Size.y/2,0),v3(0,-h.Size.y/2,0))
	att1NEC.Orientation = v3(0, -90, 90)
	att2NEC.Orientation = v3(0, -90, 90)
	sockNEC.LimitsEnabled = true
	sockNEC.TwistLimitsEnabled = true
	sockNEC.UpperAngle = 80
	sockNEC.TwistLowerAngle = -80
	sockNEC.TwistUpperAngle = 80
	local hbNEC = createhitbox(h,t)
	
	table.insert(help,att1RA)
	table.insert(help,att2RA)
	table.insert(help,sockRA)
	table.insert(help,hbRA)
	
	table.insert(help,att1LA)
	table.insert(help,att2LA)
	table.insert(help,sockLA)
	table.insert(help,hbLA)
	
	table.insert(help,att1RL)
	table.insert(help,att2RL)
	table.insert(help,sockRL)
	table.insert(help,hbRL)
	
	table.insert(help,att1LL)
	table.insert(help,att2LL)
	table.insert(help,sockLL)
	table.insert(help,hbLL)
	
	table.insert(help,att1NEC)
	table.insert(help,att2NEC)
	table.insert(help,sockNEC)
	table.insert(help,hbNEC)
	
	nec.Parent = nil
	rs.Parent = nil
	ls.Parent = nil
	rh.Parent = nil
	lh.Parent = nil
	
	wait(time)
	
	remove(stunnd)
	
	if getUp then
		hum.PlatformStand = false
		stunned = false
	end
	
	nec.Parent = t
	rs.Parent = t
	ls.Parent = t
	rh.Parent = t
	lh.Parent = t
	
	for i,v in pairs(help) do
		remove(v)
	end
end

function climb()
	using = true
	movingRight = false
	movingLeft = false
	holding = false
	moving = false
	local alpha = .25
	local add = .015
	local rutPos = rut.CFrame
	for i = 0,1,.035 do
		rut.CFrame = rut.CFrame :Lerp(rutPos * cf(0,2,-.15),alpha)
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-7.5),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(10),rad(-15),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(.35,-.45,-.15) * angles(rad(95),rad(80),rad(0)) * angles(rad(-15),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(-.35,-.45,-.45) * angles(rad(95),rad(-80),rad(0)) * angles(rad(5),rad(0),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-5),rad(-5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.25,-.25) * angles(rad(-15),rad(5),rad(7.5)),alpha)
		alpha = alpha -add
		swait()
	end
	alpha = .25
	add = .015
	for i = 0,1,.035 do
		rut.CFrame = rut.CFrame :Lerp(rutPos * cf(0,4.25,-1.5),alpha)
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-15),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(20),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.5,.25) * angles(rad(5),rad(10),rad(-7.5)) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.5,.25) * angles(rad(5),rad(-10),rad(10)) * angles(rad(0),rad(0),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,2,-.5) * angles(rad(-2.5),rad(-5),rad(-5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.25,-1.25) * angles(rad(-75),rad(5),rad(5)),alpha)
		alpha = alpha -add
		swait()
	end
	rut.Anchored = false
	using = false
	coroutine.wrap(function()
		wait(.5)
		canGrab = true
	end)()
end

function dash()
	local oldWS = ws
	local oldJP = jp
	ws = 2
	jp = 45
	using = true
	hum.Jump = true
	local vel = ins("BodyVelocity",rut)
	vel.MaxForce = v3(huge,huge,huge)
	vel.Velocity = rut.CFrame.LookVector * 50
	remove(vel,.1)
	local alpha = .25
	local add = .015
	for i = 0,1,.05 do
		local hit = rayc(rut.Position,rut.CFrame.LookVector,{char},3)
		if hit then break end
		canDash = false
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(75),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,-.25,.75) * angles(rad(80),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(170),rad(-15),rad(5)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(170),rad(15),rad(-5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(-10),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.25,-.15) * angles(rad(-25),rad(5),rad(-2.5)),alpha)
		alpha = alpha -add
		swait()
	end
	using = false
	ws = oldWS
	jp = oldJP
end

function roLl()
	using = true
	local oldWS = ws
	local oldJP = jp
	ws = 0
	jp = 0
	local alpha = .15
	local add = 0
	local rot = 0
	hum.HipHeight = -1.5
	rut.CFrame = rut.CFrame * cf(0,-1.5,0)
	local vel = ins("BodyVelocity",rut)
	vel.MaxForce = v3(huge,huge,huge)
	vel.Velocity = rut.CFrame.LookVector * 35
	for i = 0,1,.0475 do
		local hit = rayc(rut.Position,rut.CFrame.LookVector,{char},3)
		if hit then break end
		canDash = false
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-65),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(-45),rad(25)) * angles(rad(rot),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,.2,-.35) * angles(rad(80),rad(0),rad(0)) * angles(rad(0),rad(0),rad(-80)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(30),rad(20),rad(40)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,1.5,-.65) * angles(rad(-20),rad(0),rad(0)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,1.5,-.5) * angles(rad(-15),rad(0),rad(0)),alpha)
		rot = rot + 25
		alpha = alpha -add
		swait()
	end
	hum.HipHeight = 0
	remove(vel)
	ws = oldWS
	jp = oldJP
	using = false
end

function wallClimb()
	if not wallClimbDeb and not holding then
		using = true
		wallClimbDeb = true
		oldWS = ws
		oldJP = jp
		ws = 0
		jp = 0
		local vel = ins("BodyVelocity",rut)
		vel.MaxForce = v3(huge,huge,huge)
		vel.Velocity = v3(0,30,0)
		remove(vel,.1)
		local alpha = .65
		for i = 0,1,.1 do
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(45),rad(0),rad(0)),alpha)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(-2.5),rad(0),rad(0)),alpha)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.15,-.2) * angles(rad(165),rad(-5),rad(-5)),alpha)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.1,-.15) * angles(rad(170),rad(5),rad(5)),alpha)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.1,-.1) * angles(rad(-10),rad(0),rad(0)),alpha)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),alpha)
			alpha = alpha -.025
			swait()
		end
		ws = oldWS
		jp = oldJP
		using = false
		coroutine.wrap(function()
			wait(1.5)
			wallClimbDeb = false
		end)()
	end
end

mouse.KeyDown:Connect(function(key)
	if not using and not stunned then
		if key == "g" and canDash then
			dash()
		end
	end
	
	if key == "n" and not using  and not dancin then
		dancin = true
		using = true
	elseif key == "n" and using  and dancin then
		dancin = false
		using = false
	end
	
	if key == "f" then
		lightEnabled = not lightEnabled
	end
	
	if key == "q" then
		ws = 25
		jp = 35
	end
	
	if holding and not stunned then
		if key == "a" then
			movingLeft = true
			movingRight = false
			moveDir = -1
		elseif key == "d" then
			movingRight = true
			movingLeft = false
			moveDir = 1
		elseif key == "s" then
			movingRight = false
			movingLeft = false
			holding = false
			rut.Anchored = false
			using = false
			canGrabLedge = false
			wait(.5)
			canGrabLedge = false
			canGrab = true
		elseif key == "w" then
			local detec = rayc(rut.CFrame * cf(0,2.75,-.5).Position,rut.CFrame.LookVector,{char},1.5)
			if not detec then
				climb()
			end
		end
	end
end)

mouse.KeyUp:Connect(function(key)
	if not using then
		
	end
	if key == "q" then
		ws = 8
		jp = 35
	end
	if holding then
		if key == "a" then
			moveDir = 0
			movingLeft = false
		elseif key == "d" then
			moveDir = 0
			movingRight = false
		end
	end
end)

hum.Died:Connect(function()
	--charDeath()
end)

while true do
	Swait()
	if stunned then
		hum.PlatformStand = true
	else
		hum.PlatformStand = false
	end
	
	sine = sine + change
	dSine = dSine + change
	
	if dSine >-1500 and dSine <1500 then
		dSine = 1500
	end
	
	if dSine > 5000 then
		dSine = -5000
	end
	
	local verVel = rut.Velocity.y
	local horVel = (rut.Velocity * v3(1,0,1)).Magnitude

	local Ccf=rut.CFrame
	
	local dir = hum.MoveDirection
	
	if dir == v3(0,0,0) then
		dir = rut.Velocity/10
	end

	local Walktest1 = dir * Ccf.LookVector
	local Walktest2 = dir * Ccf.RightVector

	local rotfb = Walktest1.X+Walktest1.Z
	local rotrl = Walktest2.X+Walktest2.Z
	
	if rotfb >1 then
		rotfb = 1
	elseif rotfb <-1 then
		rotfb = -1
	end
	
	if rotrl >1 then
		rotrl = 1
	elseif rotrl <-1 then
		rotrl = -1
	end
	
	if lightEnabled then
		for i,v in pairs(lamp:GetDescendants()) do
			if v:IsA("SurfaceLight") then
				v.Enabled = true
			end
			if string.find(v.Name:lower(),"light") and v:IsA("Part") then
				v.Color = bc("White").Color
			end
		end
	else
		for i,v in pairs(lamp:GetDescendants()) do
			if v:IsA("SurfaceLight") then
				v.Enabled = false
			end
			if string.find(v.Name:lower(),"light") and v:IsA("Part") then
				v.Color = bc("Really black").Color
			end
		end
	end
	ignoreList = {char}
	for i,v in pairs(workspace:GetDescendants()) do
		if v:IsA("Humanoid") then
			table.insert(ignoreList,v.Parent)
		end
	end
	
	if not dancin then
		hum.WalkSpeed = ws
		hum.JumpPower = jp
	else
		hum.WalkSpeed = 2
		hum.JumpPower = 0
	end
	
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		--if not v.PlayerGui:FindFirstChild(shaker.Name) then
			--local shak = shaker:Clone()
			--shak.Parent = v.PlayerGui
			--shak.Disabled = false
		--end
	end
	
	local hit,pos,nId
	local ledgeDetector,ledgePos = rayc(rut.CFrame * cf(0,5,-random(125,150)/100).Position,-rut.CFrame.UpVector,ignoreList,5)
	local wCHit,wCPos,wCNId = rayc(rut.CFrame * cf(0,5.75,-.5).Position,rut.CFrame.LookVector,ignoreList,1.25)
	
	if not holding then
		hit,pos,nId = rayc(rut.Position + v3(0,-rut.Size.y/2,0),v3(rut.Position.x,-10000,rut.Position.z),ignoreList,3)
	else
		hit,pos,nId = rayc(rut.Position + v3(0,-rut.Size.y/2,0),v3(rut.Position.x,-10000,rut.Position.z),ignoreList,0)
	end
	
	if canWallClimb and not using and not ledgeDetector then
		canWallClimb = false
		spawn(function()
			wallClimb()
		end)
	end
	
	if using then
		anim = "idle"
	end
	
	if canGrabLedge and not using and canGrab and not stunned and not dancin then
		canGrabLedge = false
		local poss = v3(rut.Position.x,ledgePos.y -.025,rut.Position.z)
		local grabHit,grabPos,grabNID = rayc(poss,((ledgePos - v3(0,.025,0)) - poss),ignoreList,5)
		local blocked = rayc(cf(rut.CFrame.X,grabPos.Y + .25,rut.CFrame.Z).Position,(grabPos - cf(rut.CFrame.X,grabPos.Y,rut.CFrame.Z).Position),ignoreList,1.25)
		if grabHit and not blocked then
			using = true
			canGrab = false
			rut.Anchored = true
			rut.CFrame = cf(grabPos,grabPos-grabNID) * cf(0,-2.5,.55)
			holding = true
		end
	end
	
	if fallTime > 2 and not stunned then
		coroutine.wrap(function()
			stun(250,false)
		end)()
	end
	
	if verVel >-10 and fallTime >= .5 and hit and (horVel <5 and ws ~= 35 or ws == 8) or verVel >-10 and fallTime >= 1.25 and hit and not dancin then
		hum.Health = hum.Health - fallTime * 50
		if fallTime > .75 then
			ui.StunCover.BackgroundTransparency = 0
			tlerp(ui.StunCover,{BackgroundTransparency = 1},7.5,styles.Quad,directions.Out)
			sound(2801263,.75,random(90,110)/100,t,.25)
			for i = 1,random(10,20) * fallTime do
				blood(t.CFrame,v3(random(-10,10)/10,random(5,10)/10,random(-10,10)/10),random(random(10,20)),random(75,125)/100)
			end
			sound(2561290769,1.25,random(90,110)/100,t,.25)
			localEffectsEvent:FireClient("shak")
			coroutine.wrap(function()
				stun(((random(75,100)/10) * fallTime) + (1/(hum.Health/hum.MaxHealth)),true,true)
			end)()
		else
			sound(363808674,.75,random(150,175)/100,t,.25)
		end
		fallTime = 0
	elseif verVel >-10 and fallTime >= .35 and fallTime <1.25 and hit and (horVel >= 5 and ws == 35 or ws ~= 8) then
		fallTime = 0
		roLl()
	end
	
	if hit then
		canDash = true
	end
	
	if anim == "idle" and hit and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/30) * rad(.75),sin(sine/120) * rad(2.5),-sin(sine/240) * rad(2)) * angles(-mouse.Hit.LookVector.Y,0,0),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(-sin(sine/120)/17.5,sin(sine/30)/25,sin(sine/30)/17.5) * angles(sin(sine/60) * rad(1.25),-sin(sine/240) * rad(1.5),sin(sine/120) * rad(1)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,sin(sine/30)/25,-sin(sine/240)/25) * angles(sin(sine/60) * rad(2) + sin(sine/120) * rad(3),sin(sine/90) * rad(-1),sin(sine/120) * rad(-1)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,sin(sine/30)/25,sin(sine/240)/25) * angles(sin(sine/60) * rad(2) + sin(sine/120) * rad(-3),-sin(sine/90) * rad(-1),sin(sine/120) * rad(-1)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,(sin(sine/120)/60) + sin(sine/30)/25,sin(sine/60)/22.5) * angles(sin(sine/60) * rad(2.5),rad(0),sin(sine/120) * rad(1)) * angles(sin(sine/30) * rad(-2),-sin(sine/240) * rad(1.5),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,(-sin(sine/120)/60) + sin(sine/30)/25,-sin(sine/60)/22.5) * angles(sin(sine/60) * rad(1.25),rad(0),sin(sine/120) * rad(1)) * angles(sin(sine/30) * rad(-2),-sin(sine/240) * rad(1.5),rad(0)),.1)
	elseif anim == "fall" and not hit and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)) * angles(-mouse.Hit.LookVector.Y,0,0),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "jump" and not hit and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)) * angles(-mouse.Hit.LookVector.Y,0,0),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "walk" and hit and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(-sin(sine/2.5) * rad(2),sin(sine/5) * rad(1),-sin(sine/5) * rad(1)) * angles(0,rotrl/2,0) * angles(-mouse.Hit.LookVector.Y,0,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,cos(sine/2.5)/10,0) * angles(sin(sine/2.5) * rad(2),sin(sine/5) * rad(3.5),0) * angles(-rotfb/13.5,rut.RotVelocity.y/90,-rotrl/10),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,-cos(sine/5)/25,cos(sine/5)/15) * angles(-sin(sine/5) * rad(30) * rotfb,sin(sine/5) * rad(5),-sin(sine/2.5) * rad(2.5) + (-sin(sine/5) * rad(5) * rotrl)),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,cos(sine/5)/25,-cos(sine/5)/15) * angles(sin(sine/5) * rad(30) * rotfb,sin(sine/5) * rad(5),-sin(sine/2.5) * rad(2.5) + (sin(sine/5) * rad(5) * rotrl)),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,cos(sine/5)/6.5,-cos(sine/5)/7.5) * angles(rad(4) + sin(sine/5) * rad(30) * rotfb,rad(0),sin(sine/5) * rad(30) * rotrl),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,-cos(sine/5)/6.5,cos(sine/5)/7.5) * angles(rad(4) + sin(sine/5) * rad(-30) * rotfb,rad(0),-sin(sine/5) * rad(30) * rotrl),.2)
	elseif anim == "run" and hit and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/1.25) * rad(5),rad(0),rad(0)) * angles(0,rotrl/1.5,0) * angles(-mouse.Hit.LookVector.Y,0,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(sine/1.25)/5,0) * angles(sin(sine/1.25) * rad(5),sin(sine/2.5) * rad(5),rad(0)) * angles(-rotfb/5,0,-rotrl/5),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,cos(sine/2.5)/10,-cos(sine/2.5)/10) * angles(sin(sine/2.5) * rad(80) * rotfb,sin(sine/1.25) * rad(10),sin(sine/2.5) * rad(10) * rotrl),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,-cos(sine/2.5)/10,cos(sine/2.5)/10) * angles(-sin(sine/2.5) * rad(80) * rotfb,sin(sine/1.25) * rad(10),-sin(sine/2.5) * rad(10) * rotrl),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,-cos(sine/2.5)/2.5,cos(sine/2.5)/3.5) * angles((-sin(sine/2.5) * rad(60) + rad(5)) * rotfb,rad(0),-sin(sine/2.5) * rad(50) * rotrl),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,cos(sine/2.5)/2.5,-cos(sine/2.5)/3.5) * angles((sin(sine/2.5) * rad(60) + rad(5)) * rotfb,rad(0),sin(sine/2.5) * rad(50) * rotrl),.2)
	elseif holding and moveDir ~= 0 and moving and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/15) * rad(2.5),moveDir/1.5,rad(0)) * angles(-mouse.Hit.LookVector.Y,0,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(sine/7.5)/15,0) * angles(sin(sine/7.5) * rad(1),rad(0),sin(sine/15) * rad(1) + (-moveDir/15)),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,(cos(sine/15)/7.5) + moveDir/10,0) * angles(sin(sine/15) * rad(25) * moveDir,rad(0),rad(0)),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,(-cos(sine/15)/7.5) - moveDir/10,0) * angles(sin(sine/15) * rad(25) * moveDir,rad(0),rad(0)),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(cos(sine/15) * rad(1.5),rad(0),rad(0)),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(-cos(sine/15) * rad(2.5),rad(0),rad(0)),.2)
	elseif holding and  moveDir == 0 or not moving and not dancin then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/30) * rad(2.5),sin(sine/60) * rad(10),rad(0)) * angles(-mouse.Hit.LookVector.Y,0,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(cos(sine/60)/15,sin(sine/30)/20,0) * angles(rad(0),sin(sine/60) * rad(2.5),rad(0)),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(cos(sine/60)/15,-sin(sine/30)/20,0) * angles(-cos(sine/60) * rad(1.5),rad(0),-sin(sine/60) * rad(2)),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(cos(sine/60)/15,-sin(sine/30)/20,0) * angles(cos(sine/60) * rad(1.5),rad(0),-sin(sine/60) * rad(2)),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(cos(sine/60) * rad(2.5),rad(0),rad(0)),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(-cos(sine/60) * rad(2.5),rad(0),rad(0)),.2)
	elseif dancin then
		local sSin = sin(dSine/75)
		local sCos = cos(dSine/25)
		local lSine = dSine * (sCos * sSin)/75
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(lSine/5) * rad(5),sin(lSine/10) * rad(25),-cos(lSine/10) * rad(10)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(lSine/5)/5,0) * angles(sin(lSine/5) * rad(5),-cos(lSine/10) * rad(35),cos(lSine/10) * rad(10)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,cos(lSine/5)/2.5) * angles(rad(-105),rad(0),rad(0)) * angles(sin(lSine/20) * rad(20),sin(lSine/10) * rad(65),cos(lSine/10) * rad(55)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,-cos(lSine/5)/2.5) * angles(rad(-105),rad(0),rad(0)) * angles(-sin(lSine/20) * rad(20),sin(lSine/10) * rad(65),cos(lSine/10) * rad(55)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,(sin(lSine/5)/5) + cos(lSine/10)/10,0) * angles((sin(lSine/5) * rad(10)) - cos(lSine/10) * rad(15),-cos(lSine/10) * rad(10),cos(lSine/10) * rad(15)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,(sin(lSine/5)/5) - cos(lSine/10)/10,0) * angles((sin(lSine/5) * rad(10)) + cos(lSine/10) * rad(15),-cos(lSine/10) * rad(10),cos(lSine/10) * rad(15)),.1)
	end
	
	if movingLeft then
		movingRight = false
	elseif movingRight then
		movingLeft = false
	end
	
	if holding and not stunned and not dancin then
		using = true
		canDash = true
		rut.Velocity = v3(0,0,0)
		anim = "idle"
		change = 1
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(45),rad(0),rad(0)),.2)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(.25,.65,-.65) * angles(rad(170),rad(0),rad(-5)) * angles(rad(0),rad(80),rad(0)),.2)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(-.25,.65,-.65) * angles(rad(170),rad(0),rad(5)) * angles(rad(0),rad(-80),rad(0)),.2)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(-2.5),rad(-5),rad(2.5)),.2)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.1,-.1) * angles(rad(-5),rad(5),rad(-1.5)),.2)
		
		ledgeDetector,ledgePos = rayc(rut.CFrame * cf(0,5,-.575).Position,-rut.CFrame.UpVector,ignoreList,5)
		
		local cff = rut.CFrame * cf(0,0,.75)
		local poss = v3(cff.X,ledgePos.y -.025,cff.Z)
		local lPos = cf(poss,ledgePos) * cf(0,0-.025,-1.275)
		local grabHit,grabPos,grabNID = rayc(poss,(lPos.Position - poss),ignoreList,3.25)
		local decL = rayc(rut.CFrame * cf(-1.75,2.5,.75).Position,rut.CFrame.LookVector,ignoreList,3)
		local decR = rayc(rut.CFrame * cf(1.75,2.5,.75).Position,rut.CFrame.LookVector,ignoreList,3)
		if grabHit then
			if movingLeft and decL then
				ledgePos = cf(grabPos,grabPos-grabNID) * cf(-.1,-2.5,.55)
				moving = true
			elseif not decL then
				moving = false
			end
			if movingRight and decR then
				ledgePos = cf(grabPos,grabPos-grabNID) * cf(.1,-2.5,.55)
				moving = true
			elseif not decR then
				moving = false
			end
		end
		if typeof(ledgePos) == "CFrame" then
			rut.CFrame = rut.CFrame:Lerp(ledgePos,.35)
		end
	end
	if not using and not dancin then
		if horVel > 5 and verVel >-10 and verVel <10 and ws == 8 then
			anim = "walk"
			fallTime = 0
			change = .6
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		elseif horVel > 5 and verVel >-10 and verVel <10 and ws == 25 then
			anim = "run"
			fallTime = 0
			change = .5
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		elseif verVel >10 then
			fallTime = 0
			local obstacleRay = rayc(rut.CFrame * cf(0,2.6,0).Position,rut.CFrame.LookVector,ignoreList,.55)
			if ledgeDetector and not hit and not obstacleRay then
				canGrabLedge = true
			end
			if wCHit then
				canWallClimb = true
			end
			anim = "jump"
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(15),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(142),rad(0),rad(7)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(145),rad(0),rad(-8)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(-3.5)),.2)
		elseif verVel <-10 then
			local obstacleRay = rayc(rut.CFrame * cf(0,2.6,0).Position,rut.CFrame.LookVector,ignoreList,.55)
			if ledgeDetector and not hit and not obstacleRay then
				canGrabLedge = true
			end
			fallTime = fallTime +.025
			anim = "fall"
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(.45,-.46,0) * angles(rad(5),rad(0),rad(105)),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(-.45,-.44,0) * angles(rad(6),rad(0),rad(-97.5)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(-3.5)),.2)
		elseif horVel < 5 and verVel >-10 and verVel <10 then
			anim = "idle"
			fallTime = 0
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(1.5)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(-1.5)),.1)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(-4),rad(2)),.1)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(4),rad(-2)),.1)
		end
	elseif using and dancin then
		change = 1
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(2.5)),.2)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(-2.5)),.2)
	end
end
end)

Section:NewButton("Internal war free", "ButtonInfo", function()
    print("Clicked")
-- Synapse Decompiler
-- Purchase Here: https://brack4712.xyz/synapse/purchase/
--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
    local unit = realPartVelocity.Unit
    if (unit.Y > 0.9) or (unit.Y < -0.9) then
        return realPartVelocity * (25.1 / realPartVelocity.Y)
    end
    realPartVelocity *= Vector3_101
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        realPartVelocity = unit * Vector3_101 * 100
    end
    return realPartVelocity + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = true --set it to true if you want noclip
local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function Destroy_Mesh(hat)
    print(hat)
    local hat1 = hat.Handle:FindFirstChildOfClass("SpecialMesh") or hat.Handle:FindFirstChildOfClass("SpecialMesh")
    hat1:Destroy()
end

local hat1 = gp(c, "Robloxclassicred", "Accessory")
Destroy_Mesh(hat1)

local hat2 = gp(c, "LavanderHair", "Accessory")
Destroy_Mesh(hat2)

local hat3 = gp(c, "Pink Hair", "Accessory")
Destroy_Mesh(hat3)

local hat4 = gp(c, "Kate Hair", "Accessory")
Destroy_Mesh(hat4)

local hat5 = gp(c, "Hat1", "Accessory")
Destroy_Mesh(hat5)

local hat6 = gp(c, "Pal Hair", "Accessory")
Destroy_Mesh(hat6)

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

--[[
    fling function
    usage: fling(target, duration, velocity)
    target can be set to: basePart, CFrame, Vector3, character model or humanoid
    duration (fling time) can be set to a number or a string containing the number (in seconds) will be set to 0.5 if not provided,
    velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)
]]

local flingpart0 = gp(model, flingpart, "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0.Destroying:Connect(function()
        flingpart0 = nil
        fling = function() end
    end)
    flingpart0.Archivable = true
    flingpart1.Destroying:Connect(function()
        flingpart1 = nil
        fling = function() end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0.Destroying:Connect(function()
            att0 = nil
            fling = function() end
        end)
        att1.Destroying:Connect(function()
            att1 = nil
            fling = function() end
        end)
        local lastfling = nil
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                return
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Destroying:Connect(function()
                flingpart = nil
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local steppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = stepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = steppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end

wait(7)

wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound", Character)
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
script.Parent = WEAPONGUI
--Character.Archivable = true
local SHADOW = Character:Clone()
SHADOW.Parent = Character
RootPart2 = SHADOW.HumanoidRootPart
Torso2 = SHADOW.Torso
Head2 = SHADOW.Head
RightArm2 = SHADOW["Right Arm"]
LeftArm2 = SHADOW["Left Arm"]
RightLeg2 = SHADOW["Right Leg"]
LeftLeg2 = SHADOW["Left Leg"]
RootJoint2 = RootPart2.RootJoint
Neck2 = Torso2.Neck
RightShoulder2 = Torso2["Right Shoulder"]
LeftShoulder2 = Torso2["Left Shoulder"]
RightHip2 = Torso2["Right Hip"]
LeftHip2 = Torso2["Left Hip"]
SHADOW.PrimaryPart = RootPart2
--Character.Archivable = false
SHADOW.Name = "'s War"





local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local ROAR = 528589078
local E = 1.32
local PLAYSONG = true
local REPLAY = false
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local weldBetween = function(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = VOLUME * 5
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function WACKYEFFECT(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material or "Neon"
	local COLOR = Table.Color or C3(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0, 0, 0))
		end
		if MSH ~= nil then
			local MOVESPEED
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude / TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME + 1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH / TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0, 0, -MSH.Scale.X / 8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until SOUND.Playing == false
				EFFECT:remove()
			end
		elseif PLAYSSOUND == false then
			EFFECT:remove()
		else
			repeat
				Swait()
			until SOUND.Playing == false
			EFFECT:remove()
		end
	end))
end
function MakeForm(PART, TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh", PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Wedge"
	end
end
Debris = game:GetService("Debris")
function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos, EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end
function GetRoot(MODEL, ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	end
end
function FacialShadow()
	local SHADOWS = {}
	for i = 1, 16 do
		local FACE = CreatePart(3, Effects, "Fabric", 0, 0 + (i - 1) / 16.2, "Dark stone grey", "FaceGradient", VT(1.01, 0.65, 1.01), false)
		FACE.Color = C3(0, 0, 0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0, 0.45 - (i - 1) / 25, 0), CF(0, 0, 0))
		table.insert(SHADOWS, FACE)
	end
	local function UNDO()
		for i = 1, #SHADOWS do
			SHADOWS[i]:remove()
		end
	end
	return UNDO
end
function CreateFlyingDebree(FLOOR, POSITION, AMOUNT, BLOCKSIZE, SWAIT, STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			do
				local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
				DEBREE.Material = FLOOR.Material
				DEBREE.Color = FLOOR.Color
				DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
				DEBREE.Velocity = VT(MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH), MRANDOM(-STRENGTH, STRENGTH))
				coroutine.resume(coroutine.create(function()
					Swait(15)
					DEBREE.Parent = workspace
					DEBREE.CanCollide = true
					Debris:AddItem(DEBREE, SWAIT)
				end))
			end
		end
	end
end
local SIZE = 1
print(Torso2.Size)
RootPart2.Size = RootPart.Size * SIZE
Torso2.Size = Torso.Size * SIZE
RightArm2.Size = RightArm.Size * SIZE
RightLeg2.Size = RightLeg.Size * SIZE
LeftArm2.Size = LeftArm.Size * SIZE
LeftLeg2.Size = LeftLeg.Size * SIZE
RootJoint2.C0 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
RootJoint2.C1 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck2.C0 = NECKC0 * CF(0 * SIZE, 0 * SIZE, 0 + (1 * SIZE - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck2.C1 = CF(0 * SIZE, -0.5 * SIZE, 0 * SIZE) * ANGLES(RAD(-90), RAD(0), RAD(180))
RightShoulder2.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
LeftShoulder2.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
RightHip2.C0 = CF(1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip2.C0 = CF(-1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
RightHip2.C1 = CF(0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip2.C1 = CF(-0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
Head2.Size = VT(1, 1, 1) * SIZE
RootJoint2.Parent = RootPart
Neck2.Parent = Torso
RightShoulder2.Parent = Torso
LeftShoulder2.Parent = Torso
RightHip2.Parent = Torso
LeftHip2.Parent = Torso
local SKILLTEXTCOLOR = C3(1, 1, 1)
local SKILLFONT = "Fantasy"
local SKILLTEXTSIZE = 6
local ATTACKS = {
	"Z-Tremor Punch",
	"E-Meteor Impact",
	"R-Uppercut"
}
local GUIS = {}
for i = 1, #ATTACKS do
	local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.05, 0, 0.9 - 0.04 * i, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill Frame")
	local SKILLTEXT = CreateLabel(SKILLFRAME, "[" .. ATTACKS[i] .. "]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Skill text")
	SKILLTEXT.TextXAlignment = "Left"
	table.insert(GUIS, SKILLTEXT)
end
function ApplyDamage(Humanoid, Damage)
	Damage = 0
	if Humanoid.Health < 2000 and Humanoid.Parent.HumanoidRootPart ~= nil and Humanoid.Parent ~= nil and Humanoid.Parent.Head ~= nil then
		if Humanoid.Health - Damage > 0 then
			fling(Humanoid.Parent.HumanoidRootPart.Position, 0.1)
			--Humanoid.Health = Humanoid.Health - Damage
		else
			fling(Humanoid.Parent.HumanoidRootPart.Position, 0.1)
			--Humanoid.Parent:BreakJoints()
		end
	else
		fling(Humanoid.Parent.Head.Position, 0.1)
		--Humanoid.Parent:BreakJoints()
	end
end
function ApplyAoE(POSITION, RANGE, MINDMG, MAXDMG, FLING, INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
					if INSTAKILL == true then
						for i = 1, 35 do
							fling(TORSO.Position, 0.1)
						
						end
					else
						for i = 1, 35 do
							fling(TORSO.Position, 0.1)
						
						end
					end
					if FLING > 0 then
						for _, c in pairs(CHILD:GetChildren()) do
							if c:IsA("BasePart") then
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
								bv.velocity = CF(POSITION, TORSO.Position).lookVector * FLING
								bv.Parent = c
								Debris:AddItem(bv, 0.05)
							end
						end
					end
				end
			end
		end
	end
end
function Intro()
	EQUIPPED = true
	ATTACK = true
	Rooted = true
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootPart2.Anchored = true
			for _, c in pairs(SHADOW:GetChildren()) do
				if c:IsA("Part") then
					--c.Color = C3(1, 1, 1)
					--if c ~= RootPart2 then
						--c.Transparency = E + 0.15 * SIN(SINE / 12)
					--end
					if c then
						c.Transparency = 1
					end
					if c:FindFirstChildOfClass("Decal") then
						c:ClearAllChildren()
					end
					c.CanCollide = false
					c.Material = "Neon"
				else
					c:remove()
				end
			end
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(-35)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(35)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-1), RAD(0), RAD(3)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-1), RAD(0), RAD(-3)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-12), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
		until ATTACK == false
	end))
	wait(1)
	SHADOW.Parent = Character
	SHADOW:SetPrimaryPartCFrame(RootPart.CFrame * CF(0, -20, 5))
	local lp = game:GetService("Players").LocalPlayer

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local hat = gp(cplayer, "Robloxclassicred", "Accessory")
local handle = gp(hat, "Handle", "BasePart")
local att = gp(handle, "att1_Handle", "Attachment")
att.Parent = SHADOW.Torso
att.Position = v3(-0.5,0,0)
att.Rotation = v3(90, 0, 0)

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att = gp(handle2, "att1_Handle", "Attachment")
att.Parent = SHADOW.Torso
att.Position = v3(0.5,0,0)
att.Rotation = v3(90, 0, 0)

local hat3 = gp(cplayer, "Pink Hair", "Accessory")
local handle3 = gp(hat3, "Handle", "BasePart")
local att = gp(handle3, "att1_Handle", "Attachment")
att.Parent = SHADOW["Right Arm"]
att.Position = v3(0,0,0)
att.Rotation = v3(90, 0, 0)

local hat4 = gp(cplayer, "Kate Hair", "Accessory")
local handle4 = gp(hat4, "Handle", "BasePart")
local att = gp(handle4, "att1_Handle", "Attachment")
att.Parent = SHADOW["Left Arm"]
att.Position = v3(0,0,0)
att.Rotation = v3(90, 0, 0)

local hat5 = gp(cplayer, "Pal Hair", "Accessory")
local handle5 = gp(hat5, "Handle", "BasePart")
local att = gp(handle5, "att1_Handle", "Attachment")
att.Parent = SHADOW["Right Leg"]
att.Position = v3(0,0,0)
att.Rotation = v3(90, 0, 0)

local hat6 = gp(cplayer, "Hat1", "Accessory")
local handle6 = gp(hat6, "Handle", "BasePart")
local att = gp(handle6, "att1_Handle", "Attachment")
att.Parent = SHADOW["Left Leg"]
att.Position = v3(0,0,0)
att.Rotation = v3(90, 0, 0)

local hat6 = gp(cplayer, "MediHood", "Accessory")
local handle6 = gp(hat6, "Handle", "BasePart")
local att = gp(handle6, "att1_Handle", "Attachment")
att.Parent = SHADOW["Head"]
att.Position = v3(0,0,0)
att.Rotation = v3(0, 0, 0)


for _, c in pairs(SHADOW:GetChildren()) do
	if c:IsA("Part") then
		--c.Color = C3(1, 1, 1)
		--if c ~= RootPart2 then
			--c.Transparency = E + 0.15 * SIN(SINE / 12)
		--end
		if c then
			c.Transparency = 1
		end
	else
		c:remove()
	end
end

	local HIT, POS = Raycast(RootPart.CFrame * CF(0, 0, 5).p, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
	for i = 1, 250 do
		Swait()
		E = E - 0.0032
		local AREA = CF(POS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * CF(0, 0, MRANDOM(2, 18))
		local TIMER = MRANDOM(20, 80)
		WACKYEFFECT({
			Time = TIMER,
			EffectType = "Sphere",
			Size = VT(1, 1, 1),
			Size2 = VT(0, 45, 0),
			Transparency = 0,
			Transparency2 = 0,
			CFrame = AREA,
			MoveToPos = AREA.p + VT(0, MRANDOM(35, 160), 0),
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = 0.8,
			SoundVolume = 5
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.01)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-15), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-15), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 0, 0.6, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(140), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(140), RAD(0), RAD(25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(25), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	CreateSound(ROAR, Head2, 10, 1, false)
	for i = 0, 4, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
function Roar(TABLE)
	ATTACK = true
	Rooted = true
	local E = false
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 8, 0), 0.1)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(35), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.65, 0) * ANGLES(RAD(170), RAD(0), RAD(-22)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.45, 0.65, 0) * ANGLES(RAD(170), RAD(0), RAD(22)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		until E == true
	end))
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.15 * SIZE, 0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(140), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.15 * SIZE, 0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(140), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(25), RAD(80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(25), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	CreateSound(ROAR, Effects, 4, 1, false)
	if TABLE then
		for E = 1, #TABLE do
			if TABLE[E]:FindFirstChildOfClass("Humanoid") then
				local ROOT = GetRoot(TABLE[E], true)
				if ROOT then
					for i = 1, 35 do
						fling(ROOT.Position, 0.1)
					
					end
				end
			end
		end
	end
	for i = 0, 6, 0.1 / Animation_Speed do
		Swait()
		local HITFLOOR, HITPOS = Raycast(RootPart2.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
		if HITFLOOR then
			CreateFlyingDebree(HITFLOOR, CF(HITPOS), 1, VT(1, 1, 1) * MRANDOM(7, 15) / 10, 5, 60)
		end
		WACKYEFFECT({
			EffectType = "Wave",
			Size = VT(20, 1, 20),
			Size2 = VT(25 + MRANDOM(0, 8), 7, 25 + MRANDOM(0, 8)),
			Transparency = 0.9,
			Transparency2 = 1,
			CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 5,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-35), RAD(MRANDOM(-3, 3)), RAD(MRANDOM(-3, 3))), 1 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.7 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	E = true
	if TABLE then
		CreateSound(1535995263, Head, 10, 1, false)
		for i = 0, 2.2, 0.1 / Animation_Speed do
			Swait()
			RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(-5 + 2 * SIN(SINE / 12)), RAD(15), RAD(35)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.3 * SIZE, -0.6 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(25), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	ATTACK = false
	Rooted = false
end
function Punch()
	ATTACK = true
	Rooted = false
	local HITS = {}
	Speed = 12
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	CreateSound(588693579, RightArm2, 6, MRANDOM(8, 12) / 10, false)
	for i = 0, 0.3, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({
			EffectType = "Box",
			Size = RightArm2.Size,
			Size2 = RightArm2.Size,
			Transparency = RightArm2.Transparency,
			Transparency2 = 1,
			CFrame = RightArm2.CFrame,
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.4)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(135), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			do
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					do
						local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO and (TORSO.Position - RightArm2.CFrame * CF(0, -2, 0).p).Magnitude <= 15 then
							table.insert(HITS, CHILD)
							coroutine.resume(coroutine.create(function()
								CreateSound(260430117, TORSO, 3, MRANDOM(8, 12) / 10, false)
								--TORSO.Anchored = true
								local POS = TORSO.CFrame
								
								for i = 1, 35 do
									Swait()
									--ApplyDamage(HUM, MRANDOM(1, 1))
									fling(TORSO.Position, 0.1)
									--TORSO.CFrame = POS * CF(MRANDOM(-2, 2) / 10, MRANDOM(-2, 2) / 10, MRANDOM(-2, 2) / 10)
								end
								--TORSO.Anchored = false
							end))
						end
					end
				end
			end
		end
	end
	for i = 0, 0.2, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({
			EffectType = "Box",
			Size = RightArm2.Size,
			Size2 = RightArm2.Size,
			Transparency = RightArm2.Transparency,
			Transparency2 = 1,
			CFrame = RightArm2.CFrame,
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.5)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(135), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if #HITS > 0 then
		for i = 0, 0.5, 0.1 / Animation_Speed do
			Swait()
			RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.5)
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(135), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Roar(HITS)
	end
	Speed = 16
	ATTACK = false
	Rooted = false
end
function Throw()
	ATTACK = true
	Rooted = false
	local DEBREE = {}
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 1, 2), 0.2)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(90), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local CFRAME = RootPart2.CFrame * CF(0, 50, 0)
	Humanoid.PlatformStand = true
	UNANCHOR = false
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, CF(CFRAME.p, VT(Mouse.Hit.p.X, RootPart2.Position.Y, Mouse.Hit.p.Z)), 0.2)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(90), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootPart.CFrame = RootPart2.CFrame * CF(0, -1, -2)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local WELD = CreateWeldOrSnapOrMotor("Weld", RightArm2, RightArm2, Torso, CF(0, -2, 0) * ANGLES(RAD(-90), RAD(0), RAD(0)), CF(0, 0, 0))
	for i = 0, 0.4, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, CF(CFRAME.p, VT(Mouse.Hit.p.X, RootPart2.Position.Y, Mouse.Hit.p.Z)), 0.2)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(140), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.3) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, -0.3) * ANGLES(RAD(80), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.4, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local IMPACT = false
	WELD:remove()
	RootPart.CFrame = CF(RightArm2.CFrame * CF(0, -3, 0).p, Mouse.Hit.p)
	CreateSound(588693579, RightArm2, 6, MRANDOM(8, 12) / 10, false)
	for i = 0, 0.4, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({
			EffectType = "Box",
			Size = RightArm2.Size,
			Size2 = RightArm2.Size,
			Transparency = RightArm2.Transparency,
			Transparency2 = 1,
			CFrame = RightArm2.CFrame,
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, CF(CFRAME.p, VT(Mouse.Hit.p.X, RootPart2.Position.Y, Mouse.Hit.p.Z)), 0.2)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(140), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.3) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, -0.3) * ANGLES(RAD(80), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.4, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(140), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.3) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, -0.3) * ANGLES(RAD(80), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.4, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		until IMPACT == true or ATTACK == false
	end))
	local FLOOR
	for i = 1, 80 do
		Swait()
		local HIT, POS = Raycast(RootPart.Position, RootPart.CFrame.lookVector, 6, Character)
		if HIT then
			FLOOR = HIT
			IMPACT = true
			local ORI = VT(0, RootPart.Orientation.Y, 0)
			RootPart.CFrame = CF(POS + VT(0, 3.5, 0))
			RootPart.Orientation = ORI
			RootJoint.Parent = RootPart
			break
		else
			RootPart.CFrame = RootPart.CFrame * CF(0, 0, -6)
		end
	end
	UNANCHOR = true
	if FLOOR then
		do
			local PLAYING = false
			Humanoid.PlatformStand = false
			local REPLAY = true
			local FLING = false
			coroutine.resume(coroutine.create(function()
				local ROCKS = MRANDOM(8, 13)
				for i = 1, ROCKS do
					local DEBREEPART = CreatePart(3, Effects, FLOOR.Material, 0, 0, FLOOR.BrickColor, "Debree", VT(1, 1, 1) * MRANDOM(2, 7), true)
					DEBREEPART.CFrame = CF(RootPart.Position - VT(0, 7, 0)) * ANGLES(RAD(0), RAD(360 / ROCKS * i), RAD(0)) * CF(0, 0, MRANDOM(20, 28)) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
					table.insert(DEBREE, {
						DEBREEPART,
						DEBREEPART.Orientation,
						CF(DEBREEPART.Position + VT(0, MRANDOM(3, 7) + 8, 0))
					})
				end
				repeat
					Swait()
					for E = 1, #DEBREE do
						local ROCK = DEBREE[E][1]
						ROCK.CFrame = Clerp(ROCK.CFrame, DEBREE[E][3], 0.3)
						ROCK.Orientation = DEBREE[E][2]
					end
				until FLING == true or ATTACK == false
				if FLING == false then
					for E = 1, #DEBREE do
						local ROCK = DEBREE[E][1]
						ROCK.Anchored = false
						Debris:AddItem(ROCK, 4)
					end
				else
					for E = 1, #DEBREE do
						do
							local ROCK = DEBREE[E][1]
							ROCK.CFrame = CF(ROCK.Position, Mouse.Hit.p)
							coroutine.resume(coroutine.create(function()
								for i = 1, 150 do
									Swait()
									local HIT, POS, NORMAL = Raycast(ROCK.Position, ROCK.CFrame.lookVector, 3, Character)
									if HIT then
										break
									else
										ROCK.CFrame = ROCK.CFrame * CF(0, 0, -3)
									end
								end
								ApplyAoE(ROCK.Position, 22, 10, 15, 70, false)
								WACKYEFFECT({
									EffectType = "Box",
									Size = ROCK.Size,
									Size2 = ROCK.Size * 1.2,
									Transparency = 0,
									Transparency2 = 1,
									CFrame = ROCK.CFrame,
									MoveToPos = nil,
									RotationX = 0,
									RotationY = 0,
									RotationZ = 0,
									Material = "Neon",
									Color = C3(1, 1, 1),
									SoundID = nil,
									SoundPitch = nil,
									SoundVolume = nil
								})
								WACKYEFFECT({
									Time = 15,
									EffectType = "Sphere",
									Size = ROCK.Size,
									Size2 = VT(35, 35, 35),
									Transparency = 0.8,
									Transparency2 = 1,
									CFrame = CF(ROCK.Position),
									MoveToPos = nil,
									RotationX = 0,
									RotationY = 0,
									RotationZ = 0,
									Material = "Neon",
									Color = C3(1, 1, 1),
									SoundID = 174580476,
									SoundPitch = 1,
									SoundVolume = 3
								})
								ROCK:remove()
							end))
							Swait(5)
						end
					end
				end
			end))
			local UNDO = FacialShadow()
			CreateSound(765590102, Torso, 2, MRANDOM(8, 12) / 10, false)
			KEY = Mouse.KeyDown:connect(function(NEWKEY)
				if NEWKEY == "e" then
					KEY:Disconnect()
					PLAYING = true
				end
			end)
			for i = 0, 2, 0.1 / Animation_Speed do
				Swait()
				if PLAYING == true then
					break
				end
				RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
				RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(-5 + 2 * SIN(SINE / 12)), RAD(15), RAD(35)), 0.5 / Animation_Speed)
				Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
				RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.3 * SIZE, -0.6 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			if KEY then
				KEY:Disconnect()
			end
			if PLAYING == true then
				for i = 0, 0.3, 0.1 / Animation_Speed do
					Swait()
					RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
					RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
					Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.5 / Animation_Speed)
					RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(3)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-3)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				FLING = true
				for i = 0, 1, 0.1 / Animation_Speed do
					Swait()
					RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
					RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 2 / Animation_Speed)
					Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 2 / Animation_Speed)
					RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
					LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(3)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-3)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
			UNDO()
		end
	end
	REPLAY = false
	ATTACK = false
	Rooted = false
end
function Uppercut()
	ATTACK = true
	Rooted = false
	local HITS = {}
	Speed = 12
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	CreateSound(588693579, RightArm2, 6, MRANDOM(8, 12) / 10, false)
	for i = 0, 0.3, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({
			EffectType = "Box",
			Size = RightArm2.Size,
			Size2 = RightArm2.Size,
			Transparency = RightArm2.Transparency,
			Transparency2 = 1,
			CFrame = RightArm2.CFrame,
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.4)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(80), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD ~= Character.Model and CHILD.Name ~= Player.Name then
			do
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					do
						local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO and (TORSO.Position - RightArm2.CFrame * CF(0, -2, 0).p).Magnitude <= 15 then
							coroutine.resume(coroutine.create(function()
								CreateSound(260430117, TORSO, 3, MRANDOM(8, 12) / 10, false)
								--local grav = Instance.new("BodyPosition", TORSO)
								--grav.D = 1500
								--grav.P = 20000
								--grav.maxForce = Vector3.new(math.huge, math.huge, math.huge)
								for i = 1, 35 do
									fling(TORSO.Position, 0.1)
								
								end
								
								
								--grav.position = TORSO.Position + VT(0, 25, 0)
								--TORSO.RotVelocity = VT(MRANDOM(-25, 25), MRANDOM(-25, 25), MRANDOM(-25, 25))
								table.insert(HITS, {CHILD, grav})
								--ApplyDamage(HUM, MRANDOM(12, 22))
							end))
						end
					end
				end
			end
		end
	end
	if #HITS > 0 then
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
			until ATTACK == false
			for E = 1, #HITS do
				HITS[E][2]:remove()
			end
		end))
	end
	REPLAY = true
	local PLAYING = false
	local WHACK = false
	local HITTING = 0
	local PAYDOWN = 200
	local UNDO = FacialShadow()
	for i = 0, 0.5, 0.1 / Animation_Speed do
		Swait()
		if PLAYING == true then
			break
		end
		WACKYEFFECT({
			EffectType = "Box",
			Size = RightArm2.Size,
			Size2 = RightArm2.Size,
			Transparency = RightArm2.Transparency,
			Transparency2 = 1,
			CFrame = RightArm2.CFrame,
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = C3(1, 1, 1),
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.5)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(185), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if #HITS > 0 then
		KEY = Mouse.KeyDown:connect(function(NEWKEY)
			if NEWKEY == "r" and WHACK == false then
				if PLAYING == false then
					PLAYING = true
				end
				WHACK = true
				PAYDOWN = 70
				HITTING = HITTING + 1
				for E = 1, #HITS do
					if HITS[E][1] then
						local ROOT = GetRoot(HITS[E][1], true)
						if ROOT then
							local HUM = HITS[E][1]:FindFirstChildOfClass("Humanoid")
							if HUM and HUM.Health > 0 then
								HUM.PlatformStand = true
								CreateSound(260430117, ROOT, 3, MRANDOM(8, 12) / 10, false)
								local HIT, POS = Raycast(ROOT.Position + VT(0, 5, 0), CF(RootPart.Position, RootPart.Position - VT(0, 5, 0)).lookVector, 60, HITS[E][1])
								ROOT.CFrame = CF(POS)
								for i = 1, 35 do
									fling(ROOT.Position, 0.1)
								
								end
								ROOT.RotVelocity = VT(MRANDOM(-25, 25), MRANDOM(-25, 25), MRANDOM(-25, 25)) * 4
								if HIT then
									CreateFlyingDebree(HIT, CF(POS), 5, VT(1, 1, 1) * MRANDOM(7, 15) / 20, 5, 30)
								end
							end
						end
					end
				end
				CreateSound(217767125, RightArm, 10, 1, false)
				for i = 0, 0.25, 0.1 / Animation_Speed do
					Swait()
					RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
					RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-15 - 1 * SIN(SINE / 6))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0.1) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.4) * ANGLES(RAD(-25), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				WHACK = false
			end
		end)
	end
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		if PLAYING == true then
			break
		end
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 3, -5), 0.5)
		RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(45)), 0.5 / Animation_Speed)
		Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
		RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.25 * SIZE, 0.5 * SIZE, -0.25 * SIZE) * ANGLES(RAD(185), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(50 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if PLAYING == true then
		Rooted = true
		repeat
			Swait()
			if WHACK == false then
				PAYDOWN = PAYDOWN - 1
				if PAYDOWN <= 0 then
					PLAYING = false
				end
				RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
				RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(120)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-15 - 1 * SIN(SINE / 6))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.5 * SIZE, -0.5 * SIZE) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(120)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.4) * ANGLES(RAD(-25), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		until PLAYING == false
	end
	if KEY then
		KEY:Disconnect()
	end
	if HITTING > 4 then
		CreateSound(1535994137, Head, 10, 1, false)
		for i = 0, 2.4, 0.1 / Animation_Speed do
			Swait()
			RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(-5 + 2 * SIN(SINE / 12)), RAD(15), RAD(35)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.3 * SIZE, -0.6 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(15), RAD(15)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65, 0) * ANGLES(RAD(170), RAD(0), RAD(-13)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-3)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	end
	UNDO()
	Speed = 16
	REPLAY = false
	ATTACK = false
	Rooted = false
end
function TakeOn()
	ATTACK = true
	Rooted = true
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(-5 + 2 * SIN(SINE / 12)), RAD(15), RAD(35)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.3 * SIZE, -0.6 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		until ATTACK == false
	end))
	CreateSound(1535994669, Head, 10, 1, false)
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5, 0.2) * ANGLES(RAD(-25), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(35)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5, 0.2) * ANGLES(RAD(-25), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
function MouseDown(Mouse)
	if ATTACK == false then
	end
end
function MouseUp(Mouse)
	HOLD = false
end
function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		Punch()
	end
	if Key == "e" and ATTACK == false and REPLAY == false then
		Throw()
	end
	if Key == "r" and ATTACK == false and REPLAY == false then
		Uppercut()
	end
	if Key == "t" and ATTACK == false then
		Roar()
	end
	if Key == "y" and ATTACK == false then
		TakeOn()
	end
end
function KeyUp(Key)
	KEYHOLD = false
end
Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)
function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end
Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and Disable_Jump == true then
		Humanoid.Jump = false
	end
end)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		SINE = SINE + CHANGE
	end
end))
while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _, v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop()
	end
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
	local WALKSPEEDVALUE = 4
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.05 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), -0.125 * COS(SINE / WALKSPEEDVALUE) + 0.2 - 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.4 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), 0.125 * COS(SINE / WALKSPEEDVALUE) + 0.2 + 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.4 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif ANIM ~= "Walk" or TORSOVELOCITY < 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.4 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.4 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -0.4 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.4 * SIZE, -0.5 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(-5 + 2 * SIN(SINE / 12)), RAD(15), RAD(35)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.3 * SIZE, -0.6 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(3)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5, 0.2) * ANGLES(RAD(-25), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(-2), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint2.C0 = Clerp(RootJoint2.C0, ROOTC0 * CF(0, 0, 0.25 * COS(SINE / 12)) * ANGLES(RAD(35 + 2 * SIN(SINE / 12)), RAD(0), RAD(35)), 0.5 / Animation_Speed)
			Neck2.C0 = Clerp(Neck2.C0, NECKC0 * CF(0, 0, 0 + (1 * SIZE - 1)) * ANGLES(RAD(-25 - 2 * SIN(SINE / 12)), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder2.C0 = Clerp(RightShoulder2.C0, CF(1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder2.C0 = Clerp(LeftShoulder2.C0, CF(-1.5 * SIZE, 0.5 * SIZE, 0) * ANGLES(RAD(-35 + 15 * SIN(SINE / 12)), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip2.C0 = Clerp(RightHip2.C0, CF(1 * SIZE, -1 * SIZE, 0) * ANGLES(RAD(0), RAD(80 - 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip2.C0 = Clerp(LeftHip2.C0, CF(-1 * SIZE, -0.5 * SIZE, -0.3 * SIZE) * ANGLES(RAD(-25), RAD(-80 + 1 * SIN(SINE / 6)), RAD(0)) * ANGLES(RAD(-3 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(30 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		end
	end
	if ATTACK == false then
		RootPart2.CFrame = Clerp(RootPart2.CFrame, RootPart.CFrame * CF(0, 6, 5), 0.1)
	end
	unanchor()
	RootPart2.Anchored = true
	Humanoid.MaxHealth = 200
	Humanoid.Health = 200
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	for _, c in pairs(SHADOW:GetChildren()) do
		if c:IsA("Part") then
			--c.Color = C3(1, 1, 1)
			--if c ~= RootPart2 then
				--c.Transparency = E + 0.15 * SIN(SINE / 12)
			--end
			if c then
				c.Transparency = 1
			end
			if c:FindFirstChildOfClass("Decal") then
				c:ClearAllChildren()
			end
			c.CanCollide = false
			c.Material = "Neon"
		else
			c:remove()
		end
	end
	sick.SoundId = "rbxassetid://609005478"
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 1.5
	sick.Parent = Character
	sick.Playing = PLAYSONG
	if EQUIPPED == false then
		Intro()
	end
end
end)

local Tab = Window:NewTab("Collision Scripts")
local Section = Tab:NewSection("Collidable Scripts")

Section:NewButton("Ball", "ButtonInfo", function()
    print("Clicked")
--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --change this if you have a better method
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        local unit = realPartVelocity.Unit
        if (unit.Y > 0.25) or (unit.Y < -0.75) then
            return realPartVelocity * (25.1 / realPartVelocity.Y)
        end
        realPartVelocity = unit * 100
    end
    return (realPartVelocity * Vector3_101) + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = false --set it to true if you want noclip
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
local flingpart = "HumanoidRootPart" --name of the part or the hat used for flinging
--the fling function
--usage: fling(target, duration, velocity)
--target can be set to: basePart, CFrame, Vector3, character model or humanoid (flings at mouse.Hit if argument not provided))
--duration (fling time in seconds) can be set to: a number or a string convertable to the number (0.5s if not provided),
--velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
	    c = nil
	end
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

if type(getNetlessVelocity) ~= "function" then
    getNetlessVelocity = nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment")
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment")
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if getNetlessVelocity then
	    local vel = Part0.Velocity
	    local velpart = Part1
        local rsteppedcon = renderstepped:Connect(function()
            Part0.Velocity = vel
        end)
        local heartbeatcon = heartbeat:Connect(function()
            vel = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(velpart.Velocity)
        end)
        local attcon = nil
        Part0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (Part0 and Part0.Parent) then
                rsteppedcon:Disconnect()
                heartbeatcon:Disconnect()
                attcon:Disconnect()
            end
        end)
        attcon = att1:GetPropertyChangedSignal("Parent"):Connect(function()
	        if not (att1 and att1.Parent) then
	            attcon:Disconnect()
                velpart = Part0
	        else
	            velpart = att1.Parent
	            if not velpart:IsA("BasePart") then
	                velpart = Part0
	            end
	        end
	    end)
	end
	
	att0.Parent = Part0
    att1.Parent = Part1
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
	    model = nil
    end
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						scr:Destroy()
						scr1:Destroy()
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent and (not v:IsDescendantOf(model)) then
		if v:IsA("Decal") then
		    v.Transparency = 1
		elseif v:IsA("BasePart") then
			v.Transparency = 1
			v.Anchored = false
		elseif v:IsA("ForceField") then
			v.Visible = false
		elseif v:IsA("Sound") then
			v.Playing = false
		elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
			v.Enabled = false
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum0 and hum0.Parent) then
            hum0 = nil
        end
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum1 and hum1.Parent) then
            hum1 = nil
        end
    end)
    
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.849,
					LeftLowerArm = -0.174,
					LeftUpperArm = 0.415
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.849,
					RightLowerArm = -0.174,
					RightUpperArm = 0.415
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.29,
					LeftUpperLeg = 0.49
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.29,
					RightUpperLeg = 0.49
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		if hum1 then
    		hum1.RigType = Enum.HumanoidRigType.R6
    		hum1.HipHeight = 0
		end
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v:GetPropertyChangedSignal("Parent"):Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart0 and flingpart0.Parent) then
            flingpart0 = nil
            fling = function() end
        end
    end)
    flingpart0.Archivable = true
    flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart1 and flingpart1.Parent) then
            flingpart1 = nil
            fling = function() end
        end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att0 and att0.Parent) then
                att0 = nil
                fling = function() end
            end
        end)
        att1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att1 and att1.Parent) then
                att1 = nil
                fling = function() end
            end
        end)
        local lastfling = nil
        local mouse = lp:GetMouse()
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                target = mouse.Hit
                if target then
                    target = target.Position
                else
                    return
                end
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (flingpart and flingpart.Parent) then
                    flingpart = nil
                end
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local rsteppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = renderstepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rsteppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end
task.wait(0.75)
local netboost = Vector3.new(0, 25, 0)

local ws = game:GetService("Workspace") 
local rs = game:GetService("RunService")
local lp = game:GetService("Players").LocalPlayer

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att1 = Instance.new("Attachment")
	att1.Orientation = Vector3.new(0, 0, 0)
	att1.Position = Vector3.new(0, 0, 0)
	att1.Archivable = true
	local att0 = att1:Clone()

	local ap = Instance.new("AlignPosition", att0)
	ap.ApplyAtCenterOfMass = false
	ap.MaxForce = 1000
	ap.MaxVelocity = 1000
	ap.ReactionForceEnabled = false
	ap.Responsiveness = 200
	ap.RigidityEnabled = false

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = 1000
	ao.MaxTorque = 1000
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.RigidityEnabled = false

	ap.Attachment1 = att1
	ap.Attachment0 = att0
	ao.Attachment1 = att1
	ao.Attachment0 = att0

	att1.Parent = Part1
	att0.Parent = Part0


	if netboost then
		spawn(function()
			while rs.Heartbeat:Wait() and Part0 and Part0.Parent do
				Part0.Velocity = netboost
			end
		end)
		spawn(function()
			while rs.Stepped:Wait() and Part0 and Part0.Parent and Part1 and Part1.Parent do
				Part0.Velocity = Part1.Velocity
			end
		end)
	end
end
local c = lp.Character.Model
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
local startpart = gp(c, "Torso", "BasePart") or gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart")
if not startpart then
	print("part not found")
	return
end
local size = Vector3.new(6, 6, 6)
local orient = {
	Vector3.new(45 ,-45, 0)
}
local hats = {}
for i, v in pairs(c:GetChildren()) do
	if v:IsA("Accessory") then
		table.insert(hats, v)
	end
end
local allhandles = {}
for i, v in pairs(hats) do
	local handle = gp(v, "Handle", "BasePart")
	if handle then
		table.insert(allhandles, handle)
	end
end
local handles = {}
for i, v in pairs(allhandles) do
	if v.Size == size then
		table.insert(handles, v)
	end
end
if #handles < #orient then
	for i, v in pairs(allhandles) do
		if not table.find(handles, v) then
			table.insert(handles, v)
		end
		if #handles == #orient then
			break
		end
	end
end
if #handles < #orient then
	print("not enough hats")
	return
end
local ball = Instance.new("Part", ws)
ball.Anchored = true
ball.CanCollide = false
ball.CanTouch = false
ball.Transparency = 1
ball.Shape = "Ball"
ball.Size = Vector3.new(8, 8, 8)
ball.Position = startpart.Position
for i, v in pairs(orient) do
	local handle = handles[i]
	handle:ClearAllChildren()
	local part = Instance.new("Part", ball)
	part.Massless = true
	part.Transparency = 1
	part.Anchored = true
	part.CanCollide = false
	part.Position = ball.Position
	part.Orientation = v
	local weld = Instance.new("WeldConstraint", part)
	weld.Part0 = ball
	weld.Part1 = part
	weld.Enabled = true
	handle.Parent = part
	align(handle, part)
	part.Anchored = false
	handle.Changed:Connect(function(prop)
		if (prop == "Parent") and part and part.Parent then
			part:Destroy()
		end
	end)
end
ball.CanCollide = true
ball.Anchored = false
c.Changed:Connect(function(prop)
	if (prop == "Parent") and ball and ball.Parent then
		ball:Destroy()
	end
end)
end)

Section:NewButton("Master Hand (wont fling)", "ButtonInfo", function()
    print("Clicked")


GlobalFunctions = {}
getgenv().HatCollide = true
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
-- -gh 4794315940,48474313,63690008,1103003368,48474294,62234425,451220849,62724852,376524487,3822880197

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

wait(7)

local HatChar = game.Players.LocalPlayer.Character.Model

-- Mesh Remover that probally doesnt work
function removeMesh(hat)
    for i,v in pairs(hat:GetChildren()) do
        if v:IsA("Mesh") or v:IsA("SpecialMesh") then
            v:Destroy()
            print(v)
        end
    end
end


plr = game.Players.LocalPlayer
char=game.Players.LocalPlayer.Character
ct={}
te=table.insert
reanim = char
vargun = false
HumanDied=false
mwouse = plr:GetMouse()


wt = 0.05 s = script it = Instance.new v3 = Vector3.new c3 = Color3.new ud = UDim2.new cf = CFrame.new ca = CFrame.Angles pi = math.pi rd = math.rad
bc = BrickColor.new ab = math.abs de = math.deg ts = tostring tn = tonumber ti = table.insert tr = table.remove  
cr = coroutine.resume cc = coroutine.create
asset = "http://www.roblox.com/asset/?id="
sr = string.reverse sl = string.lower su = string.upper 
Serv = {} Serv.p = game:GetService(sr("sreyalP")) Serv.l = game:GetService(sr("gnithgiL")) 
Serv.is = game:GetService(sr("ecivreStresnI")) if game:findFirstChild(sr("revreSkrowteN")) then Serv.ns = game:GetService(sr("revreSkrowteN")) else NetworkServer = nil end 
Serv.sg = game:GetService(sr("iuGretratS")) Serv.sp = game:GetService(sr("kcaPretratS")) Serv.d = game:GetService(sr("sirbeD"))
Decs = {}
Decs.Crack = "49173398" Decs.Cloud = "1095708" Decs.Spike = "1033714" Decs.Rock = "1290033" Decs.Crown = "1323306"
function ft(tablez,item) if not tablez or not item then return nil end for i=1,#tablez do if tablez[i] == item then return i end end return nil end
function re(par,obj) if type(par) ~= "userdata" or type(obj) ~= "string" then return nil end if par:findFirstChild(obj) then par[obj]:Remove() end end 
function pa(pa,sh,x,y,z,c,a,tr,re,bc2) local fp = nil if sh ~= "Wedge" and sh ~= "CornerWedge" then  fp = it("Part",pa) fp.Shape = sh  fp.formFactor = "Custom" elseif sh == "Wedge" then fp = it("WedgePart",pa)  fp.formFactor = "Custom"
elseif sh == "CornerWedge" then fp = it("CornerWedgePart",pa)  end  fp.Size = v3(x,y,z) fp.CanCollide = c fp.Anchored = false fp.BrickColor = bc(bc2) fp.Transparency = tr fp.Reflectance = re fp.BottomSurface = 0
fp.TopSurface = 0 fp.CFrame = t.CFrame + Vector3.new(0,50,0) fp.Velocity = Vector3.new(0,10,0) fp:BreakJoints() return fp  end 
function clearit(tab) for xx=1,#tab do tab[xx]:Remove() end end 
function weld(pa,p0,p1,x,y,z,a,b,c) local fw = it("Weld",pa) fw.Part0 = p0 fw.Part1 = p1 fw.C0 = cf(x,y,z) *ca(a,b,c) return fw end
function spm(ty,pa,ss) local sp = it("SpecialMesh",pa) sp.MeshType = ty sp.Scale = Vector3.new(ss,ss,ss) end function mbm(pa,sx,sy,sz) local bm = Instance.new("BlockMesh",pa) bm.Scale = Vector3.new(sx,sy,sz) end 
function ra(mn,mx,dc) local tms = 1 if dc == nil then dc = 0 end if type(dc) == "number" and dc > 5 then dc = 5 end for zx=1,dc do tms = tms*10 end   return math.random(mn*tms,mx*tms)/tms end 
p = Serv.p.LocalPlayer -----Your Name Here
bp = p.Backpack
pg = p.PlayerGui
c = p.Character
he = c.Head
t = c.Torso
hu = c.Humanoid
mou = nil
re(c,"Hand")
s = 0.8
     
--tool var
Equip = false
HTrans = 0
HRef = 0
HCol = "a"
LaserCol = "New Yeller"
LaserCol2 = "Really red"
LaserCol3 = "Alder"
Posing = "Follow"
Facing = "Owner"
Anim = {}
Anim.a = "None"
Anim.b = "None"
Anim.Welding = 0
local fingwide = 1.5*s
local finghei = 2.8
local tiphei = 2.55
handoffset = v3(5,18,-8)*s
bgx,bgy,bgz = -90,0,0
w = {}
Button = false 
--
BlastMesh = it("FileMesh")
BlastMesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
RingMesh = it("FileMesh")
RingMesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
RockMesh = it("FileMesh")
DiamondMesh = it("FileMesh")
DiamondMesh.MeshId = "http://www.roblox.com/Asset/?id=9756362"
m = Instance.new("Model",c) m.Name = "Hand"
Palm = pa(m,"Block",6*s,7*s,fingwide*2,true,false,HTrans,HRef,HCol) mbm(Palm,1,1,0.6)
local x,y,z = Palm.Size.x,Palm.Size.y,Palm.Size.z
bPoint1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point1 = weld(bPoint1,Palm,bPoint1,-x/2+(fingwide/2),y/2,0,0,0,0)
pPoint1 = pa(m,"Block",fingwide,finghei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint1,0.9,1,0.9)
wPoint1 = weld(pPoint1,bPoint1,pPoint1,0,pPoint1.Size.y/2,0,0,0,0)
bPoint2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point2 = weld(bPoint2,pPoint1,bPoint2,0,pPoint1.Size.y/2,0,0,0,0)
pPoint2 = pa(m,"Block",fingwide,finghei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint2,0.9,1,0.9)
wPoint2 = weld(pPoint2,bPoint2,pPoint2,0,pPoint1.Size.y/2,0,0,0,0)
bPoint3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Point3 = weld(bPoint3,pPoint2,bPoint3,0,pPoint2.Size.y/2,0,0,0,0)
pPoint3 = pa(m,"Block",fingwide,tiphei*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPoint3,0.9,1,0.9)
wPoint3 = weld(pPoint3,bPoint3,pPoint3,0,pPoint3.Size.y/2,0,0,0,0)
bMid1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid1 = weld(bMid1,Palm,bMid1,-x/2+((fingwide/2)+((fingwide)*1)),y/2,0,0,0,0)
pMid1 = pa(m,"Block",fingwide,(finghei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid1,0.9,1,0.9)
wMid1 = weld(pMid1,bMid1,pMid1,0,pMid1.Size.y/2,0,0,0,0)
bMid2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid2 = weld(bMid2,pMid1,bMid2,0,pMid1.Size.y/2,0,0,0,0)
pMid2 = pa(m,"Block",fingwide,(finghei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid2,0.9,1,0.9)
wMid2 = weld(pMid2,bMid2,pMid2,0,pMid1.Size.y/2,0,0,0,0)
bMid3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Mid3 = weld(bMid3,pMid2,bMid3,0,pMid2.Size.y/2,0,0,0,0)
pMid3 = pa(m,"Block",fingwide,(tiphei*1.1)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pMid3,0.9,1,0.9)
wMid3 = weld(pMid3,bMid3,pMid3,0,pMid3.Size.y/2,0,0,0,0)
bRing1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring1 = weld(bRing1,Palm,bRing1,-x/2+((fingwide/2)+((fingwide)*2)),y/2,0,0,0,0)
pRing1 = pa(m,"Block",fingwide,(finghei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing1,0.9,1,0.9)
wRing1 = weld(pRing1,bRing1,pRing1,0,pRing1.Size.y/2,0,0,0,0)
bRing2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring2 = weld(bRing2,pRing1,bRing2,0,pRing1.Size.y/2,0,0,0,0)
pRing2 = pa(m,"Block",fingwide,(finghei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing2,0.9,1,0.9)
wRing2 = weld(pRing2,bRing2,pRing2,0,pRing1.Size.y/2,0,0,0,0)
bRing3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Ring3 = weld(bRing3,pRing2,bRing3,0,pRing2.Size.y/2,0,0,0,0)
pRing3 = pa(m,"Block",fingwide,(tiphei*0.98)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pRing3,0.9,1,0.9)
wRing3 = weld(pRing3,bRing3,pRing3,0,pRing3.Size.y/2,0,0,0,0)
bPinkie1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie1 = weld(bPinkie1,Palm,bPinkie1,-x/2+((fingwide/2)+((fingwide)*3)),y/2,0,0,0,0)
pPinkie1 = pa(m,"Block",fingwide,(finghei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie1,0.9,1,0.9)
wPinkie1 = weld(pPinkie1,bPinkie1,pPinkie1,0,pPinkie1.Size.y/2,0,0,0,0)
bPinkie2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie2 = weld(bPinkie2,pPinkie1,bPinkie2,0,pPinkie1.Size.y/2,0,0,0,0)
pPinkie2 = pa(m,"Block",fingwide,(finghei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie2,0.9,1,0.9)
wPinkie2 = weld(pPinkie2,bPinkie2,pPinkie2,0,pPinkie1.Size.y/2,0,0,0,0)
bPinkie3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Pinkie3 = weld(bPinkie3,pPinkie2,bPinkie3,0,pPinkie2.Size.y/2,0,0,0,0)
pPinkie3 = pa(m,"Block",fingwide,(tiphei*0.8)*s,fingwide,true,false,HTrans,HRef,HCol) mbm(pPinkie3,0.9,1,0.9)
wPinkie3 = weld(pPinkie3,bPinkie3,pPinkie3,0,pPinkie3.Size.y/2,0,0,0,0)
bThumb1 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb1 = weld(bThumb1,Palm,bThumb1,-x/2+(fingwide/7),-y*0.1,-fingwide*0.25,0,0,0)
pThumb1 = pa(m,"Block",fingwide*1.4,(finghei*1)*s,fingwide*1.4,true,false,HTrans,HRef,HCol) mbm(pThumb1,0.9,1,0.9)
wThumb1 = weld(pThumb1,bThumb1,pThumb1,0,pThumb1.Size.y/2,0,0,0,0)
bThumb2 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb2 = weld(bThumb2,pThumb1,bThumb2,0,pThumb1.Size.y/2,0,0,0,0)
pThumb2 = pa(m,"Block",fingwide*1.3,(finghei*1)*s,fingwide*1.3,true,false,HTrans,HRef,HCol) mbm(pThumb2,0.9,1,0.9)
wThumb2 = weld(pThumb2,bThumb2,pThumb2,0,pThumb1.Size.y/2,0,0,0,0)
bThumb3 = pa(m,"Block",0,0,0,false,false,HTrans,HRef,HCol)
Thumb3 = weld(bThumb3,pThumb2,bThumb3,0,pThumb2.Size.y/2,0,0,0,0)
pThumb3 = pa(m,"Block",fingwide*1.25,(tiphei*1)*s,fingwide*1.25,true,false,HTrans,HRef,HCol) mbm(pThumb3,0.9,1,0.9)
wThumb3 = weld(pThumb3,bThumb3,pThumb3,0,pThumb3.Size.y/2,0,0,0,0)
w["a1"] = Pinkie1
w["a2"] = Pinkie2
w["a3"] = Pinkie3
w["b1"] = Ring1
w["b2"] = Ring2
w["b3"] = Ring3
w["c1"] = Mid1
w["c2"] = Mid2
w["c3"] = Mid3
w["d1"] = Point1
w["d2"] = Point2
w["d3"] = Point3
w["e1"] = Thumb1
w["e2"] = Thumb2
w["e3"] = Thumb3
w.e1.C1 = ca(0,rd(35),rd(-20))
w.e2.C1 = ca(rd(20),0,0)
w.e3.C1 = ca(rd(20),0,0)
w.d1.C1 = ca(0,0,rd(-3))
w.c1.C1 = ca(0,0,rd(-1))
w.b1.C1 = ca(0,0,rd(1))
w.a1.C1 = ca(0,0,rd(3))


function AttachPartsHat(hat,parthand,rotation,position)
hat = cnnnnn[hat].Name
local HatChoice = gp(gp(gp(cnnnnn, hat, "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
HatChoice.Parent = parthand
HatChoice.Position = position or Vector3.new(0,-2,0)
HatChoice.Rotation = rotation or Vector3.new(0,0,0)
parthand.Transparency = 1 --0.8
removeMesh(HatChar[hat].Handle)

end

 AttachPartsHat("MeshPartAccessory",Palm,Vector3.new(0,0,0),Vector3.new(0,0,0))
  AttachPartsHat("Robloxclassicred",bPoint1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
    AttachPartsHat("Pal Hair",bPoint2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
      AttachPartsHat("RedBeanieWithHair",bThumb1,Vector3.new(0,0,0),Vector3.new(0,1.5,0))
        AttachPartsHat("Pink Hair",bRing1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
           AttachPartsHat("Hat1",bRing2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
         AttachPartsHat("LavanderHair",bMid1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
   AttachPartsHat("Kate Hair",bMid2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
    AttachPartsHat("MessyHair",bPinkie1,Vector3.new(90,0,0),Vector3.new(0,1.5,0))
     AttachPartsHat("International Fedora",bPinkie2,Vector3.new(90,0,0),Vector3.new(0,1.5,0))

 pPoint1.Transparency = 1 --0.8

pPoint2.Transparency = 1 --0.8

pPoint3.Transparency = 1

pThumb1.Transparency = 1 --0.8

pThumb2.Transparency = 1

pThumb3.Transparency = 1

pMid1.Transparency = 1 --0.8

pMid2.Transparency = 1 --0.8

pMid3.Transparency = 1

pRing1.Transparency = 1 --0.8

pRing2.Transparency = 1 --0.8

pRing3.Transparency = 1
bRing3.Transparency = 1

pPinkie1.Transparency = 1 --0.8

pPinkie2.Transparency = 1 --0.8

pPinkie3.Transparency = 1

bPinkie1.Transparency = 1 --0.8

bPinkie2.Transparency = 1 --0.8

bPinkie3.Transparency = 1

function c1(wexx,smmx,xx,yy,zz) 
coroutine.resume(coroutine.create(function()
local xx2,yy2,zz2 = wexx.C1:toEulerAnglesXYZ() 
local aa,bb,cc = wexx.C0.x,wexx.C0.y,wexx.C0.z
local twa = smmx/wt
Anim.Welding = Anim.Welding + 1
for i=0,twa,1 do wexx.C0 = cf(aa,bb,cc)
wexx.C1 = ca(xx2-(((xx2-rd(xx))/twa)*i),yy2-(((yy2-rd(yy))/twa)*i),zz2-(((zz2-rd(zz))/twa)*i))
wait()
end 
Anim.Welding = Anim.Welding - 1
end))
end 
function CloseFing(fingz,spee)  if spee == nil then spee = 1 end c1(w[fingz.. "1"],spee,80,0,0) c1(w[fingz.. "2"],spee,110,0,0) c1(w[fingz.. "3"],spee,30,0,0) end
function OpenFing(fingz,spee) if spee == nil then spee = 1 end c1(w[fingz.. "1"],spee,2,0,0) c1(w[fingz.. "2"],spee,2,0,0) c1(w[fingz.. "3"],spee,2,0,0)  end 
function HandSign(form,spee) form = form:lower() if spee == nil then spee = 1 end 
if form == "f" then 
CloseFing("d",spee) CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,0,0,0) c1(w["c2"],spee,0,0,0) c1(w["c3"],spee,0,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "fist" then
CloseFing("d",spee) CloseFing("a",spee) CloseFing("b",spee) CloseFing("c",spee)
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "pointer" then
CloseFing("a",spee) CloseFing("b",spee) CloseFing("c",spee)
c1(w["d1"],spee,5,0,0) c1(w["d2"],spee,5,0,0) c1(w["d3"],spee,5,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "v" then
CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,1,0,15) c1(w["c2"],spee,1,0,0) c1(w["c3"],spee,1,0,0) 
c1(w["d1"],spee,1,0,-15) c1(w["d2"],spee,1,0,0) c1(w["d3"],spee,1,0,0) 
c1(w["e1"],spee,70,40,-90) c1(w["e2"],spee,50,0,0) c1(w["e3"],spee,50,0,0) 
elseif form == "free" or form == "five" then
OpenFing("a",spee) OpenFing("b",spee) OpenFing("c",spee) OpenFing("d",spee) 
c1(w["e1"],spee,0,35,-20) c1(w["e2"],spee,20,0,0) c1(w["e3"],spee,20,0,0) 
elseif form == "ride" then 
c1(w["a1"],spee,60,0,0) c1(w["a2"],spee,-30,0,0) c1(w["a3"],spee,-30,0,0) 
c1(w["b1"],spee,30,0,0) c1(w["b2"],spee,65,0,0) c1(w["b3"],spee,60,0,0) 
c1(w["c1"],spee,30,0,0) c1(w["c2"],spee,65,0,0) c1(w["c3"],spee,60,0,0) 
c1(w["d1"],spee,30,0,0) c1(w["d2"],spee,65,0,0) c1(w["d3"],spee,60,0,0) 
c1(w["e1"],spee,-70,185,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
elseif form == "gun" then


CloseFing("a",spee) CloseFing("b",spee)
c1(w["c1"],spee,0,0,1) c1(w["c2"],spee,0,0,0) c1(w["c3"],spee,0,0,0) 
c1(w["d1"],spee,0,0,-1) c1(w["d2"],spee,0,0,0) c1(w["d3"],spee,0,0,0) 
c1(w["e1"],spee,-60,90,0) c1(w["e2"],spee,20,0,0) c1(w["e3"],spee,-20,0,0) 
elseif form == "wide" then
c1(w["a1"],spee,-3,0,45) c1(w["a2"],spee,-3,0,0) c1(w["a3"],spee,-3,0,0) 
c1(w["b1"],spee,-3,0,15) c1(w["b2"],spee,-3,0,0) c1(w["b3"],spee,-3,0,0) 
c1(w["c1"],spee,-3,0,-15) c1(w["c2"],spee,-3,0,0) c1(w["c3"],spee,-3,0,0) 
c1(w["d1"],spee,-3,0,-45) c1(w["d2"],spee,-3,0,0) c1(w["d3"],spee,-3,0,0) 
c1(w["e1"],spee,-70,90,0) c1(w["e2"],spee,10,0,0) c1(w["e3"],spee,-10,0,0) 
elseif form == "wide2" then
c1(w["a1"],spee,-18,0,45) c1(w["a2"],spee,36,0,0) c1(w["a3"],spee,30,0,0) 
c1(w["b1"],spee,-18,0,15) c1(w["b2"],spee,36,0,0) c1(w["b3"],spee,30,0,0) 
c1(w["c1"],spee,-18,0,-15) c1(w["c2"],spee,36,0,0) c1(w["c3"],spee,30,0,0) 
c1(w["d1"],spee,-18,0,-45) c1(w["d2"],spee,36,0,0) c1(w["d3"],spee,30,0,0) 
c1(w["e1"],spee,-50,90,-10) c1(w["e2"],spee,5,0,-30) c1(w["e3"],spee,-10,0,-40) 
elseif form == "grab2" then
c1(w["a1"],spee,-70,-65,0) c1(w["a2"],spee,40,0,0) c1(w["a3"],spee,20,0,0) 
c1(w["b1"],spee,-70,-20,0) c1(w["b2"],spee,40,0,0) c1(w["b3"],spee,20,0,0) 
c1(w["c1"],spee,-70,20,-0) c1(w["c2"],spee,40,0,0) c1(w["c3"],spee,20,0,0) 
c1(w["d1"],spee,-70,65,-0) c1(w["d2"],spee,40,0,0) c1(w["d3"],spee,20,0,0) 
c1(w["e1"],spee,-70,150,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
elseif form == "grab3" then
c1(w["a1"],spee,-30,-40,30) c1(w["a2"],spee,50,0,0) c1(w["a3"],spee,35,0,0) 
c1(w["b1"],spee,-30,-15,12) c1(w["b2"],spee,50,0,0) c1(w["b3"],spee,35,0,0) 
c1(w["c1"],spee,-30,15,-12) c1(w["c2"],spee,50,0,0) c1(w["c3"],spee,35,0,0) 
c1(w["d1"],spee,-30,40,-30) c1(w["d2"],spee,50,0,0) c1(w["d3"],spee,35,0,0) 
c1(w["e1"],spee,-55,205,0) c1(w["e2"],spee,30,0,0) c1(w["e3"],spee,30,0,0) 
end
end
function ColFings(iscol)
pPinkie1.CanCollide = iscol
pPinkie2.CanCollide = iscol
pPinkie3.CanCollide = iscol
pRing1.CanCollide = iscol
pRing2.CanCollide = iscol
pRing3.CanCollide = iscol
pMid1.CanCollide = iscol
pMid2.CanCollide = iscol
pMid3.CanCollide = iscol
pPoint1.CanCollide = iscol
pPoint2.CanCollide = iscol
pPoint3.CanCollide = iscol
pThumb1.CanCollide = iscol
pThumb2.CanCollide = iscol
pThumb3.CanCollide = iscol
end
function ray(Pos, Dir) 
return Workspace:FindPartOnRay(Ray.new(Pos, Dir.unit *999), c) 
end 
function Earthsplosion(pos,siz,dmg,rndmg,forc,eos) local colz22 = "Earth green" if eos == nil or eos == "earth" then eos = "earth" else colz22 = "Pastel brown" eos = "sand" end 
coroutine.resume(coroutine.create(function() 
if eos == "earth" then local cr = pa(m,"Block",((14*siz)/10)*s,0,((14*siz)/10)*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = pos *ca(rd(0),rd(ra(-360,360)),rd(0)) cr.CFrame = cr.CFrame + v3(ra(-siz*10,siz*10)/22,0,ra(-siz*10,siz*10)/22)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,25) end
for i=1,4 do
coroutine.resume(coroutine.create(function() 
local sw = pa(m,"Block",(siz/3)*s,(siz*1.3)*s,(siz/3)*s,true,true,0,0,colz22) sw.Anchored = true sw.CFrame = pos *cf(ra(-3*s,3*s),0,ra(-3*s,3*s)) *ca(rd(ra(-27,27)),rd(ra(-360,360)),rd(ra(-27,27))) local swm = it("SpecialMesh",sw) if eos == "earth" then swm.MeshType = "FileMesh"
swm.MeshId = asset .. Decs.Spike else swm.MeshType = "Sphere" end if eos == "earth" then swm.Scale = v3(sw.Size.x/1.3,sw.Size.y*1.2,sw.Size.z/1.3)
else swm.Scale = v3(sw.Size.x/10,sw.Size.y/37,sw.Size.z/10) end sw.CFrame = sw.CFrame + v3(ra(-0.3*siz*s,0.3*siz*s,7),0,ra(-0.3*siz*s,0.3*siz*s)) sw.CFrame = sw.CFrame * cf(0,-sw.Size.y/1.4,0)
Dustplosion(cf(pos.p+v3(0,2*s,0)),18*s,{"Dark green","Bright green","Brown"},1)
if eos == "earth" then 
for x=1,8 do
sw.CFrame = sw.CFrame *cf(0,sw.Size.y/8,0) wait() end wait(ra(1,5))
for x=1,20 do
sw.CFrame = sw.CFrame *cf(0,-sw.Size.y/20,0) wait()
end sw:Remove()
else 
for x=1,25 do
sw.CFrame = sw.CFrame *cf(0,sw.Size.y/25,0) sw.Transparency = x/25 - 0.1 swm.Scale = swm.Scale + v3(0.025,0.025,0.025) wait() end
end sw:Remove()
end)) end 
wait(0.3)
DmgHumanoidsNear(pos.p,dmg,rndmg,5.5*s*(siz/4),forc)
end))
end
function Dustplosion(onb,scale,col,cls) coroutine.resume(coroutine.create(function() 
for x=1,cls do coroutine.resume(coroutine.create(function()  
local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col[ra(1,#col)]) sw.Anchored = true sw.CFrame = onb *ca(rd(ra(-35,35)),rd(ra(-360,360)),rd(ra(-35,35))) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh"
swm.MeshId = asset .. Decs.Cloud sw.CFrame = sw.CFrame + v3(ra(-scale,scale)/8,ra(-scale,scale)/8,ra(-scale,scale)/8) 
for i=1,scale,0.25 do 
swm.Scale = v3(i*1.5,i*1,i*1.5) sw.Transparency = ((i/scale)/2) + 0.45
wait()
end
sw:Remove()
end)) end 
end)) end 
function ShockWave(onb,scale,col) coroutine.resume(coroutine.create(function()  local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col) sw.Anchored = true sw.CFrame = onb *ca(rd(90),0,0) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh" swm.MeshId = RingMesh.MeshId  
for i=1,scale,0.75 do  swm.Scale = v3(i*1.5,i*1.5,i*1.5) sw.Transparency = (i/scale) + 0 wait() end sw:Remove() end)) end 
function BlastWave(onb,scale,ymes,col) coroutine.resume(coroutine.create(function() 
local sw = pa(m,"Block",1*s,0,1*s,false,false,0.2,0,col) sw.Anchored = true sw.CFrame = onb *ca(rd(0),0,0) local swm = it("SpecialMesh",sw) swm.MeshType = "FileMesh"
swm.MeshId = BlastMesh.MeshId 
for i=1,scale,scale/11 do 
swm.Scale = v3(i*1.25,i*ymes,i*1.25) sw.CFrame = sw.CFrame *ca(0,rd(720*(i/scale)),0) sw.Transparency = (i/scale) + 0
wait()
end
sw:Remove()
end))
end 
function Explode(onb,scale,col) local Torm = m coroutine.resume(coroutine.create(function() local e1 = Instance.new("Part") e1.Anchored = true e1.formFactor = "Custom" e1.CanCollide = false e1.Size = Vector3.new(1,1,1) e1.BrickColor = BrickColor.new(col) 
e1.Transparency = 0.6 e1.TopSurface = 0 e1.BottomSurface = 0 e1.Parent = Torm e1.CFrame = onb local e1m = Instance.new("SpecialMesh") 
e1m.MeshType = "Sphere" e1m.Parent = e1 local r1 = Instance.new("Part") r1.Anchored = true r1.formFactor = "Custom" r1.CanCollide = false r1.Size = Vector3.new(1,1,1) r1.BrickColor = BrickColor.new(col) r1.Transparency = 0.6 r1.TopSurface = 0 r1.BottomSurface = 0 r1.Parent = Torm r1.CFrame = e1.CFrame *CFrame.Angles(math.rad(180),0,0) local r1m = Instance.new("SpecialMesh") r1m.MeshType = "FileMesh" 
r1m.Scale = Vector3.new(3,3,3) r1m.Parent = r1 r1m.MeshId = RingMesh.MeshId local r2 = Instance.new("Part") r2.Anchored = true r2.formFactor = "Custom" r2.CanCollide = false r2.Size = Vector3.new(1,1,1) r2.BrickColor = BrickColor.new(col) r2.Transparency = 0.6 r2.TopSurface = 0 r2.BottomSurface = 0 r2.Parent = Torm r2.CFrame = e1.CFrame *CFrame.Angles(0,math.rad(180),0) local r2m = Instance.new("SpecialMesh") r2m.MeshType = "FileMesh" 
r2m.Parent = r2 r2m.Scale = Vector3.new(3,3,3) r2m.MeshId = RingMesh.MeshId local bla = Instance.new("Part") bla.Anchored = true 
bla.formFactor = "Custom" bla.CanCollide = false bla.Size = Vector3.new(1,1,1)  bla.BrickColor = BrickColor.new(col) bla.Transparency = 0.6 bla.TopSurface = 0 bla.BottomSurface = 0 bla.Parent = Torm bla.CFrame = onb local blam = Instance.new("SpecialMesh") 
blam.MeshType = "FileMesh" blam.Parent = bla blam.Scale = Vector3.new(5,5,5) blam.MeshId = BlastMesh.MeshId for i=1,30 do local pluscal = scale/38 e1m.Scale = e1m.Scale + Vector3.new(pluscal,pluscal,pluscal) 
r1m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal) r2m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal)
blam.Scale = blam.Scale + Vector3.new(pluscal,pluscal/2,pluscal) bla.CFrame = bla.CFrame * CFrame.Angles(0,math.rad(12),0) r1.CFrame = r1.CFrame * CFrame.Angles(math.rad(6),0,0) r2.CFrame = r2.CFrame * CFrame.Angles(0,math.rad(6),0) wait() end for i=1,30 do local pluscal = scale/38 e1m.Scale = e1m.Scale + Vector3.new(pluscal,pluscal,pluscal)  r1m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal) r2m.Scale = r1m.Scale + Vector3.new(pluscal,pluscal,pluscal)
blam.Scale = blam.Scale + Vector3.new(pluscal/3,pluscal/3,pluscal/3) bla.CFrame = bla.CFrame * CFrame.Angles(0,math.rad(12),0) r1.CFrame = r1.CFrame * CFrame.Angles(math.rad(6),0,0) r2.CFrame = r2.CFrame * CFrame.Angles(0,math.rad(6),0) bla.Transparency = bla.Transparency + 0.1 e1.Transparency = e1.Transparency + 0.1 r1.Transparency = r1.Transparency + 0.1 r2.Transparency = r2.Transparency + 0.1 wait() end e1:Remove() r1:Remove() r2:Remove() end)) end
function Hurtsplosion(pos,dmg,rndmg,siz,forc)
coroutine.resume(coroutine.create(function() local boomcol = {"Bright red","New Yeller","Neon orange"}
for i=1,3 do 
coroutine.resume(coroutine.create(function()
local plos = pa(m,"Block",1*s*siz,1.5*s*siz,0.7*s*siz,false,false,0.3,0,boomcol[i]) spm("Sphere",plos,1) plos.Anchored = true
plos.CFrame = cf(pos + v3(0,0,0)) * ca(rd(ra(-360,360)),rd(ra(-360,360)),rd(ra(-360,360)))
plos.Mesh.Scale = v3(0.1,0.1,0.1)
for i=0.3,1,0.03 do local plc = plos.CFrame
plos.Mesh.Scale = v3(i*6,i*6,i*6) plos.Transparency = i plos.CFrame = plc * ca(rd(3),rd(3),0)
wait()
end
plos:Remove()
end))
end 
end))
wait(0.1)
DmgHumanoidsNear(pos,dmg,rndmg,5.5*s*siz,forc)
end
function DmgHumanoidsNear(pos,dmg,rndmg,mag,forc) 
    --[[
local function kidive(ob) 
for i,v in pairs(ob:children()) do 
if v:IsA("BasePart") and v.Parent.Parent:findFirstChild("Humanoid") == nil and v.Parent:findFirstChild("Humanoid") == nil and (v.Position - pos).magnitude < mag*1.3 and v.Anchored == false  and v:GetMass() < 150 then 
 
end
if v:IsA("Humanoid") and v ~= hu and v.Parent:findFirstChild("Torso") then 
if (pos - v.Parent.Torso.Position).magnitude < mag then local tdmg = dmg*ra(1,rndmg) 
if v.Parent:findFirstChild("Hh") == nil then local hh= Instance.new("NumberValue",v.Parent) hh.Name = "Hh"
hh.Value = v.Health - tdmg else v.Parent.Hh.Value = v.Health - (tdmg*3.5) end 
 if v.Parent.Hh.Value < 1 then end 
end  
end 
if v:IsA("Model") or v:IsA("Workspace") then kidive(v) end end end 
kidive(workspace)  ]]
end 
function Fire(bullet,typez,siz,dmg,rndmg,forc)
if typez == 1 then
bullet.Anchored = true 
local bullethit = false
local tyms = 0
repeat
tyms = tyms + 2
local bhit,bpos = ray(bullet.Position,bullet.Position - (bullet.CFrame *cf(0,0,-1)).p) 
if bpos ~= nil and (bpos - bullet.Position).magnitude < 7  then bullethit = true else bullet.CFrame = bullet.CFrame *cf(0,0,-1*s) *ca(rd(-0.0025),rd(0),0) end 
if tyms%32 == 0 then wait() end 
until bullethit or bullet.Position.y < -300 or tyms > 800 
bullet.CFrame = bullet.CFrame *cf(0,0,8) bullet:Remove()
if bullet.Position.y < -300 then
else
Hurtsplosion(bullet.Position,dmg,rndmg,siz,forc)
end
elseif typez == 2 then
bullet.Anchored = true 
local bullethit = false
local tyms = 0
local ming = 0.001
repeat 
if tyms > 70 and (ming == 0.001 or ming == -2.5) then ming = -2.5
local bpos = (bullet.CFrame *cf(0,0,-300)).p if (bpos - v3(Palm.Position.x,bpos.y,Palm.Position.z)).magnitude < 25*s then ming = 0 end 
end
tyms = tyms + 2
local bhit,bpos = ray(bullet.Position,bullet.Position - (bullet.CFrame *cf(0,0,-1)).p) 
if bpos ~= nil and (bpos - bullet.Position).magnitude < 7  then bullethit = true else bullet.CFrame = bullet.CFrame *cf(0,0,-0.5) *ca(rd(ming),rd(0),0) end
if tyms%16 == 0 then wait() end 
until bullethit or bullet.Position.y < -300 or tyms > 500 
bullet.CFrame = bullet.CFrame *cf(0,0,8) bullet:Remove()
if bullet.Position.y < -300 then
else
Hurtsplosion(bullet.Position,dmg,rndmg,siz,forc)
end
elseif typez == 3 then 
end
end 
function ShortifiedAnim(theanim)
if theanim == "Beam" then
local crom = pa(m,"Block",0,0,0,true,true,0.5,0,LaserCol3) local cromm = it("SpecialMesh",crom) cromm.MeshType = "FileMesh" cromm.MeshId = asset .. Decs.Crown
cromm.Scale = v3(15*s,5*s,15*s) crom.Anchored = true --local cromw = weld(crom,Palm,crom,0,Palm.Size.y/3.6,-Palm.Size.z*1.8,rd(-90),0,0)
dias = {} loldiv = 360/8 for x=0,360,loldiv do 
local dia = pa(m,"Block",0,0,0,false,false,0,0,LaserCol2) dia.Anchored = true local diam = it("SpecialMesh",dia) diam.MeshType = "FileMesh" diam.MeshId = DiamondMesh.MeshId
diam.Scale = v3(3*s,9*s,3*s) table.insert(dias,dia)
end Button = true coroutine.resume(coroutine.create(function() local tardz = 0 repeat wait() tardz = tardz+ 15
crom.CFrame = Palm.CFrame *ca(rd(-90),0,0) *cf(0,5.5*s,2*s) *ca(0,rd(tardz),0) 
for rofl=1,#dias do dias[rofl].CFrame = crom.CFrame *ca(0,rd(rofl*loldiv),0) *cf(0,-19*s,0) *ca(rd(25),0,0) *cf(0,32*s,0) end 
 until not Button for x2=0.5,1,0.05 do wait() crom.Transparency = x2 end   end))
coroutine.resume(coroutine.create(function() for xk=1,0.5,-0.02 do wait() for i=1,#dias do dias[i].Transparency =xk end end end))
wait(1) local beamoffset = v3(0,0,0)
local b1 = pa(m,"Ball",10*s,10*s,10*s,false,false,0.1,0,LaserCol) b1.Anchored = true 
local b2 = pa(m,"Block",10*s,1,10*s,false,false,0.1,0,LaserCol) b2.Anchored = true  local b2m = it("CylinderMesh",b2)
local b3 = pa(m,"Ball",10*s,10*s,10*s,false,false,0.1,0,LaserCol) b3.Anchored = true 
local bpos = nil local bhit = nil local ts = 0
 repeat beamoffset = v3(ra(-2*s,2*s),ra(-2*s,2*s),ra(-2*s,2*s)) ts = ts + 1
bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,0,1)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 1500 then break end 
b1.CFrame = Palm.CFrame *cf(0,3*s,-11*s) 
b3.CFrame = cf(bpos) local lenz = (b1.Position - b3.Position).magnitude 
b2.CFrame = cf(b1.Position,b3.Position) *ca(rd(90),0,0) *cf(0,-lenz/2,0)  b2m.Scale = v3(1,lenz,1)
b1.CFrame = b1.CFrame + beamoffset b2.CFrame = b2.CFrame + beamoffset b3.CFrame = b3.CFrame + beamoffset 
if ts%10 == 0 then DmgHumanoidsNear(b3.Position,3,10,(14*s)+2,100) Explode(b3.CFrame*cf(0,b3.Size.y/3,0),25*s,LaserCol2) end
wait()  until not Button or ts > 600
  coroutine.resume(coroutine.create(function() for xk=0.1,1.1,0.08 do wait() b1.Transparency = xk  b2.Transparency = xk  b3.Transparency = xk  end b1:Remove() b2:Remove() b3:Remove() end))
 coroutine.resume(coroutine.create(function() for xk=0.5,1.1,0.02 do wait() for i=1,#dias do dias[i].Transparency =xk end end end))
wait(1)  clearit(dias) crom:Remove()
end
end 
PalmLev = it("BodyPosition",Palm) 
PalmFace = it("BodyGyro",Palm) PalmFace.maxTorque = v3(0,0,0)
coroutine.resume(coroutine.create(function()
PalmLev.position = (t.CFrame *cf(handoffset)).p
local yspi = 0
while true do yspi = yspi + 8
if Anim.a == "Gun" or Anim.a == "Ride" or Anim.a == "Pound" then 
Facing = "Mouse" bgx = -90 bgy = 90 bgz = 0 
elseif Anim.a == "Fu" or Anim.a == "Fist" or Anim.a == "GroundGrip" then 
Facing = "Mouse" bgx = -90 bgy = 0 bgz = 0 
elseif Anim.a == "Splat" or Anim.a == "Beam" then
Facing = "Mouse" bgx = 0 bgy = 0 bgz = 0 
elseif Anim.a == "None" then 
Facing = "Owner" bgx = -90 bgy = 0 bgz = 0 Posing = "Follow"
elseif Anim.a == "Shower" then
Facing = "None" bgx = 0 bgy = 0 bgz = 0 Posing = "TopOwner"
end 
if Posing == "Follow" then 
PalmLev.maxForce = v3(1/0,1/0,1/0) PalmLev.position = (t.CFrame *cf(handoffset) *cf(0,0,0)).p 
elseif Posing == "TopOwner" then
PalmLev.maxForce = v3(1/0,1/0,1/0) PalmLev.position = (t.CFrame *cf(0,12*s,0)).p 
end 
if Facing == "Owner" then 
PalmFace.maxTorque = v3(1/0,1/0,1/0) PalmFace.cframe = cf(Palm.Position,he.Position) *ca(rd(bgx),rd(bgy),rd(bgz))
elseif Facing == "Mouse" and mou ~= nil and Equip then 
if Anim.a == "Gun" or Anim.a == "Beam" or Anim.a == "Ride" or Anim.a == "GroundGrip" or Anim.a == "Fu" or Anim.a == "Pound" or Anim.a == "Splat" or Anim.a == "Fist" then 
if Anim.b == "None" or Anim.a == "Beam" or Anim.a == "Ride" then 
PalmFace.cframe = cf(Palm.Position,mou.Hit.p) *ca(rd(bgx),rd(bgy),rd(bgz)) wait(0.05)
end end end
wait(0.05)
end 
end))
function FireFinger(lasercol,ffingz,targ,typez,siz,dmg,rndmg,forc) coroutine.resume(coroutine.create(function() 
local laser = pa(m,"Block",fingwide*1.3,fingwide*1.3,fingwide*2.5,true,false,0,0,lasercol) spm("Sphere",laser,1+(siz/5.5)) laser.Name = "Projectile"
local lw = weld(laser,ffingz,laser,0,ffingz.Size.y/0.8 +(siz/2.5),0,rd(90),0,0)
for i=1,0.4,-0.05 do laser.Transparency = i wait() end 
BlastWave(ffingz.CFrame*cf(0,ffingz.Size.y*1.3,0)*ca(0,0,0),ffingz.Size.x*1.6,1.8,LaserCol2)
lw:Remove() laser.CFrame = cf(laser.Position,targ)
Fire(laser,typez,siz,dmg,rndmg,forc) 
end))
end
GrabWeld = it("Weld",m)
Palm.Touched:connect(function(touch)
print(touch) print(touch.Parent)  print(touch.Parent.Parent)
if Anim.a == "Ride" and GrabWeld.Part1 == nil and touch.Parent:findFirstChild("HumanoidRootPart") and touch.Parent:findFirstChild("Humanoid") then
local tor = touch.Parent.HumanoidRootPart touch.Parent.Humanoid.PlatformStand = true 
GrabWeld.Part0 = Palm GrabWeld.Part1 = tor GrabWeld.C0 = cf(-3*s,4.5*s,-Palm.Size.x/2) GrabWeld.C1 = ca(0,rd(90),rd(-90)) *ca(0,rd(0),0)
end
end)
re(bp,"Hand")
hb = it("HopperBin",bp) hb.Name = "Hand"
hb.Selected:connect(function(mouse) mou = mouse Equip = true
mouse.KeyDown:connect(function(k)  k = k:lower()
if Anim.a == "Ride" and k == "f" then FireFinger(LaserCol,pPinkie3,mouse.Hit.p,1,2.25,1,18,30)  end
if Anim.b ~= "None" or Anim.Welding ~= 0 then  return end 
if Anim.a == "None" then
if k == "f" then -- on anim on
Anim.a = "Gun" HandSign("Gun",0.7)
vargun = true
elseif k == "p" then
Anim.a = "Fu" HandSign("f",1)
elseif k == "g" then
Anim.a = "Fist" HandSign("fist",1)
elseif k == "c" then
Anim.a = "Splat" HandSign("wide",1)
elseif k == "r" then
Anim.a = "Ride" HandSign("ride",1) Posing = "None"
elseif k == "v" then
Anim.a = "Shower" HandSign("grab2",1) PalmFace.cframe = cf(0,0,0) *ca(0,0,0)
elseif k == "b" then
Anim.a = "Pound" HandSign("fist",1)
elseif k == "x" then
Anim.a = "GroundGrip" HandSign("grab2",1)
elseif k == "z" then
Anim.a = "Beam" HandSign("wide2",1) 
end 
else
if k == "f" and Anim.a == "Gun" then -- on anim off
vargun = false
Anim.a = "None" HandSign("five",0.8)
elseif k == "p" and Anim.a == "Fu" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "g" and Anim.a == "Fist" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "c" and Anim.a == "Splat" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "r" and Anim.a == "Ride" then
Anim.a = "None" HandSign("five",0.8) GrabWeld.Part0 = nil Anim.b = "None" Posing = "Follow"  Facing = "Owner"
if GrabWeld.Part1 ~= nil and GrabWeld.Part1.Parent:findFirstChild("Humanoid") ~= nil then GrabWeld.Part1.Parent.Humanoid.PlatformStand = false end GrabWeld.Part1 = nil
elseif k == "v" and Anim.a == "Shower" then
Anim.a = "None" HandSign("five",0.8) Posing = "Follow" Facing = "Owner"
elseif k == "b" and Anim.a == "Pound" then
Anim.a = "None" HandSign("five",0.8)
elseif k == "x" and Anim.a == "GroundGrip" then 
Anim.a = "None" HandSign("five",0.8)
elseif k == "z" and Anim.a == "Beam" then 
Anim.a = "None" HandSign("five",0.8)
end
end
end)
mouse.Button1Down:connect(function()
if Anim.a == "None" or Anim.b ~= "None" then return end 
if Anim.a == "Gun" then
Anim.b = "Gun" FireFinger(LaserCol,pPoint3,mouse.Hit.p,1,2.25,1,10,60) FireFinger(LaserCol,pMid3,mouse.Hit.p,1,2.25) wait(1) Anim.b = "None"
elseif Anim.a == "Fu" then
Anim.b = "Fu" FireFinger(LaserCol,pMid3,mouse.Hit.p,1,3.65,2,14,95) wait(0.25) Anim.b = "None"
elseif Anim.a == "Fist" then 
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
Anim.b = "Fist" Posing = "None" PalmFace.cframe = cf(Palm.Position,bpos) *ca(rd(-90),0,0)
PalmLev.position = (Palm.CFrame *cf(0,-15*s,0)).p
wait(0.45)
PalmLev.position = bpos + ((Palm.CFrame *cf(0,1*s,0)).p - Palm.Position)
local tz = 0 repeat wait()  BlastWave(Palm.CFrame*ca(rd(180),0,0),8*s,3.5,HCol) tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 8*s or tz > 1
Explode(Palm.CFrame *cf(0,6*s,0) *ca(rd(180),0,0),15*s,ts(bhit.BrickColor))
DmgHumanoidsNear((Palm.CFrame *cf(0,8,0)).p,3,10,(12*s)+2,105)
if not bhit.Anchored then PalmLev.position = (Palm.CFrame *cf(0,12*s,0)).p wait(0.5) end 
wait(1) Posing = "Follow" Anim.b = "None"
elseif Anim.a == "Splat" then
if mouse.Target == nil and (Palm.Position - mouse.Hit.p).magnitude > 500 then return end local bpos = mouse.Hit.p
Anim.b = "Splat" Posing = "None" 
local ya,yb,yc = PalmFace.cframe:toEulerAnglesXYZ() PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(-90),0,0) PalmLev.position = bpos + v3(0,10*s,0)
local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 5*s or tz > 1.3 
for i=-90,0,5 do 
PalmLev.position = PalmLev.position + v3(0,2*s,0) PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(i),0,0)
wait()
end  wait(0.2)
for i=0,-100,-10 do 
local lewd = i
if lewd < -50 then lewd = -95 end 
PalmLev.position = PalmLev.position - v3(0,4.7*s,0) PalmFace.cframe = cf(0,0,0) *ca(0,yb,0) *ca(rd(lewd),0,0)
wait()
end wait(0.2)
local cr = pa(m,"Block",16*s,0,16*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = cf(bpos) *ca(0,rd(ra(-360,360)),0)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,16)
DmgHumanoidsNear((Palm.CFrame *cf(0,0,-1)).p,3,20,(15*s)+2,110)
ShockWave(Palm.CFrame *ca(rd(90),0,0),25*s,LaserCol)
wait(1) Posing = "Follow" Anim.b = "None"
elseif Anim.a == "Ride" and Button == false then
Posing = "None" Anim.b = "Ride"
Button = true
repeat PalmLev.position = (Palm.CFrame *cf(0,10,0)).p wait() until Button == false
 Anim.b = "None"
elseif Anim.a == "Shower" and Button == false then
Anim.b = "Shower" Button = true 
repeat
local targz = Palm.Position + v3(0,20*s,0)
if ra(1,12) == 1 then FireFinger(LaserCol,pPinkie3,targz,2,4,1,18,55) end
if ra(1,13) == 1 then FireFinger(LaserCol,pRing3,targz,2,4,1,18,60) end
if ra(1,12) == 1 then FireFinger(LaserCol,pMid3,targz,2,4,1,18,65) end
if ra(1,13) == 1 then FireFinger(LaserCol,pPoint3,targz,2,4,1,18,70) end
if ra(1,12) == 1 then FireFinger(LaserCol,pThumb3,targz,2,4,1,18,80) end
PalmFace.cframe = PalmFace.cframe *ca(0,rd(10),0)
wait()
until Button == false
Anim.b = "None" 
elseif Anim.a == "Pound" and Anim.b == "None" then Posing = "None" Anim.b = "Pound"
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
PalmLev.position = bpos + v3(0,15*s,0) 
local ya,yb,yc = PalmFace.cframe:toEulerAnglesXYZ() PalmFace.cframe = ca(ya,yb,yc) 
 local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 5*s or tz > 1.3  wait(0.1)
for i=-90,-10,10 do
PalmFace.cframe = ca(ya,yb,yc) *ca(0,0,rd(i+90)) PalmLev.position = PalmLev.position + v3(0,2.5*s,0)
wait() end wait(0.25) local realcf = cf(v3(he.Position.x,0,he.Position.z),v3(Palm.Position.x,0,Palm.Position.z))
for i=-10,-90,-10 do
PalmFace.cframe =  ca(ya,yb,yc) *ca(0,0,rd(i+90)) PalmLev.position = PalmLev.position - v3(0,4*s,0)
wait() end PalmFace.cframe = realcf *ca(rd(-90),rd(90),0) wait(0.25)
local cr = pa(m,"Block",22*s,0,22*s,false,false,1,0,"") cr.Anchored = true cr.CFrame = cf(bpos) *ca(0,rd(ra(-360,360)),0)
local de = it("Decal",cr) de.Face = "Top" de.Texture = asset .. Decs.Crack Serv.d:AddItem(cr,16)
Dustplosion(Palm.CFrame *cf(2*s,0,0) *ca(rd(90),0,rd(90)),30*s,{"Dark green","Bright green","Brown"},3)
ShockWave(Palm.CFrame *cf(2*s,0,0) *ca(rd(90),0,rd(90)),20*s,ts(bhit.BrickColor))
DmgHumanoidsNear((Palm.CFrame *cf(0,1,0)).p,1,20,(15*s)+2,90) wait(0.2)
local palmcf = cf(bpos) local earthsplos = ra(5,8) palmcf = Palm.CFrame *ca(0,rd(90),0) *ca(rd(-90),0,rd(0))
for i=1,earthsplos do Earthsplosion(palmcf *cf(0,-2*s,((i*7)+7)*s),10,1,20,75) wait(0.1) end 
Earthsplosion(palmcf *cf(0,-2*s,(((earthsplos+1)*7)+7)*s),16,2,25,75)
      wait(1) Posing = "Follow" wait(0.25) Anim.b = "None" 
elseif Anim.a == "GroundGrip" then Posing = "None" Anim.b = "GroundGrip"
local bhit,bpos = ray(Palm.Position,Palm.Position - (Palm.CFrame *cf(0,-1,0)).p) 
if bhit == nil or (Palm.Position - bpos).magnitude > 500 then return end 
PalmLev.position = bpos + v3(0,27*s,0) ColFings(false)
local tz = 0 repeat wait() tz = tz + wait() until (PalmLev.position - Palm.Position).magnitude < 8*s or tz > 1.3  wait(0.1)
local thepos = (Palm.CFrame *cf(0,-0.1*s,0)).p - Palm.Position
PalmFace.cframe = cf(Palm.Position,bpos + thepos) *ca(rd(-90),0,0)
for i=27,1,-3 do PalmLev.position = bpos + v3(0,i*s,0) wait(0.07) end HandSign("grab3",0.4) wait(0.55)
local ro = pa(m,"Ball",0,0,0,false,false,0,0,"Earth green") ro.Name = "Rock" local row = it("SpecialMesh",ro) row.MeshType = "FileMesh" row.MeshId = asset .. Decs.Rock
local rowe = weld(ro,Palm,ro,0,Palm.Size.y,-Palm.Size.z*1.2,0,0,0) row.Scale = v3(9*s,10*s,9*s)
coroutine.resume(coroutine.create(function() for xz=1,70,7 do PalmLev.position = bpos + v3(0,xz*s,0) wait(0.06) end end))
wait(0.25) Dustplosion(cf(bpos),30*s,{"Dark green","Bright green","Brown"},3) local lolra = ra(-360,360)
Earthsplosion(cf(bpos),25,1,20,125,"sand") for yyy=0,360,60 do  coroutine.resume(coroutine.create(function()
for zzz=1,4 do 
Earthsplosion(cf(bpos) *ca(0,rd(yyy+lolra),0) *cf(0,0,zzz*15*s),10,1,20,75) wait(0.14)
end wait(0.25) Earthsplosion(cf(bpos) *ca(0,rd(yyy+lolra),0) *cf(0,0,5*18*s),25,1,20,120)  end)) end 
wait(0.3) HandSign("grab2",0.5) wait(0.75) Serv.d:AddItem(ro,20) rowe:Remove() ro.CanCollide = true local rocf = ro.CFrame ro.Size=v3(14*s,14*s,14*s) ro.CFrame = rocf wait(0.75) ColFings(true) Posing = "Follow" Anim.b = "None" 
elseif Anim.a == "Beam" and not Button and Anim.b == "None" then Anim.b = "Beam" 
ShortifiedAnim("Beam") wait(0.5) Anim.b = "None"
end
end)
mouse.Button1Up:connect(function()
Button = false
end)
mouse.Move:connect(function() 
end)
end)
hb.Deselected:connect(function(mouse)
Equip = false
end)
--lego
game.Players.LocalPlayer.Character.Humanoid.MaxHealth = math.huge  -----Put your name where it says "YourNameHere"
print(lego)

click = false

mwouse.Button1Down:Connect(function()
    click=true
    end)
    
 mwouse.Button1Up:Connect(function()
    click=false
    end)

    if getgenv().HatCollide == false then
--[[]]
game:GetService("RunService").Heartbeat:Connect(function()
    mwouse.TargetFilter=char
    if vargun == true then 
    if click == true then
    GlobalFunctions.fling(mwouse.Hit.p)
    --bppart.Position=mwouse.Hit.p
    --char['Right Arm'].Position=mwouse.Hit.p
    else
    --bppart.Position=char["Pal Hair"].Handle.Position
    --char['Right Arm'].Position=char["Pal Hair"].Handle.Position
    end
    else
    if click == true then
    GlobalFunctions.fling(mwouse.Hit.p)
    --bppart.Position=mwouse.Hit.p
    --char['Right Arm'].Position=mwouse.Hit.p
    else
    --bppart.Position=reanim.VANS_Umbrella.Handle.Position
    --char['Right Arm'].Position=reanim.VANS_Umbrella.Handle.Position
    end
    end
    end) 

end
end)

local Tab = Window:NewTab("Hats")
local Section = Tab:NewSection("Clicking these will set the hats to your clipboard")

Section:NewButton("server admin", "copies hat ids to clipboard", function()
setclipboard("376526673,4391384843,3822880197,4047554959,4094878701,3409612660,3940375351,3656493304,4794315940,4315489767")
end)

Section:NewButton("Thor", "copies hat ids to clipboard", function()
setclipboard("63690008,6114844034,6114875330,6114870953")
end)

Section:NewButton("Master Hand", "copies hat ids to clipboard", function()
setclipboard("4794315940,48474313,63690008,1103003368,48474294,62234425,451220849,62724852,376524487,3822880197")
end)

Section:NewButton("Katanarist", "copies hat ids to clipboard", function()
setclipboard("9923864659,6114844034,")
end)

Section:NewButton("Engineer", "copies hat ids to clipboard", function()
setclipboard("2493718915,48474313,8763338397,8763318146,8763347709,8763290412,8763328018,5134896593,6202292790")
end)


Section:NewButton("The Boys", "copies hat ids to clipboard", function()
setclipboard("5555611932")
end)

Section:NewButton("Atlas Axe", "copies hat ids to clipboard", function()
setclipboard("5555611932,8527979605")
end)

Section:NewButton("Frost Giant", "copies hat ids to clipboard", function()
setclipboard("4878136110,1744219293,18015906,30845203,1744235800,1743941933,4753437569,9661543986,9350274205,9560392730")
end)

Section:NewButton("Pro Knife", "copies hat ids to clipboard", function()
setclipboard("7170680556")
end)

Section:NewButton("Mercenary", "copies hat ids to clipboard", function()
setclipboard("7604371176,6202097932")
end)

Section:NewButton("Glitcher free", "copies hat ids to clipboard", function()
setclipboard("4391384843,3822880197,4047554959,4094878701,3409612660,3940375351,3992084515,3656493304")
end)

Section:NewButton("Internal war free", "copies hat ids to clipboard", function()
setclipboard("376548738,63690008,451220849,48474313,617605556,48474294,62724852,62234425")
end)

Section:NewButton("Achromatic free", "copies hat ids to clipboard", function()
setclipboard("3940375351,3409612660,4094878701,4047554959,3822880197,4391384843")
end)

Section:NewButton("Studio Dummy V1 free", "copies hat ids to clipboard", function()
setclipboard("376527115")
end)

Section:NewButton("Eyo Zen", "copies hat ids to clipboard", function()
setclipboard("4132848799,10406930154,20011897")
end)

Section:NewButton("Parkour free (no hats)", "copies hat ids to clipboard", function()
setclipboard("Never gonna give you up")
end)

Section:NewButton("Ball", "copies hat ids to clipboard", function()
setclipboard("4753437569")
end)

local Tab = Window:NewTab("Credits")
local Section = Tab:NewSection("Credit to luvbxe#1893 for making the hub")
Section:NewButton("copy x2qiz server to clipboard", "title reads all", function()
setclipboard("https://discord.gg/TqejqctcPD")
end)
local Section = Tab:NewSection("copper#0001 for minor tweaks")
local Section = Tab:NewSection("Deia#1057 for some converts *Main dev*")
local Section = Tab:NewSection("OmarXploits#4197 The whitelist")
local Section = Tab:NewSection("B0NEZ#9706 Obfusticate")